MR_DEF = $(MR_HOME)/mapreduce/definitions.hh 
MASTER_DEP = $(MR_HOME)/master/master_job.hh 
MASTER_DEP += $(MR_HOME)/master/master_task.hh 
MASTER_DEP += $(MR_HOME)/master/connslave.hh 
MASTER_DEP += $(MR_HOME)/master/connclient.hh
MASTER_DEP += $(MR_HOME)/common/msgaggregator.hh
SLAVE_DEP = $(MR_HOME)/slave/slave_job.hh
SLAVE_DEP += $(MR_HOME)/slave/slave_task.hh
ECLIPSE_DEP = $(MR_HOME)/file_distributor/fileserver.hh
ECLIPSE_DEP += $(MR_HOME)/file_distributor/filepeer.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/filebridge.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/messagebuffer.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/file_connclient.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/writecount.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/iwriter.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/idistributor.hh 
ECLIPSE_DEP += $(MR_HOME)/file_distributor/ireader.hh 
ECLIPSE_DEP += $(MR_HOME)/orthrus/histogram.hh 
ECLIPSE_DEP += $(MR_HOME)/orthrus/cache.hh 
ECLIPSE_DEP += $(MR_HOME)/orthrus/datablock.hh 
ECLIPSE_DEP += $(MR_HOME)/orthrus/dataentry.hh 
ECLIPSE_DEP += $(MR_HOME)/common/msgaggregator.hh 
CACHESERVER_DEP = $(MR_HOME)/orthrus/histogram.hh
CACHESERVER_DEP += $(MR_HOME)/orthrus/cacheserver.cc
CACHESERVER_DEP += $(MR_HOME)/orthrus/cacheclient.hh
CACHESERVER_DEP += $(MR_HOME)/orthrus/iwfrequest.hh
DHT_FLAG = -I $(MR_HOME)/DHT/
DHT_FLAG += -I $(MR_HOME)/common/ 
DHT_FLAG += $(DHT_OBJ)
DHT_FLAG += -L $(MR_HOME)/common/
CCFLAGS = -Wall -g

all:
	echo Type ether: [make nfs], [make hdfs], [make dht] [make clean]

dht: $(MR_HOME)/make_version/master_dht $(MR_HOME)/make_version/slave_dht $(MR_HOME)/make_version/client_dht $(MR_HOME)/make_version/mcc_dht $(MR_HOME)/bin/mrcat_core $(MR_HOME)/bin/fd_core $(MR_HOME)/common/hash.o $(MR_HOME)/bin/eclipse $(MR_HOME)/bin/cacheserver
	touch $(MR_HOME)/make_version/dht_mode

nfs: $(MR_HOME)/make_version/master_nfs_hdfs $(MR_HOME)/make_version/slave_nfs_hdfs $(MR_HOME)/make_version/client_nfs_hdfs $(MR_HOME)/make_version/mcc_nfs $(MR_HOME)/common/hash.o
	rm -f $(MR_HOME)/make_version/dht_mode

hdfs: $(MR_HOME)/make_version/master_nfs_hdfs $(MR_HOME)/make_version/slave_nfs_hdfs $(MR_HOME)/make_version/client_nfs_hdfs $(MR_HOME)/make_version/mcc_hdfs $(MR_HOME)/common/hash.o
	rm -f $(MR_HOME)/make_version/dht_mode


$(MR_HOME)/make_version/master_dht: $(MR_HOME)/master/dht/master.cc $(MR_HOME)/master/dht/master.hh $(MR_DEF) $(MASTER_DEP) $(DHT_OBJ) $(MR_HOME)/make_version/master $(MR_HOME)/common/hash.o $(MR_HOME)/orthrus/histogram.hh
	g++ $(CCFLAGS) $(MR_HOME)/master/dht/master.cc -o $(MR_HOME)/bin/master -I $(MR_HOME) $(DHT_FLAG) $(MR_HOME)/common/hash.o -lpthread 
	touch $(MR_HOME)/make_version/master
	touch $(MR_HOME)/make_version/master_dht

$(MR_HOME)/make_version/master_nfs_hdfs: $(MR_HOME)/master/master.cc $(MR_HOME)/master/master.hh $(MR_DEF) $(MASTER_DEP) $(MR_HOME)/make_version/master
	g++ $(CCFLAGS) $(MR_HOME)/master/master.cc -o $(MR_HOME)/bin/master -I $(MR_HOME) -lpthread 
	touch $(MR_HOME)/make_version/master
	touch $(MR_HOME)/make_version/master_nfs_hdfs


$(MR_HOME)/make_version/slave_dht: $(MR_HOME)/slave/dht/slave.cc $(MR_HOME)/slave/dht/slave.hh $(MR_DEF) $(DHT_OBJ) $(SLAVE_DEP) $(MR_HOME)/make_version/slave $(MR_HOME)/common/msgaggregator.hh
	g++ $(CCFLAGS) $(MR_HOME)/slave/dht/slave.cc -o $(MR_HOME)/bin/slave -I $(MR_HOME) $(DHT_FLAG) -lpthread 
	touch $(MR_HOME)/make_version/slave
	touch $(MR_HOME)/make_version/slave_dht

$(MR_HOME)/make_version/slave_nfs_hdfs: $(MR_HOME)/slave/slave.cc $(MR_HOME)/slave/slave.hh $(MR_DEF) $(SLAVE_DEP) $(MR_HOME)/make_version/slave
	g++ $(CCFLAGS) $(MR_HOME)/slave/slave.cc -o $(MR_HOME)/bin/slave -I $(MR_HOME) -lpthread 
	touch $(MR_HOME)/make_version/slave
	touch $(MR_HOME)/make_version/slave_nfs_hdfs


$(MR_HOME)/make_version/client_dht: $(MR_HOME)/client/dht/client.cc $(MR_HOME)/client/dht/client.hh $(MR_DEF) $(MR_HOME)/make_version/client
	g++ $(CCFLAGS) $(MR_HOME)/client/dht/client.cc -o $(MR_HOME)/bin/client -I $(MR_HOME) -lpthread
	touch $(MR_HOME)/make_version/client
	touch $(MR_HOME)/make_version/client_dht

$(MR_HOME)/make_version/client_nfs_hdfs: $(MR_HOME)/client/client.cc $(MR_HOME)/client/client.hh $(MR_DEF) $(MR_HOME)/make_version/client
	g++ $(CCFLAGS) $(MR_HOME)/client/client.cc -o $(MR_HOME)/bin/client -I $(MR_HOME) -lpthread
	touch $(MR_HOME)/make_version/client
	touch $(MR_HOME)/make_version/client_nfs_hdfs


$(MR_HOME)/make_version/mcc_nfs: $(MR_HOME)/mcc/nfs/mcc.cc $(MR_HOME)/mcc/nfs/mcc.hh $(MR_HOME)/mapreduce/nfs/mapreduce.hh $(MR_HOME)/make_version/mcc $(MR_DEF)
	g++ $(CCFLAGS) $(MR_HOME)/mcc/nfs/mcc.cc -o $(MR_HOME)/bin/mcc -I $(MR_HOME) 
	touch $(MR_HOME)/make_version/mcc
	touch $(MR_HOME)/make_version/mcc_nfs

$(MR_HOME)/make_version/mcc_hdfs: $(MR_HOME)/mcc/hdfs/mcc.cc $(MR_HOME)/mcc/hdfs/mcc.hh $(MR_HOME)/mapreduce/hdfs/mapreduce.hh $(MR_HOME)/make_version/mcc $(MR_DEF)
	g++ $(CCFLAGS) $(MR_HOME)/mcc/hdfs/mcc.cc -o $(MR_HOME)/bin/mcc -I $(MR_HOME) 
	touch $(MR_HOME)/make_version/mcc
	touch $(MR_HOME)/make_version/mcc_hdfs

$(MR_HOME)/make_version/mcc_dht: $(MR_HOME)/mcc/dht/mcc.cc $(MR_HOME)/mcc/dht/mcc.hh $(MR_HOME)/mapreduce/dht/mapreduce.hh $(MR_HOME)/make_version/mcc $(MR_DEF)
	g++ $(CCFLAGS) $(MR_HOME)/mcc/dht/mcc.cc -o $(MR_HOME)/bin/mcc -I $(MR_HOME) 
	touch $(MR_HOME)/make_version/mcc
	touch $(MR_HOME)/make_version/mcc_dht

$(MR_HOME)/bin/eclipse: $(MR_DEF) $(MR_HOME)/orthrus/launcher.cc $(MR_HOME)/common/hash.o $(ECLIPSE_DEP)
	g++ -g $(CCFLAGS) $(MR_HOME)/orthrus/launcher.cc -I $(MR_HOME) -I $(MR_HOME)/common -I $(MR_HOME)/orthrus $(MR_HOME)/common/hash.o -o $(MR_HOME)/bin/eclipse

$(MR_HOME)/bin/cacheserver: $(MR_DEF) $(CACHESERVER_DEP)
	g++ $(CCFLAGS) $(MR_HOME)/orthrus/cacheserver.cc -I $(MR_HOME) -I $(MR_HOME)/common -o $(MR_HOME)/bin/cacheserver


$(MR_HOME)/DHT/DHTserver.o: $(MR_HOME)/DHT/DHTserver.cc $(MR_HOME)/DHT/DHTserver.hh
	g++ $(CCFLAGS) -c $(MR_HOME)/DHT/DHTserver.cc -o $(MR_HOME)/DHT/DHTserver.o -I $(MR_HOME)/DHT/ -I $(MR_HOME)/common/ 

$(MR_HOME)/DHT/DHTclient.o: $(MR_HOME)/DHT/DHTclient.cc $(MR_HOME)/DHT/DHTclient.hh
	g++ $(CCFLAGS) -c $(MR_HOME)/DHT/DHTclient.cc -o $(MR_HOME)/DHT/DHTclient.o -I $(MR_HOME)/DHT/ -I $(MR_HOME)/common/ 


$(MR_HOME)/make_version/master:
	touch $(MR_HOME)/make_version/master

$(MR_HOME)/make_version/mcc:
	touch $(MR_HOME)/make_version/mcc

$(MR_HOME)/make_version/slave:
	touch $(MR_HOME)/make_version/slave

$(MR_HOME)/make_version/client:
	touch $(MR_HOME)/make_version/client


$(MR_HOME)/bin/fd_core: $(MR_HOME)/file_distributor/fd_core.cc $(MR_DEF) $(MR_HOME)/common/hash.o
	g++ $(CCFLAGS) $(MR_HOME)/file_distributor/fd_core.cc -o $(MR_HOME)/bin/fd_core -I $(MR_HOME)/ $(MR_HOME)/common/hash.o

$(MR_HOME)/bin/mrcat_core: $(MR_HOME)/file_distributor/mrcat_core.cc $(MR_DEF) $(MR_HOME)/common/hash.o
	g++ $(CCFLAGS) $(MR_HOME)/file_distributor/mrcat_core.cc -o $(MR_HOME)/bin/mrcat_core -I $(MR_HOME)/ $(MR_HOME)/common/hash.o

$(MR_HOME)/common/utils.o: $(MR_HOME)/common/utils.cc $(MR_HOME)/common/utils.hh
	g++ $(CCFLAGS) -c $(MR_HOME)/common/utils.cc -o $(MR_HOME)/common/utils.o -I $(MR_HOME)/common

$(MR_HOME)/common/hash.o: $(MR_HOME)/common/hash.cc $(MR_HOME)/common/hash.hh
	g++ $(CCFLAGS) -c $(MR_HOME)/common/hash.cc -o $(MR_HOME)/common/hash.o -I $(MR_HOME)/common

clean:
	rm -f $(MR_HOME)/bin/master
	rm -f $(MR_HOME)/bin/slave
	rm -f $(MR_HOME)/bin/client
	rm -f $(MR_HOME)/bin/mcc
	rm -f $(MR_HOME)/bin/eclipse
	rm -f $(MR_HOME)/DHT/DHTserver.o
	rm -f $(MR_HOME)/DHT/DHTclient.o
	rm -f $(MR_HOME)/make_version/*
	rm -f $(MR_HOME)/bin/fd_core
	rm -f $(MR_HOME)/bin/cacheserver
wc -l \
\
Makefile \
countline.sh \
run.sh \
run_without_fd.sh \
clear_mr.sh \
killall.sh \
setup.conf \
\
bin/fd \
bin/mrls \
bin/mrrm \
bin/mrcat \
\
client/client.cc \
client/client.hh \
\
mapreduce/definitions.hh \
mapreduce/nfs/mapreduce.hh \
mapreduce/hdfs/mapreduce.hh \
mapreduce/dht/mapreduce.hh \
\
master/master.cc \
master/master.hh \
master/dht/master.cc \
master/dht/master.hh \
master/connclient.hh \
master/connslave.hh \
master/master_job.hh \
master/master_task.hh \
\
mcc/nfs/mcc.cc \
mcc/nfs/mcc.hh \
mcc/hdfs/mcc.cc \
mcc/hdfs/mcc.hh \
mcc/dht/mcc.cc \
mcc/dht/mcc.hh \
\
slave/slave.cc \
slave/slave.hh \
slave/dht/slave.cc \
slave/dht/slave.hh \
slave/slave_job.hh \
slave/slave_task.hh \
\
common/fileclient.hh \
common/msgaggregator.hh \
\
file_distributor/writecount.hh \
file_distributor/iwriter.hh \
file_distributor/idistributor.hh \
file_distributor/ireader.hh \
file_distributor/fd_core.cc \
file_distributor/mrcat_core.cc \
file_distributor/fileserver.hh \
file_distributor/filebridge.hh \
file_distributor/filepeer.hh \
file_distributor/file_connclient.hh \
file_distributor/messagebuffer.hh \
\
orthrus/launcher.cc \
orthrus/cacheserver.cc \
orthrus/iwfrequest.hh \
orthrus/histogram.hh \
orthrus/datablock.hh \
orthrus/dataentry.hh \
orthrus/cache.hh
#usage: sh run.sh

# transfer the text files if dht mode is built
if [ -e $MR_HOME/make_version/dht_mode ]
then
	fd
fi

echo "Launching master..."
$MR_HOME/bin/master &

# sleep 1 seconds to ensure the initialization of master before slave starts
sleep 1

#numslave=$(awk '$1=="num_slave"{print $2}' setup.conf)

i=0
for line in `cat nodelist.conf`
do
	echo "Launching slave $i"
	ssh $line $MR_HOME/bin/slave &
	(( i++ ))
done

if [ -e $MR_HOME/make_version/dht_mode ]
then
	echo "Launching cache server"
	$MR_HOME/bin/cacheserver &

	i=0
	for line in `cat nodelist.conf`
	do
		echo "Launching eclipse $i"
		ssh $line $MR_HOME/bin/eclipse &
		(( i++ ))
	done
fi

wait
#usage: sh run.sh

echo "Launching master..."
$MR_HOME/bin/master &

# sleep 1 seconds to ensure the initialization of master before slave starts
sleep 1

#numslave=$(awk '$1=="num_slave"{print $2}' setup.conf)

i=0
for line in `cat nodelist.conf`
do
	echo "Launching slave $i"
	ssh $line $MR_HOME/bin/slave &
	(( i++ ))
done

if [ -e $MR_HOME/make_version/dht_mode ]
then
	echo "Launching cache server"
	$MR_HOME/bin/cacheserver &

	i=0
	for line in `cat nodelist.conf`
	do
		echo "Launching eclipse $i"
		ssh $line $MR_HOME/bin/eclipse &
		(( i++ ))
	done
fi

wait
rm -f /scratch/youngmoon01/mr_storage/.job*

for line in `cat nodelist.conf`
do
	ssh $line rm -f $DHT_PATH/.job* &
done

wait
i=0
for line in `cat nodelist.conf`
do
	echo "Shutting down slave in node $i"
	ssh $line killall slave &
	(( i++ ))
done

wait

echo -e "\033[0;32mDone\033[0m"

i=0
for line in `cat nodelist.conf`
do
	echo "Shutting down eclipse in node $i"
	ssh $line killall eclipse &
	(( i++ ))
done

wait

echo -e "\033[0;32mDone\033[0m"

for program in $*
do
	i=0
	for line in `cat nodelist.conf`
	do
		echo "Shutting down $program in node $i"
		ssh $line killall $program &
		(( i++ ))
	done
	wait
done

echo -e "\033[0;32mDone\033[0m"

echo "Shutting down master node..."

killall master
killall cacheserver

for program in $*
do
	killall $program
done

echo -e "\033[0;32mDone\033[0m"
master_address 192.168.1.201
port 7001
dhtport 7002
max_job 1024
#!/bin/sh

# remove the existing file list and distribution table
echo "Deleting garbage file on DHT PATH in all slave nodes..."

rm -f $MR_PATH/inputlist.conf
rm -f $MR_PATH/dist.sh

# remove the existing input files
for line in `cat nodelist.conf`
do
	ssh $line mrrm &
done

wait

echo -e "\033[0;32mDone\033[0m"

# make new file list
echo "Generating file list..."

for file in `ls $MR_PATH`
do
	if [[ $file == *".txt" ]]
	then
		echo $file >> $MR_PATH/inputlist.conf
	fi
done

echo -e "\033[0;32mDone\033[0m"


# make new distribution table
echo "Generating file distribution table..."

$MR_HOME/bin/fd_core inputlist.conf dist.sh

echo -e "\033[0;32mDone\033[0m"

# distribute the file according to the distribution table
echo "Distributing the files..."

sh $MR_PATH/dist.sh

echo -e "\033[0;32mDone\033[0m"
#!/bin/sh

i=1
for line in `cat $MR_HOME/nodelist.conf`
do
	echo -e "\033[0;32mSlave$i:\033[0m"
	if (( $# > 0 ))
	then
		if [ $1 == "all" ]
		then
			ssh $line ls -a $DHT_PATH
		else
			ssh $line ls $DHT_PATH
		fi
	else
		ssh $line ls $DHT_PATH
	fi

	echo
	(( i++ ))
done
#!/bin/sh

for file in `ls -a $DHT_PATH`
do
	if [[ $file != hostname && $file != . && $file != .. ]]
	then
		rm -f $DHT_PATH/$file
	fi
done

#!/bin/sh

mrcat_core $1

sh $MR_PATH/mrcat.sh
#include "client.hh"
#include <iostream>
#include <fstream>
#include <string>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <netdb.h>
#include <mapreduce/definitions.hh>

using namespace std;

char read_buf[BUF_SIZE];
char write_buf[BUF_SIZE];
char master_address[BUF_SIZE];
int port = -1;
int dhtport = -1;
int masterfd = -1;
bool master_is_set = false;

int main(int argc, char** argv)
{
	// usage
	if(argc<2)
	{
		cout<<"Insufficient arguments: at least 1 argument needed"<<endl;
		cout<<"usage: client [request]"<<endl;
		cout<<"Exiting..."<<endl;
		return 1;
	}

	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			conf>>token;
			strcpy(master_address, token.c_str());
			master_is_set = true;
		}
		else
		{
			cout<<"[client]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();
	// verify initialization
	if(port == -1)
	{
		cout<<"[client]port should be specified in the setup.conf"<<endl;
		exit(1);
	}
	if(master_is_set == false)
	{
		cout<<"[client]master_address should be specified in the setup.conf"<<endl;
		exit(1);
	}
	// copy request command to write buffer
	if(strncmp(argv[1], "stop", 4) == 0)
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf,"stop");
	}
	else if(strncmp(argv[1], "numslave", 8) == 0)
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "numslave");
	}
	else if(strncmp(argv[1], "numclient", 9) == 0)
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "numclient");
	}
	else if(strncmp(argv[1], "numjob", 6) == 0)
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "numjob");
	}
	else if(strncmp(argv[1], "help", 4) == 0)
	{
		// TODO: lists request and their usage

		exit(0);
	}
	/*
	else if(strncmp(argv[1], "submit", 6) == 0) // submit a job
	{
		// compile the submitted job
		if(argc<3)
		{
			cout<<"The file name to submit is missing"<<endl;
			cout<<"usage: client submit [program path]"<<endl;
			cout<<"Exiting..."<<endl;
			return 1;
		}

		string args = argv[2];

		string writestring = "submit ";
		writestring.append(args);

		for(int i=3; i<argc; i++)
		{
			args = argv[i];
			writestring.append(" ");
			writestring.append(args);
		}

		// TODO: argument passing should be implemented when needed

		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, writestring.c_str());

		// TODO: Check if the file exist and if it's executable
		cout<<"Submitting the job..."<<endl;
	}
	*/
	else
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, argv[1]);
	}

	masterfd = connect_to_server(master_address, port);
	if(masterfd<0)
	{
		cout<<"Connecting to master failed"<<endl;
		exit(1);
	}

	// set sockets to be non-blocking socket to avoid deadlock
	fcntl(masterfd, F_SETFL, O_NONBLOCK);

	// start listener thread
	pthread_t listener_thread;
	pthread_create(&listener_thread, NULL, signal_listener, (void*)&masterfd);


	// sleeping loop which prevents process termination
	while(1)
		sleep(1);

	return 0;
}

int connect_to_server(char *host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent *hp;

	// SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd<0)
	{
		cout<<"Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);

	if (hp == NULL)
	{
		cout<<"Cannot find host by host name"<<endl;
		return -1;
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void* signal_listener(void* args)
{
	int serverfd = *((int*)args);
	int readbytes = 0;
	char tmp_buf[BUF_SIZE];
	while(1)
	{
		readbytes = nbread(serverfd, read_buf);
		if(readbytes == 0) // connection closed from master
		{
			cout<<"Connection from master is abnormally closed"<<endl;
			close(serverfd);
			exit(0);
		}
		else if(readbytes < 0) // no signal arrived
		{
			continue;
		}
		else // a signal arrived from master
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				// respond to "whoareyou"
				memset(tmp_buf, 0, BUF_SIZE);
				strcpy(tmp_buf, "client");
				nbwrite(serverfd, tmp_buf);

				// request to master
				nbwrite(serverfd, write_buf);
			}
			else if(strncmp(read_buf, "close", 5) == 0)
			{
				cout<<"Close request from master"<<endl;
				close(serverfd);
				cout<<"Exiting client..."<<endl;
				exit(0);
			}
			else if(strncmp(read_buf, "result", 6) == 0)
			{
				cout<<read_buf<<endl;
				close(serverfd);
				exit(0);
			}
			else
			{
				cout<<"Signal from master: "<<read_buf<<endl;
			}
		}

		// sleeps for 0.0001 seconds. change this if necessary
		// usleep(100);
	}
	close(serverfd);

	cout<<"Exiting client..."<<endl;
	exit(0);
}
#ifndef __CLIENT__
#define __CLIENT__

int connect_to_server(char *host, unsigned short port); // function which connect to the master
void *signal_listener(void *args); // thread function used to communicate with the master

#endif
#ifndef __DEFINITIONS__
#define __DEFINITIONS__

#include <iostream>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

using namespace std;

// HDFS
#define HDMR_PATH "/user/youngmoon01/mr_storage/"
#define HDFS_PATH "/home/youngmoon01/hadoop-2.2.0/include/"
#define JAVA_LIB "/home/youngmoon01/jdk1.7.0_17/jre/lib/amd64/server/"
#define HDFS_LIB "/home/youngmoon01/hadoop-2.2.0/lib/native/"
#define HADOOP_FLAG "-lhdfs"
#define JAVA_FLAG "-ljvm"


#define DHT_PATH "/scratch/youngmoon01/mr_storage/"
#define MR_PATH "/home/youngmoon01/mr_storage/"
#define IPC_PATH "/scratch/youngmoon01/socketfile"
#define LIB_PATH "/home/youngmoon01/MRR/src/"
#define BUF_SIZE (8*1024) // determines maximum size of a record
#define BUF_THRESHOLD (7*1024) // the buffer flush threshold
#define BUF_CUT 512
#define CACHESIZE (1*1024*1024*1024) // 1 GB of cache size
#define BLOCKSIZE (512*1024) // 512 KB sized block <- should be multiple of BUF_SIZE

#define IBLOCKSIZE (64*1024*1024) // size of intermediate flush threshold

// EM-KDE
#define ALPHA 0.001
#define NUMBIN 100 // number of histogram bins in the EM-KDE scheduling
#define UPDATEINTERVAL 5000 // update interval in msec
#define KERNELWIDTH 2 // number of bins affected by count_query() function: 1 + 2*KERNELWIDTH (except the boundary bins)

#define MAP_SLOT 16
#define REDUCE_SLOT 16


#define HASHLENGTH 64

#define BACKLOG 16384

enum mr_role
{
	JOB,
	MAP,
	REDUCE
};

enum datatype
{
	RAW,
	INTERMEDIATE,
	OUTPUT
};

enum task_status
{
	WAITING,
	RUNNING,
	COMPLETED
};

enum job_stage
{
	INITIAL_STAGE,
	MAP_STAGE,
	REDUCE_STAGE,
	COMPLETED_STAGE // not used but reserved for future use
};

enum bridgetype // bridge source and destination type
{
	PEER,
	DISK,
	CACHE,
	CLIENT,
	DISTRIBUTE // distribute the intermediate result of specific app + input pair
};

enum transfertype // data transfer type. packet or stream
{
	PACKET,
	STERAM
};

enum file_role 
{
	READ,
	WRITE,
	UNDEFINED
};

// non-blocking write
int nbwrite(int fd, char* buf, char* contents) // when the content should be specified
{
	int written_bytes;
	memset(buf, 0, BUF_SIZE);
	strcpy(buf, contents);
	while((written_bytes = write(fd, buf, BUF_CUT*(strlen(buf)/BUF_CUT+1))) < 0)
	{
		if(errno == EAGAIN)
		{
			// do nothing as default
		}
		else if(errno == EBADF)
		{
			cout<<"\twrite function failed due to EBADF, retrying..."<<endl;
		}
		else if(errno == EFAULT)
		{
			cout<<"\twrite function failed due to EFAULT, retrying..."<<endl;
		}
		else if(errno == EFBIG)
		{
			cout<<"\twrite function failed due to EFBIG, retrying..."<<endl;
		}
		else if(errno == EINTR)
		{
			cout<<"\twrite function failed due to EINTR, retrying..."<<endl;
		}
		else if(errno == EINVAL)
		{
			cout<<"\twrite function failed due to EINVAL, retrying..."<<endl;
		}
		else if(errno == EIO)
		{
			cout<<"\twrite function failed due to EIO, retrying..."<<endl;
		}
		else if(errno == ENOSPC)
		{
			cout<<"\twrite function failed due to ENOSPC, retrying..."<<endl;
		}
		else if(errno == EPIPE)
		{
			cout<<"\twrite function failed due to EPIPE, retrying..."<<endl;
		}
		else
		{
			cout<<"\twrite function failed due to unknown reason(debug needed)..."<<endl;
			return -1;
		}

		// sleep 1 milli seconds to prevent busy waiting
		usleep(1000);
	}
	if(written_bytes != BUF_CUT*((int)strlen(buf)/BUF_CUT+1))
	{
		int progress = written_bytes;
		int remain = BUF_CUT*(strlen(buf)/BUF_CUT+1) - written_bytes;
		while(remain > 0)
		{
			written_bytes = write(fd, buf+progress, remain);

			if(written_bytes > 0)
			{
				progress += written_bytes;
				remain -= written_bytes;
			}

			// sleep 1 milli seconds to prevent busy waiting
			usleep(1000);
		}
	}

	return written_bytes;
}

// non-blocking write
int nbwrite(int fd, char* buf) // when the content is already on the buffer
{
	int written_bytes;
	while((written_bytes = write(fd, buf, BUF_CUT*(strlen(buf)/BUF_CUT+1))) < 0)
	{
		if(errno == EAGAIN)
		{
			// do nothing as default
		}
		else if(errno == EBADF)
		{
			cout<<"\twrite function failed due to EBADF, retrying..."<<endl;
cout<<"\tcontents: "<<buf<<endl;
			sleep(5);
		}
		else if(errno == EFAULT)
		{
			cout<<"\twrite function failed due to EFAULT, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == EFBIG)
		{
			cout<<"\twrite function failed due to EFBIG, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == EINTR)
		{
			cout<<"\twrite function failed due to EINTR, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == EINVAL)
		{
			cout<<"\twrite function failed due to EINVAL, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == EIO)
		{
			cout<<"\twrite function failed due to EIO, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == ENOSPC)
		{
			cout<<"\twrite function failed due to ENOSPC, retrying..."<<endl;
			sleep(5);
		}
		else if(errno == EPIPE)
		{
			cout<<"\twrite function failed due to EPIPE, retrying..."<<endl;
			sleep(5);
		}
		else
		{
			cout<<"\twrite function failed due to unknown reason(debug needed)..."<<endl;
			sleep(5);
			return -1;
		}

		// sleep 1 milli seconds to prevent busy waiting
		usleep(1000);
	}

	if(written_bytes != BUF_CUT*((int)strlen(buf)/BUF_CUT+1))
	{
		int progress = written_bytes;
		int remain = BUF_CUT*(strlen(buf)/BUF_CUT+1) - written_bytes;
		while(remain > 0)
		{
			written_bytes = write(fd, buf+progress, remain);

			if(written_bytes > 0)
			{
				progress += written_bytes;
				remain -= written_bytes;
			}

			// sleep 1 milli seconds to prevent busy waiting
			usleep(1000);
		}
	}
	return written_bytes;
}

// non-blocking read
int nbread(int fd, char* buf)
{
	int total_readbytes = 0;
	int readbytes = 0;
	memset(buf, 0, BUF_SIZE);

	readbytes = read(fd, buf, BUF_CUT);
	if(readbytes == 0)
	{
		return readbytes;
	}
	else if(readbytes < 0)
	{
		if(errno != EAGAIN)
		{
			if(errno == EBADF)
			{
				cout<<"\t\033[0;31mread function failed due to EBADF error, debug needed\033[0m"<<endl;
			}
			else if(errno == EFAULT)
			{
				cout<<"\t\033[0;31mread function failed due to EFAULT error, debug needed\033[0m"<<endl;
			}
			else if(errno == EINTR)
			{
				cout<<"\t\033[0;31mread function failed due to EINTR error, debug needed\033[0m"<<endl;
			}
			else if(errno == EINVAL)
			{
				cout<<"\t\033[0;31mread function failed due to EINVAL error, debug needed\033[0m"<<endl;
			}
			else if(errno == EIO)
			{
				cout<<"\t\033[0;31mread function failed due to EIO error, debug needed\033[0m"<<endl;
			}
			else if(errno == EISDIR)
			{
				cout<<"\t\033[0;31mread function failed due to EISDIR error, debug needed\033[0m"<<endl;
			}
			else
			{
				cout<<"\t\033[0;31mread function failed due to unspecified error, debug needed\033[0m"<<endl;
			}

			// sleep 1 second for easier debug
			sleep(1);
		}

		return readbytes;
	}
	else
	{
		total_readbytes += readbytes;
		if(buf[total_readbytes-1] == 0 && total_readbytes%BUF_CUT == 0)
		{
			return total_readbytes;
		}
		else
		{
			while(1)
			{
				readbytes = read(fd, buf+total_readbytes, BUF_CUT-(total_readbytes%BUF_CUT));
				if(readbytes == 0)
				{
					cout<<"\t\033[0;32mthe fd was closed during reading the buffer: debug the nbread() function.\033[0m"<<endl;
					cout<<"\t\033[0;32m"<<buf<<"\033[0m"<<endl;
					cout<<"\t\033[0;32m"<<"total_readbytes: "<<total_readbytes<<"\033[0m"<<endl;
					cout<<"\t\033[0;32m"<<"last_character: "<<buf[total_readbytes-1]<<"\033[0m"<<endl;
					return 0;
				}
				else if(readbytes < 0)
				{
					// sleep 1 milli seconds to prevent busy waiting
					usleep(1000);
					continue;
				}
				else
				{
					total_readbytes += readbytes;

					if(buf[total_readbytes-1] != 0 || total_readbytes%BUF_CUT != 0)
					{
						//usleep(1000);
						continue;
					}
					else
					{
						return total_readbytes;
					}
				}
			}
		}
	}
	return total_readbytes;
}

#endif
#ifndef __MAPREDUCE__
#define __MAPREDUCE__

#include <iostream>
#include <errno.h>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <set>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/unistd.h>
#include <arpa/inet.h>

#include "../definitions.hh"

using namespace std;

// user functions
void init_mapreduce(int argc, char** argv); // initialize mapreduce configure
void summ_mapreduce(); // summarize mapreduce configure
void set_mapper(void (*map_func)());
void set_reducer(void (*red_func) (string key));
bool is_nextvalue(); // return true if there is next value
bool is_nextrecord(); // return true if there is next value
string get_nextvalue(); // returns values in reduce function
bool get_nextinput(); // process to next input for map role
string get_nextrecord(); // return true when successful, false when out of input record
bool get_nextkey(string* value); // return true when successful, false when out of key value pair
void add_inputpath(string path);
void set_outputpath(string path);
char** get_argv(void); // get user argv excepting passed pipe fd
void write_keyvalue(string key, string value);
void write_output(string record); // function used in reduce function

int openoutfile(string path); // open a task/job result file
int writeoutfile(int fd, string data); // write to the task/job result file
int closeoutfile(int fd); // close task/job result file
int get_argc(void); // get user argc excepting passed pipe fd
void report_key(int index);
int connect_to_server(char *host, unsigned short port);
int get_jobid();

mr_role role = JOB;
char read_buf[BUF_SIZE]; // read buffer for pipe
char write_buf[BUF_SIZE]; // write buffer for pipe

int argcount = -1;
char** argvalues = NULL;

// variables for job role
int port = -1;
int dhtport = -1;
int masterfd = -1;
int jobid;
int nummap = 0;
int numreduce = 0;
int completed_map = 0;
int completed_reduce = 0;
bool master_is_set = false; // check if the configure file includes master address
bool isset_mapper = false;
bool isset_reducer = false;
bool inside_map = false; // true if the code is inside map function 
bool inside_reduce = false; // true if the code is inside reduce function 
char master_address[BUF_SIZE];
vector<string> inputpaths; // list of input paths.
ifstream input; // input file stream for get_record
string outputpath = "default_output";

// variables for task role
string jobdirpath;
int taskid;
int pipefd[2]; // pipe fd when the role is map task or reduce task

// variables for map task
void (*mapfunction) (); // map function pointer
set<string> reported_keys;
set<string> unreported_keys;

// variables for reduce task
void (*reducefunction) (string key); // reduce function pointer
string nextvalue;
string nextrecord;
bool is_nextval = false;
bool is_nextrec = false;

void init_mapreduce(int argc, char** argv)
{
	int readbytes; // number of bytes read from pipe fd

	// check the arguments do determine the role
	if(argc>1) // check argc to avoid index out of bound
	{
		if(strncmp(argv[argc-1], "MAP", 3) == 0)
			role = MAP;
		else if(strncmp(argv[argc-1], "REDUCE", 6) == 0)
			role = REDUCE;
		else
			role = JOB;
	}
	else
	{
		role = JOB;
	}

	if(role == JOB) // when the role is job
	{
		// determine the argcount
		argcount = argc;

		ifstream conf;
		string token;
		string confpath = LIB_PATH;
		confpath.append("setup.conf");
		conf.open(confpath.c_str());

		conf>>token;
		while(!conf.eof())
		{
			if(token == "port")
			{
				conf>>token;
				port = atoi(token.c_str());
			}
			else if(token == "dhtport")
			{
				conf>>token;
				dhtport = atoi(token.c_str());
			}
			else if(token == "max_job")
			{
				// ignore and just pass through this case
				conf>>token;
			}
			else if(token == "master_address")
			{
				conf>>token;
				strcpy(master_address, token.c_str());
				master_is_set = true;
			}
			else
			{
				cout<<"Unknown configure record: "<<token<<endl;
			}
			conf>>token;
		}
		conf.close();

		// verify initialization
		if(port == -1)
		{
			cout<<"Port should be specified in the setup.conf"<<endl;
			exit(1);
		}
		if(master_is_set == false)
		{
			cout<<"Master_address should be specified in the setup.conf"<<endl;
			exit(1);
		}
		
		masterfd = connect_to_server(master_address, port);
		if(masterfd<0)
		{
			cout<<"Connecting to master failed"<<endl;
			exit(1);
		}
		else
		{
			cout<<"Connection to the mater node successfully established"<<endl;
		}

		// a blocking read "whoareyou" signal from master
		readbytes = nbread(masterfd, read_buf);

		if(readbytes == 0) // connection closed
		{
			cout<<"Connection to master is abnormally closed"<<endl;
			cout<<"Exiting..."<<endl;
			exit(1);
		}
		else
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				// respond to "whoareyou"
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "job");
				nbwrite(masterfd, write_buf);

				// blocking read of job id
				while(1)
				{
					readbytes = nbread(masterfd, read_buf);
					if(readbytes == 0)
					{
						cout<<"[mapreduce]Connection from master abnormally close"<<endl;
						break;
					}
					else if(readbytes < 0)
					{
						// sleep for 0.0001 second. change this if necessary
						// usleep(100);
					}
					else // reply arived
					{
						break;
					}
				}

				// register the job id and proceed
				if(strncmp(read_buf, "jobid", 5) == 0)
				{
					char* token;
					token = strtok(read_buf, " "); // token -> jobid
					token = strtok(NULL, " "); // token -> job id(a number)

					// register the job id
					jobid = atoi(token);
				}
				else // if the message is not the 'jobid'
				{
					cout<<"[mapreduce]Debugging: protocol error in mapreduce"<<endl;
				}
				cout<<"[mapreduce]Debugging: Job id is: "<<jobid<<endl;
			}
			else
			{
				cout<<"Undefined message from master node: "<<read_buf<<endl;
				cout<<"Exiting..."<<endl;
			}
		}

		// set master fd to be nonblocking to avoid deadlock
		fcntl(masterfd, F_SETFL, O_NONBLOCK);

		// make directories for the job
		int pid;
		string apath = MR_PATH;
		stringstream jobidss;

		// pass job id to the string stream
		jobidss<<".job_";
		jobidss<<jobid;
		jobidss<<"/";
		jobdirpath = jobidss.str();
		apath.append(jobdirpath);

		// fork new process and give command mkdir to the child process
		pid = fork();
		if(pid == 0) // child process
		{
			// parse the arguments to make the job directory
			char** argv;
			argv = new char*[3];
			argv[0] = new char[6];
			strcpy(argv[0], "mkdir");
			argv[1] = new char[apath.length()+1];
			strcpy(argv[1], apath.c_str());
			argv[2] = NULL;
			

			// launch the mkdir program
			execvp(argv[0], argv);
		}
		else // parent side
		{
			// do nothing
		}
	}
	else // when the role is map task or reduce task
	{
		int readcount = 0;
		pipefd[0] = atoi(argv[argc-3]); // read fd
		pipefd[1] = atoi(argv[argc-2]); // write fd
		argcount = argc - 3;

		// request the task configuration
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "requestconf");
		nbwrite(pipefd[1], write_buf);

		// blocking read until the arrival of 'taskconf' message from master
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		readbytes = nbread(pipefd[0], read_buf);

		if(readbytes == 0)
		{
			cout<<"[mapreduce]the connection from slave node is abnormally closed"<<endl;
			exit(1);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);

		// parse the task configure
		char* token;
		token = strtok(read_buf, " "); // token <- taskconf

		// check the message protocol
		if(strncmp(token, "taskconf", 8) != 0)
		{
			cout<<"[mapreduce]Debugging: The message protocol has problem"<<endl;
		}
		else
		{
			while(token != NULL)
			{
				if(strncmp(token, "jobid", 5) == 0)
				{
					// register job id and set job directory path
					stringstream jobidss;

					token = strtok(NULL, " "); // token -> job id
					jobid = atoi(token);

					jobidss<<".job_";
					jobidss<<jobid;
					jobidss<<"/";
					jobdirpath = jobidss.str();
					
				}
				else if(strncmp(token, "taskid", 6) == 0)
				{
					token = strtok(NULL, " "); // token -> taskid
					taskid = atoi(token);
				}
				else if(strncmp(token, "inputpaths", 10) == 0)
				{
					int numpath;
					token = strtok(NULL, " "); // token -> number of input paths
					numpath = atoi(token);
					for(int i=0;i<numpath;i++)
					{
						token = strtok(NULL, " ");
						inputpaths.push_back(token);
					}
				}

				// process next configure
				token = strtok(NULL, " ");
			}
		}
	}

	// parse user arguments
	argvalues = new char*[argcount];
	for(int i=0; i<argcount; i++) // copy argv into argvalues to get user argv
	{
		argvalues[i] = new char[strlen(argv[i])+1];
		strcpy(argvalues[i], argv[i]);
	}
}

void summ_mapreduce()
{
	int readbytes;
	// TODO: make sure that all configuration are done

	if(argcount == -1) // mapreduce has not been initialized with init_mapreduce() func
	{
		cout<<"Mapreduce has not been initialized"<<endl;
		exit(1);
	}
	if(role == JOB) // running job
	{
		if((nummap >= 0 && isset_mapper) || (numreduce >= 0 && isset_reducer)) // when neither mapper and reducer are activated
		{
			// TODO: manage all things if the role is the job

			// send all necessary information to the master node
			string write_string = "jobconf";
			stringstream ss;

			// TODO: deal with the case when number of characters exceeds BUF_SIZE
			ss<<" inputpath ";
			ss<<inputpaths.size();
			for(int i=0;i<inputpaths.size();i++)
			{
				ss<<" ";
				ss<<inputpaths[i];
			}

			ss<<" argcount ";
			ss<<argcount;

			// parse the arguments
			ss<<" argvalues";

			// find the program name and pass as 0th argument
			char* tmp = new char[strlen(argvalues[0])+1];
			string apath = MR_PATH;
			char* token;
			char* next_token;

			strcpy(tmp, argvalues[0]);
			next_token = strtok(tmp, "/");

			while(next_token != NULL)
			{
				token = next_token;
				next_token = strtok(NULL, "/");
			}

			ss<<" ";
			apath.append("app/");
			apath.append(token); // token <- the program name
			ss<<apath;

			delete[] tmp;

			for(int i=1;i<argcount;i++)
			{
				ss<<" ";
				ss<<argvalues[i];
			}

			write_string.append(ss.str());
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, write_string.c_str());
			nbwrite(masterfd, write_buf);
		}

		// blocking read from master until "complete" receiving message
		fcntl(masterfd, F_SETFL, fcntl(masterfd, F_GETFL) & ~O_NONBLOCK);

		while(1)
		{
			readbytes = nbread(masterfd, read_buf);
			if(readbytes == 0) // master abnormally terminated
			{
				// TODO: Terminate the job properly
				cout<<"[mapreduce]Connection to master abnormally closed"<<endl;
				exit(0);
			}
			else
			{
				if(strncmp(read_buf, "complete", 8) == 0) // "complete" message received
				{
					cout<<"[mapreduce]Job is successfully completed"<<endl;
					break;
				}
				else if(strncmp(read_buf, "mapcomplete", 11) == 0)
				{
					cout<<"[mapreduce]Map tasks are completed"<<endl;
					cout<<"[mapreduce]Now reduce tasks are launched"<<endl;
				}
				else
				{
					cout<<"[mapreduce]Unknown message from slave: "<<read_buf<<endl;
				}
			}
		}
		fcntl(masterfd, F_SETFL, O_NONBLOCK);

		// remove the job directory
		int pid;
		pid = fork();
		if(pid == 0) // child process
		{
			string apath;
			char** argv = new char*[4];

			argv[0] = new char[3];
			strcpy(argv[0], "rm");

			argv[1] = new char[4];
			strcpy(argv[1], "-rf");

			apath = MR_PATH;
			apath.append(jobdirpath);
			argv[2] = new char[apath.length()+1];
			strcpy(argv[2], apath.c_str());

			argv[3] = NULL;

			execvp(argv[0], argv);
		}
		else if(pid < 0)
		{
			cout<<"[mapreduce]Debugging: forking failed"<<endl;
		}
		else // parent process
		{
			int status;
			waitpid(pid, &status, 0);
		}

		exit(0);
	}
	else if(role == MAP) // map task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}

		// run the mapfunction until input all inputs are processed
		
		if(isset_mapper)
		{
			while(get_nextinput())
			{
				inside_map = true;
				(*mapfunction)();
				inside_map = false;

				// report generated keys to slave node
				while(!unreported_keys.empty())
				{
					string key = *unreported_keys.begin();
					string keystr = "key ";
					keystr.append(key);
cout<<"[mapreduce]Debugging: key emitted: "<<key<<endl;
					unreported_keys.erase(*unreported_keys.begin());
					reported_keys.insert(key);

					// send 'key' meesage to the slave node
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, keystr.c_str());
					nbwrite(pipefd[1], write_buf);
				}
			}
		}

		// send complete message
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "complete");
		nbwrite(pipefd[1], write_buf);
		
		// blocking read until the 'terminate' message
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				// TODO: Terminate the task properly
				input.close();
				cout<<"[mapreduce]Connection from master abnormally closed"<<endl;
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
//					cout<<"[mapreduce]Map task is successfully completed"<<endl;
					// clear task
					input.close();
					// terminate successfully
					exit(0);
				}
				else // all other messages are ignored
				{
					cout<<"[mapreduce]Abnormal message from slave: "<<read_buf<<endl;
					continue;
				}
			}

			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
	else // reduce task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}

		// run the reduce functions until all key are processed
		if(isset_reducer)
		{
			string key;
			while(get_nextkey(&key))
			{
				inside_reduce = true;
				(*reducefunction)(key);
				inside_reduce = false;
			}
		}

		// send complete message
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "complete");
		nbwrite(pipefd[1], write_buf);

		// blocking read until 'terminate' message arrive
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);

		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				// TODO: Terminate the task properly
				input.close();
				cout<<"the reduce task is gone"<<endl;
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
//					cout<<"[mapreduce]Reduce task is successfully completed"<<endl; // <- this message will be printed in the slave process side

					// clear task
					input.close();
					// terminate successfully
					exit(0);
				}
				else // all other messages are ignored
					continue;
			}

			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
}

int get_argc(void)
{
	return argcount;
}

char** get_argv(void)
{
	return argvalues;
}
void set_mapper(void (*map_func)())
{
	isset_mapper = true;
	mapfunction = map_func;
}

void set_reducer(void (*red_func) (string key))
{
	isset_reducer = true;
	reducefunction = red_func;
}

void add_inputpath(string path) // the path is relative path to MR_PATH
{
	if(role == JOB)
	{
		inputpaths.push_back(path);
	}
	else if(role == MAP)
	{
		// do nothing
	}
	else // role is reduce
	{
		// do nothing
	}
}

void set_outputpath(string path) // this user function can be used in anywhere but after initialization
{
	outputpath = path;
}

int connect_to_server(char *host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent *hp;

	// SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd<0)
	{
		cout<<"[mapreduce]Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);


	if (hp == NULL)
	{
		cout<<"[mapreduce]Cannot find host by host name"<<endl;
		return -1;
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void write_keyvalue(string key, string value)
{
	// check if thie function is called inside the map function
	if(inside_map)
	{
		if(reported_keys.find(key) == reported_keys.end()
			&& unreported_keys.find(key) == unreported_keys.end())
		{
			unreported_keys.insert(key);

			// send 'key' message to the slave node
			string key = *unreported_keys.begin();
			string keystr = "key ";
			keystr.append(key);
			cout<<"[mapreduce]Debugging: key emitted: "<<key<<endl;
			unreported_keys.erase(*unreported_keys.begin());
			reported_keys.insert(key);

			// send 'key' meesage to the slave node
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, keystr.c_str());
			nbwrite(pipefd[1], write_buf);
		}

		// path of the key file
		string keypath = MR_PATH;
		keypath.append(jobdirpath);
		keypath.append(key);

		// result string
		string rst = key;
		rst.append(" ");
		rst.append(value);
		int fd = openoutfile(keypath);

		if(fd<0)
		{
			cout<<"[mapreduce]Debugging: openoutfile error"<<endl;
		}

		writeoutfile(fd, rst);
		closeoutfile(fd);
	}
	else
	{
		cout<<"[mapreduce]Warning: the write_keyvalue() function is being used outside the map function"<<endl;
	}
}

bool get_nextinput() // internal function to process next input file
{
	if(inputpaths.size() == 0) // no more input
	{
		input.close();
		return false;
	}
	else
	{
		// open another input file
		string apath = MR_PATH;
		apath.append(inputpaths.back());
		input.close();
		input.open(apath.c_str());
		inputpaths.pop_back();

		// pre-process first record
		getline(input, nextrecord);
		
		if(input.eof())
			is_nextrec = false;
		else
			is_nextrec = true;

		return true;
	}
}

string get_nextrecord() // a user function for the map
{
	if(inside_map)
	{
		string ret = nextrecord;
		getline(input, nextrecord);

		if(input.eof())
			is_nextrec = false;
		else
			is_nextrec = true;

		return ret;
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextrecord() function is being used outside the map function"<<endl;
		return "";
	}

}

bool is_nextrecord()
{
	if(inside_map)
	{
		return is_nextrec;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextrecord() function is being used outside the map function"<<endl;
	}
}

bool get_nextkey(string* key) // internal function for the reduce
{
	if(inputpaths.size() == 0) // no more key
	{
		return false;
	}
	else
	{
		*key = inputpaths.back(); // in reduce function, inputpath name is the key
		string apath = MR_PATH;
		apath.append(jobdirpath);
		apath.append(inputpaths.back());
		input.close();
		input.open(apath.c_str());
		inputpaths.pop_back();
		
		// pre-process first value 
		input>>nextvalue; // key. pass this key
		input>>nextvalue; // first value

		if(input.eof())
			is_nextval = false;
		else
			is_nextval = true;

		return true;
	}
}

bool is_nextvalue() // returns true if there is next value
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		return is_nextval;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextvalue() function is being used outside the reduce function"<<endl;
	}
}

string get_nextvalue() // returns values in reduce function
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		string ret = nextvalue;
		input>>nextvalue; // key. pass this key
		input>>nextvalue; // next value

		if(input.eof())
			is_nextval = false;
		else
			is_nextval = true;

		return ret;
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextvalue() function is being used outside the reduce function"<<endl;
		return "";
	}
}

void write_output(string record) // this user function can be used anywhere but after initialization
{
	string outpath = MR_PATH;
	if(outputpath == "default_output")
	{
		stringstream ss;
		ss<<"job_";
		ss<<jobid;
		ss<<".out";
		outpath.append(ss.str());
	}
	else
	{
		outpath.append(outputpath);
	}

	int fd = openoutfile(outpath);
	writeoutfile(fd, record);
	closeoutfile(fd);
}

int get_jobid()
{
	return jobid;
}

int openoutfile(string path) // path: full absolute path
{
	return open(path.c_str(), O_APPEND|O_SYNC|O_WRONLY|O_CREAT, 0644);
}

int writeoutfile(int fd, string data)
{
	struct flock alock;
	struct flock ulock;

	// set lock
	alock.l_type = F_WRLCK;
	alock.l_start = 0;
	alock.l_whence = SEEK_SET;
	alock.l_len = 0;

	// set unlock
	ulock.l_type = F_UNLCK;
	ulock.l_start = 0;
	ulock.l_whence = SEEK_SET;
	ulock.l_len = 0;

	// acquire file lock
	fcntl(fd, F_SETLKW, &alock);

	// critical section
	{
		data.append("\n");
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, data.c_str());
		write(fd, write_buf, strlen(data.c_str()));
	}

	// release file lock
	fcntl(fd, F_SETLK, &ulock);

	// return 1 when successful
	return 1;
}

int closeoutfile(int fd)
{
	return close(fd);
}

#endif
#ifndef __MAPREDUCE__
#define __MAPREDUCE__

#include <iostream>
#include <errno.h>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <set>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/unistd.h>
#include <arpa/inet.h>
#include <hdfs.h>

#include "../definitions.hh"

#define HDFS_HOST "ravenleader"
#define HDFS_PORT 9000

using namespace std;

// user functions
void init_mapreduce(int argc, char** argv); // initialize mapreduce configure
void summ_mapreduce(); // summarize mapreduce configure
void set_mapper(void (*map_func) ());
void set_reducer(void (*red_func) (string key));
bool is_nextvalue(); // return true if there is next value
bool is_nextrecord(); // return true if there is next value
string get_nextvalue(); // returns values in reduce function
bool get_nextinput(); // process to next input for map role
string get_nextrecord(); // return true when successful, false when out of input record
bool get_nextkey(string* value); // return true when successful, false when out of key value pair
void add_inputpath(string path);
void set_outputpath(string path);
char** get_argv(void); // get user argv excepting passed pipe fd
void write_keyvalue(string key, string value);
void write_output(string record); // function used in reduce function

int writeoutfile(hdfsFile* hdfsFile, string data); // write to the task/job result file
bool get_record(string* record); // return true when successful, false when out of input record
bool get_nextkey(string* value); // return true when successful, false when out of key value pair
int get_argc(void); // get user argc excepting passed pipe fd
void report_key(int index);
int connect_to_server(char *host, unsigned short port);
int get_jobid();
bool hdfs_getline(hdfsFile* file, string* ret);

mr_role role = JOB;
char read_buf[BUF_SIZE]; // read buffer for pipe
char write_buf[BUF_SIZE]; // write buffer for pipe

int argcount = -1;
char** argvalues = NULL;

// variables for job role
int port = -1;
int dhtport = -1;
int masterfd = -1;
int jobid;
int nummap = 0;
int numreduce = 0;
int completed_map = 0;
int completed_reduce = 0;
bool master_is_set = false; // check if the configure file includes master address
bool isset_mapper = false;
bool isset_reducer = false;
bool inside_map = false; // true if the code is inside map function 
bool inside_reduce = false; // true if the code is inside reduce function 
char master_address[BUF_SIZE];
vector<string> inputpaths; // list of input paths.
hdfsFile input; // input file stream for get_record
string outputpath = "default_output";

// variables for task role

hdfsFS hadoopfs;
string jobdirpath;
int taskid;
int pipefd[2]; // pipe fd when the role is map task or reduce task

// variables for map task
void (*mapfunction) (); // map function pointer
set<string> reported_keys;
set<string> unreported_keys;

// variables for reduce task
void (*reducefunction) (string key); // reduce function pointer
string nextvalue;
string nextrecord;
bool is_nextval = false;
bool is_nextrec = false;

void init_mapreduce(int argc, char** argv)
{
	// connect to hdfs server
	hadoopfs = hdfsConnect(HDFS_HOST, HDFS_PORT);

	int readbytes; // number of bytes read from pipe fd

	// check the arguments do determine the role
	if(argc>1) // check argc to avoid index out of bound
	{
		if(strncmp(argv[argc-1], "MAP", 3) == 0)
			role = MAP;
		else if(strncmp(argv[argc-1], "REDUCE", 6) == 0)
			role = REDUCE;
		else
			role = JOB;
	}
	else
	{
		role = JOB;
	}

	if(role == JOB) // when the role is job
	{
		// determine the argcount
		argcount = argc;

		ifstream conf;
		string token;
		string confpath = LIB_PATH;
		confpath.append("setup.conf");
		conf.open(confpath.c_str());

		conf>>token;
		while(!conf.eof())
		{
			if(token == "port")
			{
				conf>>token;
				port = atoi(token.c_str());
			}
			else if(token == "dhtport")
			{
				conf>>token;
				dhtport = atoi(token.c_str());
			}
			else if(token == "max_job")
			{
				// ignore and just pass throught this case
				conf>>token;
			}
			else if(token == "master_address")
			{
				conf>>token;
				strcpy(master_address, token.c_str());
				master_is_set = true;
			}
			else
			{
				cout<<"Unknown configure record: "<<token<<endl;
			}
			conf>>token;
		}
		conf.close();

		// verify initialization
		if(port == -1)
		{
			cout<<"Port should be specified in the setup.conf"<<endl;
			exit(1);
		}
		if(master_is_set == false)
		{
			cout<<"Master_address should be specified in the setup.conf"<<endl;
			exit(1);
		}

		masterfd = connect_to_server(master_address, port);
		if(masterfd<0)
		{
			cout<<"Connecting to master failed"<<endl;
			exit(1);
		}
		else
		{
			cout<<"Connection to the mater node successfully established"<<endl;
		}

		// read "whoareyou" signal from master
		readbytes = nbread(masterfd, read_buf);

		if(readbytes == 0) // connection closed
		{
			cout<<"Connection to master is abnormally closed"<<endl;
			cout<<"Exiting..."<<endl;
			exit(1);
		}
		else
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				// respond to "whoareyou"
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "job");
				nbwrite(masterfd, write_buf);

				// blocking read of job id
				while(1)
				{
					readbytes = nbread(masterfd, read_buf);
					if(readbytes == 0)
					{
						cout<<"[mapreduce]Connection from master abnormally close"<<endl;
						break;
					}
					else if(readbytes < 0)
					{
						// sleep for 0.0001 second. change this if necessary
						// usleep(100);
					}
					else // reply arived
					{
						break;
					}
				}

				// register the job id and proceed
				if(strncmp(read_buf, "jobid", 5) == 0)
				{
					char* token;
					token = strtok(read_buf, " "); // token -> jobid
					token = strtok(NULL, " "); // token -> job id(a number)

					// register the job id
					jobid = atoi(token);
				}
				else // if the message is not the 'jobid'
				{
					cout<<"[mapreduce]Debugging: protocol error in mapreduce"<<endl;
				}
				cout<<"[mapreduce]Debugging: Job id is: "<<jobid<<endl;
			}
			else
			{
				cout<<"Undefined message from master node: "<<read_buf<<endl;
				cout<<"Exiting..."<<endl;
				exit(1);
			}
		}

		// set master fd to be nonblocking to avoid deadlock
		fcntl(masterfd, F_SETFL, O_NONBLOCK);

		// make lock directories for the job
		int pid;
		string lpath = MR_PATH;
		stringstream ljobidss;

		// pass job id to the string stream
		ljobidss<<".job_";
		ljobidss<<jobid;
		ljobidss<<"/";
		jobdirpath = ljobidss.str();
		lpath.append(jobdirpath);

		// fork new process and give command mkdir to the child process
		pid = fork();
		if(pid == 0) // child process
		{
			// parse the arguments to make the job directory
			char** argv;
			argv = new char*[3];
			argv[0] = new char[6];
			strcpy(argv[0], "mkdir");
			argv[1] = new char[lpath.length()+1];
			strcpy(argv[1], lpath.c_str());
			argv[2] = NULL;
			
			// launch the mkdir program
			execvp(argv[0], argv);
		}
		else // parent side
		{
			// do nothing
		}

		// make directories for the job
		string apath = HDMR_PATH;
		stringstream jobidss;

		// pass job id to the string stream
		jobidss<<".job_";
		jobidss<<jobid;
		jobidss<<"/";
		jobdirpath = jobidss.str();
		apath.append(jobdirpath);

		hdfsCreateDirectory(hadoopfs, apath.c_str());
	}
	else // when the role is map task or reduce task
	{
		int readcount = 0;
		pipefd[0] = atoi(argv[argc-3]); // read fd
		pipefd[1] = atoi(argv[argc-2]); // write fd
		argcount = argc - 3;

		// request the task configuration
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "requestconf");
		nbwrite(pipefd[1], write_buf);

		// blocking read until the arrival of 'taskconf' message from master
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		readbytes = nbread(pipefd[0], read_buf);

		if(readbytes == 0)
		{
			cout<<"[mapreduce]the connection from slave node is abnormally closed"<<endl;
			exit(1);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);

		// parse the task configure
		char* token;
		token = strtok(read_buf, " "); // token <- taskconf

		// check the message protocol
		if(strncmp(token, "taskconf", 8) != 0)
		{
			cout<<"[mapreduce]Debugging: The message protocol has problem"<<endl;
		}
		else
		{
			while(token != NULL)
			{
				if(strncmp(token, "jobid", 5) == 0)
				{
					// register job id and set job directory path
					stringstream jobidss;

					token = strtok(NULL, " "); // token -> job id
					jobid = atoi(token);

					jobidss<<".job_";
					jobidss<<jobid;
					jobidss<<"/";
					jobdirpath = jobidss.str();

				}
				else if(strncmp(token, "taskid", 6) == 0)
				{
					token = strtok(NULL, " "); // token -> taskid
					taskid = atoi(token);
				}
				else if(strncmp(token, "inputpaths", 10) == 0)
				{
					int numpath;
					token = strtok(NULL, " "); // token -> number of input paths
					numpath = atoi(token);
					for(int i=0;i<numpath;i++)
					{
						token = strtok(NULL, " ");
						inputpaths.push_back(token);
					}
				}

				// process next configure
				token = strtok(NULL, " ");
			}
		}
	}

	// parse user arguments
	argvalues = new char*[argcount];
	for(int i=0; i<argcount; i++) // copy argv into argvalues to get user argv
	{
		argvalues[i] = new char[strlen(argv[i])+1];
		strcpy(argvalues[i], argv[i]);
	}
}

void summ_mapreduce()
{
	int readbytes;
	// TODO: make sure that all configuration are done

	if(argcount == -1) // mapreduce has not been initialized with init_mapreduce() func
	{
		cout<<"Mapreduce has not been initialized"<<endl;
		exit(1);
	}

	if(role == JOB) // running job
	{
		if((nummap >= 0 && isset_mapper) || (numreduce >= 0 && isset_reducer)) // when neither mapper and reducer are activated
		{
			// TODO: manage all things if the role is the job

			// send all necessary information to the master node
			string write_string = "jobconf";
			stringstream ss;

			// TODO: deal with the case when number of characters exceeds BUF_SIZE
			ss<<" inputpath ";
			ss<<inputpaths.size();
			for(int i=0;i<inputpaths.size();i++)
			{
				ss<<" ";
				ss<<inputpaths[i];
			}

			ss<<" argcount ";
			ss<<argcount;

			// parse the arguments
			ss<<" argvalues";

			// find the program name and pass as 0th argument
			char* tmp = new char[strlen(argvalues[0])+1];
			string apath = MR_PATH;
			char* token;
			char* next_token;

			strcpy(tmp, argvalues[0]);
			next_token = strtok(tmp, "/");

			while(next_token != NULL)
			{
				token = next_token;
				next_token = strtok(NULL, "/");
			}

			ss<<" ";
			apath.append("app/");
			apath.append(token); // token <- the program name
			ss<<apath;

			delete[] tmp;

			for(int i=1;i<argcount;i++)
			{
				ss<<" ";
				ss<<argvalues[i];
			}

			write_string.append(ss.str());
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, write_string.c_str());
			nbwrite(masterfd, write_buf);
		}

		// blocking read from master until "complete" receiving message
		fcntl(masterfd, F_SETFL, fcntl(masterfd, F_GETFL) & ~O_NONBLOCK);
		while(1)
		{
			readbytes = nbread(masterfd, read_buf);
			if(readbytes == 0) // master abnormally terminated
			{
				// TODO: Terminate the job properly
				exit(0);
			}
			else
			{
				if(strncmp(read_buf, "complete", 8) == 0) // "complete" message received
				{
					cout<<"[mapreduce]Job is successfully completed"<<endl;
					break;
				}
				else if(strncmp(read_buf, "mapcomplete", 11) == 0)
				{
					cout<<"[mapreduce]Map tasks are completed"<<endl;
					cout<<"[mapreduce]Now reduce tasks are launched"<<endl;
					continue;
				}
				else // all other messages are ignored
					continue;
			}
		}
		fcntl(masterfd, F_SETFL, O_NONBLOCK);

		// remove the job directory
		string apath = HDMR_PATH;
		apath.append(jobdirpath);
		hdfsDelete(hadoopfs, apath.c_str(), 1);

		// remove the lock directory
		int pid;
		pid = fork();
		if(pid == 0) // child process
		{
			string apath;
			char** argv = new char*[4];

			argv[0] = new char[3];
			strcpy(argv[0], "rm");

			argv[1] = new char[4];
			strcpy(argv[1], "-rf");

			apath = MR_PATH;
			apath.append(jobdirpath);
			argv[2] = new char[apath.length()+1];
			strcpy(argv[2], apath.c_str());

			argv[3] = NULL;

			execvp(argv[0], argv);
		}
		else if(pid < 0)
		{
			cout<<"[mapreduce]Debugging: forking failed"<<endl;
		}
		else // parent process
		{
			int status;
			waitpid(pid, &status, 0);
		}

		// disonnect from hdfs server and close the hdfs file
		hdfsDisconnect(hadoopfs);

		exit(0);
	}
	else if(role == MAP) // map task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}


		// run the mapfunction until input all inputs are processed
		string record;

		if(isset_mapper)
		{
			while(get_nextinput())
			{
				inside_map = true;
				(*mapfunction)();
				inside_map = false;

				// report generated keys to slave node
				while(!unreported_keys.empty())
				{
					string key = *unreported_keys.begin();
					string keystr = "key ";
					keystr.append(key);
cout<<"[mapreduce]Debugging: key emitted: "<<key<<endl;
					unreported_keys.erase(*unreported_keys.begin());
					reported_keys.insert(key);

					// send 'key' meesage to the slave node
					memset(write_buf, 0, BUF_CUT);
					strcpy(write_buf, keystr.c_str());
					nbwrite(pipefd[1], write_buf);
				}
			}
		}

		// send complete message
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "complete");
		nbwrite(pipefd[1], write_buf);

		// blocking read until the 'terminate' message
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				// TODO: Terminate the task properly
				hdfsDisconnect(hadoopfs);
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
					//cout<<"[mapreduce]Map task is successfully completed"<<endl;

					// clear task
					hdfsDisconnect(hadoopfs);

					// terminate successfully
					exit(0);
				}
				else // all other messages are ignored
					continue;
			}

			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
	else // reduce task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}

		// run the reduce functions until all key are processed
		if(isset_reducer)
		{
			string key;
			while(get_nextkey(&key))
			{
				inside_reduce = true;
				(*reducefunction)(key);
				inside_reduce = false;
			}
		}

		// send complete message
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "complete");
		nbwrite(pipefd[1], write_buf);

		// blocking read until 'terminate' message arrive
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				// TODO: Terminate the task properly
				cout<<"the reduce task is gone"<<endl;
				hdfsDisconnect(hadoopfs);
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
					//					cout<<"[mapreduce]Reduce task is successfully completed"<<endl; // <- this message will be printed in the slave process side

					// clear task
					hdfsDisconnect(hadoopfs);
					// terminate successfully
					exit(0);
				}
				else // all other messages are ignored
					continue;
			}

			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
}

int get_argc(void)
{
	return argcount;
}

char** get_argv(void)
{
	return argvalues;
}
void set_mapper(void (*map_func) ())
{
	isset_mapper = true;
	mapfunction = map_func;
}

void set_reducer(void (*red_func) (string key))
{
	isset_reducer = true;
	reducefunction = red_func;
}

void add_inputpath(string path) // the path is relative path to MR_PATH
{
	if(role == JOB)
	{
		inputpaths.push_back(path);
	}
	else if(role == MAP)
	{
		// do nothing
	}
	else // role is reduce
	{
		// do nothing
	}
}

void set_outputpath(string path) // this user function can be used in anywhere but after initialization
{
	outputpath = path;
}

int connect_to_server(char *host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent *hp;

	// SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd<0)
	{
		cout<<"[mapreduce]Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);

	if (hp == NULL)
	{
		cout<<"[mapreduce]Cannot find host by host name"<<endl;
		return -1;
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void write_keyvalue(string key, string value)
{
	// check if thie function is called inside the map function
	if(inside_map)
	{
		if(reported_keys.find(key) == reported_keys.end()
				&& unreported_keys.find(key) == unreported_keys.end())
		{
			unreported_keys.insert(key);

			// send 'key' message to the slave node
			string key = *unreported_keys.begin();
			string keystr = "key ";
			keystr.append(key);
			cout<<"[mapreduce]Debugging: key emitted: "<<key<<endl;
			unreported_keys.erase(*unreported_keys.begin());
			reported_keys.insert(key);

			// send 'key' meesage to the slave node
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, keystr.c_str());
			nbwrite(pipefd[1], write_buf);
		}

		// path of the key file
		string keypath = HDMR_PATH;
		string keypath2 = MR_PATH;

		keypath.append(jobdirpath);
		keypath2.append(jobdirpath);
		keypath.append(key);
		keypath2.append(key);

		// result string
		string rst = key;
		rst.append(" ");
		rst.append(value);

		int fd = open(keypath2.c_str(), O_APPEND|O_SYNC|O_WRONLY|O_CREAT, 0644);
		struct flock alock;
		struct flock ulock;

		// set lock
		alock.l_type = F_WRLCK;
		alock.l_start = 0;
		alock.l_whence = SEEK_SET;
		alock.l_len = 0;

		//set unlock
		ulock.l_type = F_UNLCK;
		ulock.l_start = 0;
		ulock.l_whence = SEEK_SET;
		ulock.l_len = 0;

		// acquire file lock
		fcntl(fd, F_SETLKW, &alock);

		hdfsFile outfile;
		if(hdfsExists(hadoopfs, keypath.c_str()))
		{
			outfile = hdfsOpenFile(hadoopfs, keypath.c_str(), O_WRONLY, 0, 0, 0);
		}
		else
		{
			outfile = hdfsOpenFile(hadoopfs, keypath.c_str(), O_WRONLY|O_APPEND, 0, 0, 0);
		}

		if(outfile == NULL)
		{
			cout<<"[mapreduce]Debugging: openoutfile error"<<endl;
		}

		writeoutfile(&outfile, rst);
		hdfsCloseFile(hadoopfs, outfile);

		// relase file lock
		fcntl(fd, F_SETLK, &ulock);
		close(fd);
	}
	else
	{
		cout<<"[mapreduce]Warning: the write_keyvalue() function is being used outside the map function"<<endl;
	}
}

string get_nextrecord() // a user function for the map
{
	if(inside_map)
	{
		string ret = nextrecord;
		if(hdfs_getline(&input, &nextrecord))
			is_nextrec = true;
		else
			is_nextrec = false;

		return ret;
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextrecord() function is being used outside the map function"<<endl;
		return "";
	}
}

bool get_nextinput() // internal function to process next input file
{
	if(inputpaths.size() == 0) // no more input
	{
		hdfsCloseFile(hadoopfs, input);
		return false;
	}
	else
	{
		// open another input file
		string apath = HDMR_PATH;
		apath.append(inputpaths.back());
		hdfsCloseFile(hadoopfs, input);
		input = hdfsOpenFile(hadoopfs, apath.c_str(), O_RDONLY, 0, 0, 0);
		inputpaths.pop_back();

		// pre-process first record
		if(hdfs_getline(&input, &nextrecord))
			is_nextrec = true;
		else
			is_nextrec = false;

		return true;
	}
}

bool get_nextkey(string* key) // internal function for the reduce
{
	if(inputpaths.size() == 0) // no more key
	{
		hdfsCloseFile(hadoopfs, input);
		return false;
	}
	else
	{
		*key = inputpaths.back(); // in reduce function, inputpath name is the key
		string apath = HDMR_PATH;
		apath.append(jobdirpath);
		apath.append(inputpaths.back());
		hdfsCloseFile(hadoopfs, input);
		input = hdfsOpenFile(hadoopfs, apath.c_str(), O_RDONLY, 0, 0, 0);
		inputpaths.pop_back();

		// pre-process first value 
		if(hdfs_getline(&input, &nextvalue))
			is_nextval = true;
		else
			is_nextval = false;

		stringstream ss;
		ss<<nextvalue;
		ss>>nextvalue; // key. pass this key
		ss>>nextvalue; // first value

		return true;
	}
}

bool is_nextvalue() // returns true if there is next value
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		return is_nextval;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextvalue() function is being used outside the reduce function"<<endl;
	}
}

bool is_nextrecord()
{
	if(inside_map)
	{
		return is_nextrec;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextrecord() function is being used outside the map function"<<endl;
	}
}

string get_nextvalue() // returns values in reduce function
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		string ret = nextvalue;

		if(hdfs_getline(&input, &nextvalue))
			is_nextval = true;
		else
			is_nextval = false;

		stringstream ss;
		ss<<nextvalue;
		ss>>nextvalue; // key. pass this key
		ss>>nextvalue; // next value

		return ret;
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextvalue() function is being used outside the reduce function"<<endl;
		return "";
	}
}

void write_output(string record) // this user function can be used anywhere but after initialization
{
	string outpath = HDMR_PATH;
	string outpath2 = MR_PATH;
	if(outputpath == "default_output")
	{
		stringstream ss;
		ss<<"job_";
		ss<<jobid;
		ss<<".out";
		outpath.append(ss.str());
		outpath2.append(jobdirpath);
		outpath2.append(ss.str());
	}
	else
	{
		outpath.append(outputpath);
		outpath2.append(jobdirpath);
		outpath2.append(outputpath);
	}

	int fd = open(outpath2.c_str(), O_APPEND|O_SYNC|O_WRONLY|O_CREAT, 0644);
	struct flock alock;
	struct flock ulock;

	// set lock
	alock.l_type = F_WRLCK;
	alock.l_start = 0;
	alock.l_whence = SEEK_SET;
	alock.l_len = 0;

	//set unlock
	ulock.l_type = F_UNLCK;
	ulock.l_start = 0;
	ulock.l_whence = SEEK_SET;
	ulock.l_len = 0;

	// acquire file lock
	fcntl(fd, F_SETLKW, &alock);

	hdfsFile outfile;
	if(hdfsExists(hadoopfs, outpath.c_str()))
	{
		outfile = hdfsOpenFile(hadoopfs, outpath.c_str(), O_WRONLY, 0, 0, 0);
	}
	else
	{
		outfile = hdfsOpenFile(hadoopfs, outpath.c_str(), O_WRONLY|O_APPEND, 0, 0, 0);
	}

	if(outfile == NULL)
	{
		cout<<"[mapreduce]Debugging: openoutfile error"<<endl;
	}

	writeoutfile(&outfile, record);
	hdfsCloseFile(hadoopfs, outfile);

	// relase file lock
	fcntl(fd, F_SETLK, &ulock);
	close(fd);
}

int get_jobid()
{
	return jobid;
}

int writeoutfile(hdfsFile* file, string data)
{
	data.append("\n");
	memset(write_buf, 0, BUF_SIZE);
	strcpy(write_buf, data.c_str());
	hdfsWrite(hadoopfs, *file, write_buf, strlen(write_buf));
}

bool hdfs_getline(hdfsFile* file, string* ret)
{
	int pos = 0;
	int bufsize = 0;
	bufsize = hdfsRead(hadoopfs, *file, read_buf, BUF_SIZE);
	if(bufsize == 0)
	{
		return false;
	}
	else
	{
		*ret = read_buf;
		pos = ret->find_first_of('\n');
		if(pos == string::npos)
		{
			// TODO: append next buffer
		}
		*ret = ret->substr(0, pos);
		hdfsSeek(hadoopfs, *file, hdfsTell(hadoopfs, *file)-(bufsize-pos-1));

		return true;
	}
}

#endif
#ifndef __MAPREDUCE__
#define __MAPREDUCE__

#include <iostream>
#include <errno.h>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <set>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/fcntl.h>
#include <common/fileclient.hh>
#include <common/msgaggregator.hh>
#include <common/hash.hh>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/unistd.h>
#include <arpa/inet.h>

#include "../definitions.hh"

using namespace std;

// user functions
void init_mapreduce(int argc, char** argv); // initialize mapreduce configure
void summ_mapreduce(); // summarize mapreduce configure
void set_mapper(void (*map_func)(string));
void set_reducer(void (*red_func) (string key));
bool is_nextvalue(); // return true if there is next value
bool is_nextrecord(); // return true if there is next value
string get_nextvalue(); // returns values in reduce function
bool get_nextinput(string& inputpath); // process to next input for map role
string get_nextrecord(); // return true when successful, false when out of input record
bool get_nextkey(string* value); // return true when successful, false when out of key value pair
void add_inputpath(string path);
void set_outputpath(string path);
char** get_argv(void); // get user argv excepting passed pipe fd
void write_keyvalue(string key, string value);
void write_output(string record); // function used in reduce function
void enable_Icache(); // function that enables intermediate cache
void set_nummapper(int num); // sets number of mappers
void set_numreducer(int num); // sets number of reducers

int get_argc(void); // get user argc excepting passed pipe fd
int connect_to_server(char *host, unsigned short port);
int get_jobid();

mr_role role = JOB;
char read_buf[BUF_SIZE]; // read buffer for pipe
char write_buf[BUF_SIZE]; // write buffer for pipe

int argcount = -1;
char** argvalues = NULL;

// variables for job role
int port = -1;
int dhtport = -1;
int masterfd = -1;
int ipcfd = -1;
int jobid;
int nummap = 0;
int numreduce = 0;
int completed_map = 0;
int completed_reduce = 0;

bool master_is_set = false; // check if the configure file includes master address
bool isset_outputpath = false;
bool isset_mapper = false;
bool isset_reducer = false;
bool inside_map = false; // true if the code is inside map function 
bool inside_reduce = false; // true if the code is inside reduce function 
bool isIcache = false; // whether Icache option enabled

char master_address[BUF_SIZE];
vector<string> inputpaths; // list of input paths.

int currentpeer = -1;
vector<int> peerids; // list of peer ids on which the idata is located.
vector<int> numiblocks; // list of nummber of iblocks, element of which are mathced to the peerids(vector<int>)
//vector<string> nodelist; // list of slave node addresses
//ifstream input; // input file stream for get_record
//filetype inputtype = NOTOPENED; // type of the input data
//filetype outputtype = NOTOPENED; // type of the input data
string outputpath = "default_output";

// variables for task role
string jobdirpath;
int taskid;
int pipefd[2]; // pipe fd when the role is map task or reduce task
//DHTclient* dhtclient;
fileclient thefileclient;

// variables for map task
void (*mapfunction) (string inputpath); // map function pointer
set<string> reported_keys;
set<string> unreported_keys;

// variables for reduce task
void (*reducefunction) (string key); // reduce function pointer
string nextvalue;
string nextrecord;

bool is_nextval = false;
bool is_nextrec = false;

void init_mapreduce(int argc, char** argv)
{
	int readbytes; // number of bytes read from pipe fd

	// check the arguments do determine the role
	if(argc > 1) // check argc to avoid index out of bound
	{
		if(strncmp(argv[argc-1], "MAP", 3) == 0)
			role = MAP;
		else if(strncmp(argv[argc-1], "REDUCE", 6) == 0)
			role = REDUCE;
		else
			role = JOB;
	}
	else
	{
		role = JOB;
	}

	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			conf>>token;
			strcpy(master_address, token.c_str());
			master_is_set = true;
		}
		else
		{
			cout<<"Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// verify initialization
	if(port == -1)
	{
		cout<<"Port should be specified in the setup.conf"<<endl;
		exit(1);
	}

	if(master_is_set == false)
	{
		cout<<"Master_address should be specified in the setup.conf"<<endl;
		exit(1);
	}


	if(role == JOB) // when the role is job
	{
		// determine the argcount
		argcount = argc;

		masterfd = connect_to_server(master_address, port);
		if(masterfd <= 0)
		{
			cout<<"Connecting to master failed"<<endl;
			exit(1);
		}
		else
		{
			cout<<"Connection to the mater node successfully established"<<endl;
		}

		// a blocking read "whoareyou" signal from master
		readbytes = nbread(masterfd, read_buf);

		if(readbytes == 0) // connection closed
		{
			cout<<"Connection to master is abnormally closed"<<endl;
			cout<<"Exiting..."<<endl;
			exit(1);
		}
		else
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				// respond to "whoareyou"
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "job");
				nbwrite(masterfd, write_buf);

				// blocking read of job id
				while(1)
				{
					readbytes = nbread(masterfd, read_buf);
					if(readbytes == 0)
					{
						cout<<"[mapreduce]Connection from master abnormally close"<<endl;
						break;
					}
					else if(readbytes < 0)
					{
						continue;
					}
					else // reply arrived
					{
						break;
					}
				}

				// register the job id and proceed
				if(strncmp(read_buf, "jobid", 5) == 0)
				{
					char* token;
					token = strtok(read_buf, " "); // token -> jobid
					token = strtok(NULL, " "); // token -> job id(a number)

					// register the job id
					jobid = atoi(token);
				}
				else // if the message is not the 'jobid'
				{
					cout<<"[mapreduce]Debugging: protocol error in mapreduce"<<endl;
				}
				cout<<"[mapreduce]Job submitted(jobid: "<<jobid<<")"<<endl;
			}
			else
			{
				cout<<"Undefined message from master node: "<<read_buf<<endl;
				cout<<"Exiting..."<<endl;
			}
		}

		// set master fd to be nonblocking to avoid deadlock
		fcntl(masterfd, F_SETFL, O_NONBLOCK);
	}
	else if(role == MAP)// when the role is map task 
	{
		// process pipe arguments and write id
		pipefd[0] = atoi(argv[argc-3]); // read fd
		pipefd[1] = atoi(argv[argc-2]); // write fd
		argcount = argc - 3;

		// request the task configuration
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "requestconf");
		nbwrite(pipefd[1], write_buf);

		// blocking read until the arrival of 'taskconf' message from master
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		readbytes = nbread(pipefd[0], read_buf);

		if(readbytes == 0)
		{
			cout<<"[mapreduce]The connection from slave node is abnormally closed"<<endl;
			exit(1);
		}

		char* token;
		token = strtok(read_buf, " "); // token <- "taskconf"

		token = strtok(NULL, " "); // token <- jobid

		jobid = atoi(token);

		stringstream jobidss;

		jobidss << ".job_";
		jobidss << jobid;
		jobidss << "_";
		jobdirpath = jobidss.str();

		token = strtok(NULL, " "); // token <- taskid

		taskid = atoi(token);
		// read messages from slave until getting Einput
		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0)
			{
				cout<<"[mapreduce]Connection from slave is abnormally closed"<<endl;
			}
			else if(readbytes < 0)
			{
				cout<<"[mapreduce]A negative return from nbread with blocking read"<<endl;
				continue;
			}
			else // a message
			{
				if(strncmp(read_buf, "inputpath", 9) == 0)
				{
					token = strtok(read_buf, " "); // token <- "inputpath"
					
					token = strtok(NULL, " "); // first path

					while(token != NULL)
					{
						// add the input path to the task
						inputpaths.push_back(token);

						token = strtok(NULL, " ");
					}
				}
				else if(strncmp(read_buf, "Einput", 6) == 0)
				{
					// break the while loop
					break;
				}
				else
				{
					cout<<"[mapreduce]Unexpected message order from slave"<<endl;
				}
			}
		}

		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
	else // when the role is reduce
	{
		// process pipe arguments and write id
		pipefd[0] = atoi(argv[argc-3]); // read fd
		pipefd[1] = atoi(argv[argc-2]); // write fd
		argcount = argc - 3;

		// request the task configuration
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "requestconf");
		nbwrite(pipefd[1], write_buf);

		// blocking read until the arrival of 'taskconf' message from master
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);
		readbytes = nbread(pipefd[0], read_buf);

		if(readbytes == 0)
		{
			cout<<"[mapreduce]The connection from slave node is abnormally closed"<<endl;
			exit(1);
		}

		char* token;
		token = strtok(read_buf, " "); // token <- "taskconf"

		token = strtok(NULL, " "); // token <- jobid

		jobid = atoi(token);

		stringstream jobidss;

		jobidss << ".job_";
		jobidss << jobid;
		jobidss << "_";
		jobdirpath = jobidss.str();

		token = strtok(NULL, " "); // token <- taskid

		taskid = atoi(token);

		// read messages from slave until getting Einput
		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0)
			{
				cout<<"[mapreduce]Connection from slave is abnormally closed"<<endl;
			}
			else if(readbytes < 0)
			{
				cout<<"[mapreduce]A negative return from nbread with blocking read"<<endl;
				continue;
			}
			else // a message
			{
				if(strncmp(read_buf, "inputpath", 9) == 0)
				{
					token = strtok(read_buf, " "); // token <- "inputpath"
					
					token = strtok(NULL, " "); // first peer id

					while(token != NULL)
					{
						// add the input path to the task
						peerids.push_back(atoi(token));

						token = strtok(NULL, " "); // number of iblock
						numiblocks.push_back(atoi(token));

						token = strtok(NULL, " "); // next peer id
					}
					break;
				}
				else
				{
					cout<<"[mapreduce]Unexpected message order from slave"<<endl;
				}
			}
		}

		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}

	// parse user arguments
	argvalues = new char*[argcount];
	for(int i=0; i<argcount; i++) // copy argv into argvalues to get user argv
	{
		argvalues[i] = new char[strlen(argv[i])+1];
		strcpy(argvalues[i], argv[i]);
	}
}

void summ_mapreduce()
{
	int readbytes;
	// TODO: make sure that all configuration are done

	if(argcount == -1) // mapreduce has not been initialized with init_mapreduce() func
	{
		cout<<"Mapreduce has not been initialized"<<endl;
		exit(1);
	}

	if(role == JOB) // running job
	{
		if((nummap >= 0 && isset_mapper) || (numreduce >= 0 && isset_reducer)) // when neither mapper and reducer are activated
		{
			// send all necessary information to the master node
			string write_string = "jobconf ";
			stringstream ss;

			ss << "argcount ";
			ss << argcount;

			// parse the arguments
			ss<<" argvalues";

			// find the program name and pass as 0th argument
			char* tmp = new char[strlen(argvalues[0])+1];
			string apath = MR_PATH;
			char* token;
			char* next_token;

			strcpy(tmp, argvalues[0]);
			next_token = strtok(tmp, "/");

			while(next_token != NULL)
			{
				token = next_token;
				next_token = strtok(NULL, "/");
			}

			ss<<" ";
			apath.append("app/");
			apath.append(token); // token <- the program name
			ss << apath;

			delete[] tmp;

			for(int i=1;i<argcount;i++)
			{
				ss<<" ";
				ss<<argvalues[i];
			}

			ss << " nummap ";
			ss << nummap;
			ss << " numreduce ";
			ss << numreduce;

			write_string.append(ss.str());
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, write_string.c_str());
			nbwrite(masterfd, write_buf);

			// prepare inputpath message
			stringstream ss2;
			string message;
			int iter = 0;

			ss2 << "inputpath ";
			ss2 << inputpaths.size();
			message = ss2.str();

			while((unsigned)iter < inputpaths.size())
			{
				if(message.length() + inputpaths[iter].length() + 2 < BUF_SIZE) // +1 for white space, +1 for zero packet
				{
					message.append(" ");
					message.append(inputpaths[iter]);
				}
				else
				{
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(masterfd, write_buf);

					message = inputpaths[iter];
				}

				iter++;
			}

			// send last message
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, message.c_str());
			nbwrite(masterfd, write_buf);
		}

		// blocking read from master until "complete" receiving message
		fcntl(masterfd, F_SETFL, fcntl(masterfd, F_GETFL) & ~O_NONBLOCK);

		while(1)
		{
			readbytes = nbread(masterfd, read_buf);
			if(readbytes == 0) // master abnormally terminated
			{
				// TODO: Terminate the job properly
				while(close(pipefd[0]) < 0)
				{
					cout<<"close failed"<<endl;

					// sleeps for 1 milli seconds
					usleep(100000);
				}
				while(close(pipefd[1]) < 0)
				{
					cout<<"close failed"<<endl;

					// sleeps for 1 milli seconds
					usleep(100000);
				}
				cout<<"[mapreduce]Connection to master abnormally closed"<<endl;
				exit(0);
			}
			else
			{
				if(strncmp(read_buf, "complete", 8) == 0) // "complete" message received
				{
					cout<<"[mapreduce]Job "<<jobid<<" is successfully completed"<<endl;
					break;
				}
				else if(strncmp(read_buf, "mapcomplete", 11) == 0)
				{
					cout<<"[mapreduce]Map tasks are completed"<<endl;
				}
			}
		}
		exit(0);
	}
	else if(role == MAP) // map task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}

		// run the mapfunction until input all inputs are processed
		thefileclient.connect_to_server();

		if(isset_mapper)
		{
			string inputpath;
			while(get_nextinput(inputpath))
			{
				inside_map = true;
				(*mapfunction)(inputpath);
				inside_map = false;

				// report generated keys to slave node
				/*
				while(!unreported_keys.empty())
				{
					string key = *unreported_keys.begin();
//cout<<"[mapreduce]Debugging: key emitted: "<<key<<endl;
					unreported_keys.erase(*unreported_keys.begin());
					reported_keys.insert(key);

					// send 'key' meesage to the slave node
					keybuffer.add_record(key);
				}
				*/
			}
//cout<<"[mapreduce]Finished all map tasks..."<<endl;
		}

		set<int> peerids;
		thefileclient.wait_write(&peerids);

		string message;
		stringstream ss;

		ss << "complete";

		for(set<int>::iterator it = peerids.begin(); it != peerids.end(); it++)
		{
			ss << " ";
			ss << *it;
		}

		message = ss.str();

		// send complete message with peerds
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, message.c_str());
		nbwrite(pipefd[1], write_buf);

//cout<<"[mapreduce]Complete message sent..."<<endl;

		// blocking read until the 'terminate' message
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);

		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				// TODO: Terminate the task properly
				cout<<"[mapreduce]Connection from master abnormally closed"<<endl;
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
// cout<<"[mapreduce]Map task is successfully completed"<<endl;

					// terminate successfully
					while(close(pipefd[0]) < 0)
					{
cout<<"[mapreduce]close failed"<<endl;
						// sleeps for 1 milli seconds
						usleep(1000);
					}
					while(close(pipefd[1]) < 0)
					{
cout<<"[mapreduce]close failed"<<endl;
						// sleeps for 1 milli seconds
						usleep(1000);
					}
					exit(0);
				}
				else // all other messages are ignored
					continue;
			}
			else
			{
				usleep(1000);
			}
			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100000);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
	else // reduce task
	{
		// check whether no map or reduce function is running
		if(inside_map || inside_reduce)
		{
			cout<<"[mapreduce]Debugging: The map or reduce function is called from the map or reduce function."<<endl;
		}

		thefileclient.connect_to_server();

		// run the reduce functions until all key are processed
		if(isset_reducer)
		{
			// request first key
			currentpeer = 0;
			string ipath;
			stringstream ss;

			ss << jobid;
			ss << " ";
			ss << peerids[currentpeer];
			ss << " ";
			ss << numiblocks[currentpeer];

			ipath = ss.str();

			thefileclient.read_request(ipath, INTERMEDIATE);

			currentpeer++;

			// run reducers
			string key;
			while(get_nextkey(&key))
			{
				inside_reduce = true;
				(*reducefunction)(key);
				inside_reduce = false;
			}
		}

		thefileclient.wait_write(NULL);

		// send complete message
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, "complete");
		nbwrite(pipefd[1], write_buf);

		// blocking read until 'terminate' message arrive
		fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) & ~O_NONBLOCK);

		while(1)
		{
			readbytes = nbread(pipefd[0], read_buf);
			if(readbytes == 0) // pipe fd was closed abnormally
			{
				cout<<"the reduce task is gone"<<endl;
				exit(0);
			}
			else if(readbytes > 0)
			{
				if(strncmp(read_buf, "terminate", 9) == 0)
				{
					// cout<<"[mapreduce]Reduce task is successfully completed"<<endl; // <- this message will be printed in the slave process side

					// terminate successfully
					exit(0);
				}
				else // all other messages are ignored
					continue;
			}

			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100000);
		}
		fcntl(pipefd[0], F_SETFL, O_NONBLOCK);
	}
}

int get_argc(void)
{
	return argcount;
}

char** get_argv(void)
{
	return argvalues;
}
void set_mapper(void (*map_func)(string))
{
	isset_mapper = true;
	mapfunction = map_func;
}

void set_reducer(void (*red_func) (string key))
{
	isset_reducer = true;
	reducefunction = red_func;
}

void add_inputpath(string path) // the path is relative path to DHT_PATH
{
	if(role == JOB)
	{
		inputpaths.push_back(path);
	}
	else if(role == MAP)
	{
		// do nothing
	}
	else // role is reduce
	{
		// do nothing
	}
}

void set_outputpath(string path) // this user function can be used in anywhere but before initialization
{
	isset_outputpath = true;
	outputpath = path;
}

int connect_to_server(char *host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent *hp;

	// SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd < 0)
	{
		cout<<"[mapreduce]Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);

	if(hp == NULL)
	{
		cout<<"[mapreduce]Cannot find host by host name"<<endl;
		return -1;
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void write_keyvalue(string key, string value)
{
	// check if thie function is called inside the map function
	if(inside_map)
	{
		thefileclient.write_record(key, value, INTERMEDIATE);
	}
	else
	{
		cout<<"[mapreduce]Warning: the write_keyvalue() function is being used outside the map function"<<endl;
	}
}

bool get_nextinput(string& inputpath) // internal function to process next input file
{
	if(inputpaths.size() == 0) // no more input
	{
		return false;
	}
	else
	{
		// request the location of the input to the dht server
		// NOTE: for this version, we can simply call hash function
		// rather than requesting to dht server
		/*
		string address;
		string inputname = inputpaths.back();

		// use read_buf as temporal buffer for hash function
		memset(read_buf, 0, BUF_SIZE);
		strcpy(read_buf, inputname.c_str());
		
		uint32_t hashvalue = h(read_buf, HASHLENGTH);
		hashvalue = hashvalue%nodelist.size();

		address = nodelist[hashvalue];
		*/

		bool readsuccess = false;
		bool cachehit = false;
		string request;
		stringstream ss;

		// configure request message of write buffer
		ss << argvalues[0]; // app/[app name]  <- for Icache
		ss << " ";
		ss << jobid;
		ss << " ";
		ss << inputpaths.back();

		request = ss.str();

		// request <- app/[app name] [job directory path] [input path]
		cachehit = thefileclient.read_request(request, RAW);

		while(cachehit)
		{
			// forward to next input
			inputpaths.pop_back();

			// return false if inputpaths is empty
			if(inputpaths.size() == 0)
				return false;

			stringstream ss1;
			// configure request message of write buffer
			ss1 << argvalues[0]; // app/[app name]  <- for Icache
			ss1 << " ";
			ss1 << jobid;
			ss1 << " ";
			ss1 << inputpaths.back();

			request = ss1.str();

			// request <- app/[app name] [input path]
			cachehit = thefileclient.read_request(request, RAW);
		}
		
		thefileclient.configure_buffer_initial(jobdirpath, argvalues[0], inputpaths.back(), isIcache);
		inputpath = inputpaths.back();
		inputpaths.pop_back();

		// pre-process first record
		readsuccess = thefileclient.read_record(nextrecord);

		if(readsuccess)
			is_nextrec = true;
		else
			is_nextrec = false;

		return true;
	}
}

string get_nextrecord() // a user function for the map
{
	if(inside_map)
	{
		bool readsuccess = false;
		string ret = nextrecord;
		readsuccess = thefileclient.read_record(nextrecord);

		if(readsuccess)
			is_nextrec = true;
		else
			is_nextrec = false;

		return ret;
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextrecord() function is being used outside the map function"<<endl;
		return "";
	}
}

bool is_nextrecord()
{
	if(inside_map)
	{
		return is_nextrec;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextrecord() function is being used outside the map function"<<endl;
		return false;
	}
}

bool get_nextkey(string* key) // internal function for the reduce
{
	if(is_nextval) // if there are some remaining values of this key
	{
		// flush all values of this key
		bool readsuccess = true;

		while(readsuccess)
		{
			readsuccess = thefileclient.read_record(nextvalue);
		}
	}

	// get next key
	bool readsuccess = thefileclient.read_record(*key);

	if(readsuccess) // next key exist
	{
		readsuccess = thefileclient.read_record(nextvalue);

		if(readsuccess)
		{
			is_nextval = true;
		}
		else
		{
			is_nextval = false;
			cout<<"[mapreduce]Unexpected respond after read_request(1)"<<endl;
			cout<<"[mapreduce]key received: "<<*key<<endl;
			return false;
		}

		return true;
	}
	else // no next key in this node
	{
		if((unsigned)currentpeer < peerids.size()) // another peer to go
		{
			// request to next peer
			string ipath;
			stringstream ss;

			ss << jobid;
			ss << " ";
			ss << peerids[currentpeer];
			ss << " ";
			ss << numiblocks[currentpeer];

			ipath = ss.str();

			thefileclient.read_request(ipath, INTERMEDIATE);

			currentpeer++;

			// receive first key
			readsuccess = thefileclient.read_record(*key);

			if(readsuccess) // first key exist
			{
				readsuccess = thefileclient.read_record(nextvalue);

				if(readsuccess)
				{
					is_nextval = true;
				}
				else
				{
					cout<<"[mapreduce]Unexpected respond after read_request(2)"<<endl;
				}
			}
			else // no first key
			{
				cout<<"[mapreduce]Unexpected respond after read_request(3)"<<endl;
			}

			return true;
		}
		else
		{
			return false;
		}
	}
}

bool is_nextvalue() // returns true if there is next value
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		return is_nextval;
	}
	else
	{
		cout<<"[mapreduce]Warning: the is_nextvalue() function is being used outside the reduce function"<<endl;
		return false;
	}
}

string get_nextvalue() // returns values in reduce function
{
	// check if this function is called inside the reduce function
	if(inside_reduce)
	{
		string ret = nextvalue;
		bool readsuccess = false;

		if(!is_nextval) // no next value
		{
			return "";
		}
		else
		{
			readsuccess = thefileclient.read_record(nextvalue); // key value record

			// pre-process first record
			if(readsuccess)
				is_nextval = true;
			else
				is_nextval = false;

			return ret;
		}
	}
	else
	{
		cout<<"[mapreduce]Warning: the get_nextvalue() function is being used outside the reduce function"<<endl;
		return "";
	}
}

void write_output(string record) // this user function can be used anywhere but after initialization
{
	if(!isset_outputpath)
	{
		stringstream ss;
		ss << "job_";
		ss << jobid;
		ss << ".txt";
		outputpath = ss.str();
	}

	thefileclient.write_record(outputpath, record, OUTPUT);
}

void set_nummapper(int num) // sets number of mappers
{
	nummap = num;
}

void set_numreducer(int num) // sets number of reducers
{
	numreduce = num;
}

int get_jobid()
{
	return jobid;
}

void enable_Icache() // function that enables intermediate cache
{
	isIcache = true;
}

#endif
#include "master.hh"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <mapreduce/definitions.hh>
#include "master_job.hh"
#include "master_task.hh"
#include "connslave.hh"
#include "connclient.hh"

using namespace std;

vector<connslave*> slaves;
vector<connclient*> clients;

vector<master_job*> jobs;

int port = -1;
int dhtport = -1;
int max_job = -1;
int jobidclock = 0; // job id starts 0
bool thread_continue;

vector<string> nodelist;

char read_buf[BUF_SIZE]; // read buffer for signal_listener thread
char write_buf[BUF_SIZE]; // write buffer for signal_listener thread


// --------------------------master protocol---------------------------------
// 1. whoareyou: send a message to identify the connected node
// 2. close: let the destination node close the connection from the master
// 3. ignored: let connected node know message from it was ignored
// 4. result: contains resulting messeage to client followed by 'result:'
// --------------------------------------------------------------------------
// TODO: make protocols to integer or enum

int main(int argc, char** argv)
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			conf>>token;
			max_job = atoi(token.c_str());
		}
		else if(token == "master_address")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else
		{
			cout<<"[master]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();
	// verify initialization
	if(port == -1)
	{
		cout<<"[master]port should be specified in the setup.conf"<<endl;
		exit(1);
	}
	if(max_job == -1)
	{
		cout<<"[master]max_job should be specified in the setup.conf"<<endl;
		exit(1);
	}

	// read the node list information
	ifstream nodelistfile;
	string filepath = LIB_PATH;
	filepath.append("nodelist.conf");

	nodelistfile.open(filepath.c_str());
	nodelistfile>>token;
	while(!nodelistfile.eof())
	{
		nodelist.push_back(token);
		nodelistfile>>token;
	}
	

	int serverfd = open_server(port);
	if(serverfd < 0)
	{
		cout<<"[master]Openning server failed"<<endl;
		return 1;
	}

	struct sockaddr_in connaddr;
	int addrlen = sizeof(connaddr);
	char* haddrp;

	while(1) // receives connection from slaves
	{
		int fd;
		fd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);
		if(fd < 0)
		{
			cout<<"[master]Accepting failed"<<endl;

			// sleep 0.0001 seconds. change this if necessary
			// usleep(100);
			continue;
		}
		else
		{
			// check if the accepted node is slave or client
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, "whoareyou");
			nbwrite(fd, write_buf);

			// this is a blocking read
			// so don't need to check the transfer completion: nono
			nbread(fd, read_buf);

			if(strncmp(read_buf, "slave", 5) == 0) // slave connected
			{
				// add connected slave to the slaves
				slaves.push_back(new connslave(fd));

				// get ip address of slave
				haddrp = inet_ntoa(connaddr.sin_addr);
				printf("slave node connected from %s \n", haddrp);
			}
			else if(strncmp(read_buf, "client", 6) == 0) // client connected
			{
				clients.push_back(new connclient(fd));

				// set sockets to be non-blocking socket to avoid deadlock
				fcntl(clients.back()->getfd(), F_SETFL, O_NONBLOCK);

				// get ip address of client
				haddrp = inet_ntoa(connaddr.sin_addr);
				printf("a client node connected from %s \n", haddrp);
			}
			else if(strncmp(read_buf, "job", 3) == 0)
			{
				// TODO: deal with the case that a job joined the
				// server before all slave connected
			}
			else // unknown connection
			{
				// TODO: deal with this case
				cout<<"[master]Unknown connection"<<endl;
			}

			// break if all slaves are connected
			if(slaves.size() == nodelist.size())
			{
				cout<<"[master]All slave nodes are connected successfully"<<endl;
				// set maximum number of task 4 for each slave as default
				for(int i=0;(unsigned)i<slaves.size();i++)
					slaves[i]->setmaxtask(4);

				break;
			}
			else if(slaves.size() > nodelist.size())
			{
				cout<<"[master]Number of slave connection exceeded allowed limits"<<endl;
				cout<<"[master]\tDebugging needed on this problem"<<endl;
			}
			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
	}


	// set sockets to be non-blocking socket to avoid deadlock
	fcntl(serverfd, F_SETFL, O_NONBLOCK);
	for(int i=0;(unsigned)i<slaves.size();i++)
		fcntl(slaves[i]->getfd(), F_SETFL, O_NONBLOCK);

	// create listener thread and run
	thread_continue = true;
	pthread_t listener_thread;
	pthread_create(&listener_thread, NULL, signal_listener, (void*)&serverfd);

	// sleeping loop which prevents process termination
	while(thread_continue)
		sleep(1);

	return 0;
}

int open_server(int port)
{
	int serverfd;
	struct sockaddr_in serveraddr;

	// socket open
	serverfd = socket(AF_INET, SOCK_STREAM, 0);
	if(serverfd<0)
		cout<<"[master]Socket opening failed"<<endl;

	// bind
	memset((void *) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons((unsigned short) port);
	if(bind(serverfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		cout<<"[master]Binding failed"<<endl;
		return -1;
	}

	// listen
	if(listen(serverfd, BACKLOG) < 0)
	{
		cout<<"[master]Listening failed"<<endl;
		return -1;
	}
	return serverfd;
}

void* signal_listener(void* args)
{
	int serverfd = *((int*)args);
	int readbytes = 0;
	int tmpfd = -1; // store fd of new connected node temporarily
	char* haddrp;
	struct sockaddr_in connaddr;
	int addrlen = sizeof(connaddr);

	// listen signals from nodes and listen to node connection
	while(1)
	{
		// check client connection
		tmpfd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);
		if(tmpfd >= 0)
		{
			// send "whoareyou" message to connected node
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, "whoareyou");
			nbwrite(tmpfd, write_buf);

			// blocking read to check identification of connected node
			readbytes = nbread(tmpfd, read_buf);
			if(readbytes == 0)
			{
				cout<<"[master]Connection closed from client before getting request"<<endl;

				close(tmpfd);
				tmpfd = -1;
				continue;
			}

			fcntl(tmpfd, F_SETFL, O_NONBLOCK); // set socket to be non-blocking socket to avoid deadlock

			if(strncmp(read_buf, "client", 6) == 0) // if connected node is a client
			{
				// get ip address of client
				haddrp = inet_ntoa(connaddr.sin_addr);
				printf("[master]Client node connected from %s \n", haddrp);

				clients.push_back(new connclient(tmpfd));
			}
			else if(strncmp(read_buf, "slave", 5) == 0)
			{
				cout<<"[master]Unexpected connection from slave: "<<endl;
				cout<<"[master]Closing connection to the slave..."<<endl;

				// check this code
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "close");
				nbwrite(tmpfd, write_buf);
				close(tmpfd);
			}
			else if(strncmp(read_buf, "job", 3) == 0) // if connected node is a job
			{
				// limit the maximum available job connection
				if(jobs.size() == (unsigned)max_job)
				{
					cout<<"[master]Cannot accept any more job request due to maximum job connection limit"<<endl;
					cout<<"[master]\tClosing connection from the job..."<<endl;
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "nospace");
					nbwrite(tmpfd, write_buf);
					close(tmpfd);
					break;
				}

				// send the job id to the job
				stringstream jobidss;
				jobidss<<"jobid ";
				jobidss<<jobidclock;
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, jobidss.str().c_str());
				nbwrite(tmpfd, write_buf);

				cout<<"[master]Job "<<jobidclock<<" arrived"<<endl;
				jobs.push_back(new master_job(jobidclock, tmpfd));
				jobidclock++;
			}
			else
			{
				cout<<"[master]Unidentified connected node: "<<endl;
				cout<<"[master]Closing connection to the node..."<<endl;
				close(tmpfd);
			}
		}

		// listen to slaves
		for(int i=0; (unsigned)i<slaves.size(); i++)
		{
			readbytes = nbread(slaves[i]->getfd(), read_buf);
			if(readbytes == 0) // connection closed from slave
			{
				cout<<"[master]Connection from a slave closed"<<endl;
				delete slaves[i];
				slaves.erase(slaves.begin()+i);
				i--;
				continue;
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else // signal from the slave
			{
				if(strncmp(read_buf, "key", 3) == 0) // key signal arrived
				{
					char* token;
					master_job* thejob;
					token = strtok(read_buf, " "); // token <- "key"
					token = strtok(NULL, " "); // token <- "jobid"
					token = strtok(NULL, " "); // token <- job id
					
					thejob = find_jobfromid(atoi(token));

					token = strtok(NULL, " "); // token <- key value
					thejob->add_key(token); // token 
				}
				else if(strncmp(read_buf, "taskcomplete", 12) == 0) // "taskcomplete" signal arrived
				{
					char* token;
					int ajobid, ataskid;
					master_job* thejob;
					master_task* thetask;

					token = strtok(read_buf, " "); // token <- "taskcomplete"
					token = strtok(NULL, " "); // token <- "jobid"
					token = strtok(NULL, " "); // token <- job id
					ajobid = atoi(token);

					token = strtok(NULL, " "); // token <- "taskid"
					token = strtok(NULL, " "); // token <- task id
					ataskid = atoi(token);

					thejob = find_jobfromid(ajobid);
					thetask = thejob->find_taskfromid(ataskid);
					thejob->finish_task(thetask, slaves[i]);
				}
				else
				{
					cout<<"[master]Undefined message from slave node: "<<read_buf<<endl;
					cout<<"[master]Undefined message size:"<<readbytes<<endl;
				}
			}
		}

		// listen to clients
		for(int i=0; (unsigned)i<clients.size(); i++)
		{
			readbytes = nbread(clients[i]->getfd(), read_buf);
			if(readbytes == 0) // connection closed from client
			{
				cout<<"[master]Connection from a client closed"<<endl;
				delete clients[i];
				clients.erase(clients.begin()+i);
				i--;
				continue;
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else // signal from the client
			{
				cout<<"[master]Message accepted from client: "<<read_buf<<endl;
				if(strncmp(read_buf, "stop", 4) == 0) // "stop" signal arrived
				{
					int currfd = clients[i]->getfd(); // store the current client's fd

					// stop all slave
					for(int j=0;(unsigned)j<slaves.size();j++)
					{
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "close");
						nbwrite(slaves[j]->getfd(), write_buf);

						// blocking read from slave
						fcntl(slaves[j]->getfd(), F_SETFL, fcntl(slaves[j]->getfd(), F_GETFL) & ~O_NONBLOCK);
						readbytes = nbread(slaves[j]->getfd(), read_buf);
						if(readbytes == 0) // closing slave succeeded
						{
							delete slaves[j];
							slaves.erase(slaves.begin()+j);
							j--;
						}
						else // message arrived before closed
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, "ignored");
							nbwrite(slaves[j]->getfd(), write_buf);
							j--;
							continue;
						}
						cout<<"[master]Connection from a slave closed"<<endl;
					}
					cout<<"[master]All slaves closed"<<endl;

					// stop all client except the one requested stop
					for(int j=0;(unsigned)j<clients.size();j++)
					{
						if(currfd==clients[j]->getfd()) // except the client who requested the stop
							continue;

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "close");
						nbwrite(clients[j]->getfd(), write_buf);

						// blocking read from client
						fcntl(clients[j]->getfd(), F_SETFL, fcntl(clients[j]->getfd(), F_GETFL) & ~O_NONBLOCK);
						readbytes = nbread(clients[j]->getfd(), read_buf);
						if(readbytes == 0) // closing client succeeded
						{
							delete clients[j];
							clients.erase(clients.begin()+j);
							j--;
						}
						else // message arrived before closed
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, "ignored");
							nbwrite(clients[j]->getfd(), write_buf);
							j--;
							continue;
						}
						cout<<"[master]Connection from a client closed"<<endl;
					}
					cout<<"[master]All clients closed"<<endl;

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "result: stopping successful");
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numslave", 8) == 0) // "numslave" signal arrived
				{
					string ostring = "result: number of slave nodes = ";
					stringstream ss;
					ss<<slaves.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numclient", 9) == 0) // "numclient" signal arrived
				{
					string ostring = "result: number of client nodes = ";
					stringstream ss;
					ss<<clients.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numjob", 6) == 0) // "numjob" signal arrived
				{
					string ostring = "result: number of running jobs = ";
					stringstream ss;
					ss<<jobs.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numtask", 7) == 0) // "numtask" signal arrived
				{
					string ostring = "result: number of running tasks = ";
					stringstream ss;
					int numtasks = 0;
					for(int j=0;(unsigned)j<jobs.size();j++)
					{
						numtasks += jobs[j]->get_numtasks();
					}
					ss<<numtasks;
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else // undefined signal
				{
					cout<<"[master]Undefined signal from client: "<<read_buf<<endl;
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "result: error. the request is unknown");
					nbwrite(clients[i]->getfd(), write_buf);
				}
			}
		}

		// check messages from jobs
		for(int i=0; (unsigned)i<jobs.size(); i++)
		{
			readbytes = nbread(jobs[i]->getjobfd(), read_buf);
			if(readbytes == 0) // connection to the job closed. maybe process terminated
			{
				delete jobs[i];
				jobs.erase(jobs.begin()+i);
				i--;
				cout<<"[master]Job terminated abnormally"<<endl;
				continue;
			}
			else if(readbytes < 0)
			{
				// do nothing
			}
			else // signal from the job
			{
				if(strncmp(read_buf, "complete", 8) == 0) // "succompletion" signal arrived
				{
					cout<<"[master]Job "<<jobs[i]->getjobid()<<" successfully completed"<<endl;

					// clear up the completed job
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "terminate");
					nbwrite(jobs[i]->getjobfd(), write_buf);

					// delete the job from the vector jobs
					delete jobs[i];
					jobs.erase(jobs.begin()+i);
					i--;
				}
				else if(strncmp(read_buf, "jobconf", 7) == 0) // "jobconf" message arrived
				{
					char* token;
					token = strtok(read_buf, " "); // token -> jobconf
					token = strtok(NULL, " "); // token -> nummap expected

					// parse all configure
					while(token != NULL)
					{
						if(strncmp(token, "argcount", 8) == 0)
						{
							// NOTE: there should be at leat 1 arguments(program path name)
							token = strtok(NULL, " "); // token <- argument count
							jobs[i]->setargcount(atoi(token));

							// process next configure
							token = strtok(NULL, " "); // token -> argvalues

							// check the protocl
							if(strncmp(token, "argvalues", 9) != 0) // if the token is not 'argvalues'
								cout<<"Debugging: the 'jobconf' protocol conflicts."<<endl;

							char** arguments = new char*[jobs[i]->getargcount()];
							for(int j=0;j<jobs[i]->getargcount();j++)
							{
								token = strtok(NULL, " ");
								arguments[j] = new char[strlen(token)+1];
								strcpy(arguments[j], token);
							}
							jobs[i]->setargvalues(arguments);
						}
						else if(strncmp(token, "inputpath", 9) == 0)
						{
							int numpath;
							string tmp;
							token = strtok(NULL, " "); // token -> number of input paths

							numpath = atoi(token);
							for(int j=0;j<numpath;j++)
							{
								tmp = strtok(NULL, " ");
								jobs[i]->add_inputpath(tmp);
							}
						}
						else
						{
							cout<<token<<": unknown job configure in the master side"<<endl;
						}

						// process next configure
						token = strtok(NULL, " ");
					}
					if(jobs[i]->getnummap() == 0)
						jobs[i]->setnummap(jobs[i]->get_numinputpaths());

					// create map tasks
					for(int j=0;j<jobs[i]->getnummap();j++)
					{
						jobs[i]->add_task(new master_task(jobs[i], MAP));
					}

					// map inputpaths to each map tasks
					int path_iteration = 0;
					while(path_iteration<jobs[i]->get_numinputpaths())
					{
						for(int j=0;j<jobs[i]->get_numtasks() && path_iteration<jobs[i]->get_numinputpaths();j++)
						{
							jobs[i]->get_task(j)->add_inputpath(jobs[i]->get_inputpath(path_iteration));
							path_iteration++;
						}
					}

					// set job status as MAP_STAGE
					jobs[i]->set_stage(MAP_STAGE);
				}
				else // undefined signal
				{
					cout<<"[master]Undefined signal from job: "<<read_buf<<endl;
				}
			}

			// check if all task finished
			if(jobs[i]->get_numtasks() == jobs[i]->get_numcompleted_tasks())
			{
				if(jobs[i]->get_stage() == MAP_STAGE) // if map stage is finished
				{
					// send message to the job to inform that map phase is completed
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "mapcomplete");
					nbwrite(jobs[i]->getjobfd(), write_buf);

					cout<<"[master]Number of keys generated from map phase: "<<jobs[i]->get_numkey()<<endl;
					// fork reduce tasks
					for(set<string>::iterator it = jobs[i]->get_keybegin();it != jobs[i]->get_keyend(); it++)
					{
						master_task* newtask = new master_task(jobs[i], REDUCE);
						jobs[i]->add_task(newtask);
						newtask->add_inputpath(*it);
					}
					jobs[i]->set_stage(REDUCE_STAGE);
				}
				else if(jobs[i]->get_stage() == REDUCE_STAGE) // if reduce stage is finished
				{
					// send message to the job to complete the job
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "complete");
					nbwrite(jobs[i]->getjobfd(), write_buf);
					cout<<"[master]Job "<<jobs[i]->getjobid()<<" completed successfully"<<endl;

					jobs[i]->set_stage(COMPLETED_STAGE);
					// clear the job from the vector and finish
					delete jobs[i];
					jobs.erase(jobs.begin()+i);
					i--;

					continue;
				}
				else
				{
					// pass the case for INITIAL_STAGE and COMPLETED_STAGE
				}
			}
		}

		// process and schedule jobs and tasks
		for(int i=0; (unsigned)i<jobs.size(); i++)
		{
			// default scheduler: FCFS-like scheduler
			for(int j=0;(unsigned)j<slaves.size();j++)
			{
				while((slaves[j]->getnumrunningtasks() < slaves[j]->getmaxtask()) && (jobs[i]->get_lastwaitingtask() != NULL)) // schedule all the slot if none of the slot is avilable
				{
					master_task* thetask = jobs[i]->get_lastwaitingtask();
					// write to the slave the task information
					stringstream ss;
					ss<<"tasksubmit ";
					ss<<"jobid ";
					ss<<jobs[i]->getjobid();
					ss<<" ";
					ss<<"taskid ";
					ss<<thetask->gettaskid();
					ss<<" role ";
					if(thetask->get_taskrole() == MAP)
						ss<<"MAP";
					else if(thetask->get_taskrole() == REDUCE)
						ss<<"REDUCE";
else
cout<<"[master]Debugging: the role of the task not defined in the initialization step:756";

					ss<<" inputpath ";
					ss<<thetask->get_numinputpaths(); // number of input paths

					// parse all the input paths
					for(int k=0;k<thetask->get_numinputpaths();k++)
					{
						ss<<" ";
						ss<<thetask->get_inputpath(k);
					}

					ss<<" argcount ";
					ss<<thetask->get_job()->getargcount();

					// NOTE: there should be at leat 1 arguments(program path name)
					ss<<" argvalues";
					for(int k=0;k<thetask->get_job()->getargcount();k++)
					{
						ss<<" ";
						ss<<thetask->get_job()->getargvalue(k);
					}
if(ss.str().length()>=BUF_SIZE)
cout<<"[master]Debugging: the argument string exceeds the limited length"<<endl;
					
					string tmp = ss.str();
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, tmp.c_str());
					nbwrite(slaves[j]->getfd(), write_buf);

					// forward waiting task to slave slot
					jobs[i]->schedule_task(thetask, slaves[j]);
					// sleeps for 0.0001 seconds. change this if necessary
					// usleep(100);
				}
			}
		}

		// break if all slaves and clients are closed
		if(slaves.size() == 0 && clients.size() == 0)
			break;

		// sleeps for 0.0001 seconds. change this if necessary
		// usleep(100);
	}

	// close master socket
	close(serverfd);
	cout<<"[master]Master server closed"<<endl;

	cout<<"[master]Exiting master..."<<endl;

	thread_continue = false;
	return NULL;
}

master_job* find_jobfromid(int id)
{
	for(int i=0;(unsigned)i<jobs.size();i++)
	{
		if(jobs[i]->getjobid() == id)
			return jobs[i];
	}
cout<<"[master]No such a job with input job id in find_jobfromid() function."<<endl;
	return NULL;
}
#ifndef __MASTER__
#define __MASTER__

#include <iostream>
#include <string>
#include "master_job.hh"


int open_server(int port); // function which receive connections from slaves
void *accept_client(void *args); // thread function used to receive connections from clients
void *signal_listener(void *args); // thread function used to communicate with connected nodes
void run_job(char* buf_content, master_job* thejob); // run submitted job
master_job* find_jobfromid(int id); // find and return job pointer fro its jobid

#endif
#include "master.hh"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <sys/unistd.h>
#include <sys/un.h>
#include <common/msgaggregator.hh>
#include <common/hash.hh>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <mapreduce/definitions.hh>
#include <orthrus/histogram.hh>
#include "../master_job.hh"
#include "../master_task.hh"
#include "../connslave.hh"
#include "../connclient.hh"


// Available scheduling: {FCFS, EMKDE}
#define EMKDE // scheduler

using namespace std;

vector<connslave*> slaves;
vector<connclient*> clients;

vector<master_job*> jobs;

histogram* thehistogram;

int serverfd;
//int cacheserverfd;
int ipcfd; // fd of cacheserver
int port = -1;
int dhtport = -1;
int max_job = -1;
int jobidclock = 0; // job id starts 0
bool thread_continue;













vector<string> nodelist;

char read_buf[BUF_SIZE]; // read buffer for signal_listener thread
char write_buf[BUF_SIZE]; // write buffer for signal_listener thread

//DHTserver* dhtserver; // dht server object
//DHTclient* dhtclient; // dht client object

// --------------------------master protocol---------------------------------
// 1. whoareyou: send a message to identify the connected node
// 2. close: let the destination node close the connection from the master
// 3. ignored: let connected node know message from it was ignored
// 4. result: contains resulting messeage to client followed by 'result:'
// --------------------------------------------------------------------------
// TODO: make protocols to integer or enum

int main(int argc, char** argv)
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			conf>>token;
			max_job = atoi(token.c_str());
		}
		else if(token == "master_address")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else
		{
			cout<<"[master]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// verify initialization
	if(port == -1)
	{
		cout<<"[master]port should be specified in the setup.conf"<<endl;
		exit(1);
	}
	if(max_job == -1)
	{
		cout<<"[master]max_job should be specified in the setup.conf"<<endl;
		exit(1);
	}

	// read the node list information
	ifstream nodelistfile;
	string filepath = LIB_PATH;
	filepath.append("nodelist.conf");

	nodelistfile.open(filepath.c_str());
	nodelistfile>>token;

	while(!nodelistfile.eof())
	{
		nodelist.push_back(token);
		nodelistfile>>token;
	}

	for(int i = 0; (unsigned)i < nodelist.size(); i++)
	{
		slaves.push_back(new connslave(nodelist[i]));
	}

	// initialize the EM-KDE histogram
	thehistogram = new histogram(nodelist.size(), NUMBIN);

	open_server(port);
	if(serverfd < 0)
	{
		cout<<"[master]\033[0;31mOpenning server failed\033[0m"<<endl;
		return 1;
	}
	if(ipcfd < 0)
	{
		cout<<"[master]\033[0;31mOpenning server failed\033[0m"<<endl;
		return 1;
	}

	struct sockaddr_in connaddr;
	int addrlen = sizeof(connaddr);
	char* haddrp;

	int connectioncount = 0;

	int buffersize = 8388608; // 8 MB buffer

	while(1) // receives connection from slaves
	{
		int fd;
		fd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);
		if(fd < 0)
		{
			cout<<"[master]Accepting failed"<<endl;

			// sleep 0.0001 seconds. change this if necessary
			usleep(1000);
			continue;
		}
		else
		{
			// check if the accepted node is slave or client
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, "whoareyou");
			nbwrite(fd, write_buf);

			// this is a blocking read
			// so don't need to check the transfer completion
			nbread(fd, read_buf);

			if(strncmp(read_buf, "slave", 5) == 0) // slave connected
			{
				// get ip address of slave
				haddrp = inet_ntoa(connaddr.sin_addr);

				// set fd and max task of connect slave
				for(int i = 0; (unsigned)i < slaves.size(); i++)
				{
					if(slaves[i]->get_address() == haddrp)
					{
						slaves[i]->setfd(fd);
						slaves[i]->setmaxmaptask(MAP_SLOT);
						slaves[i]->setmaxreducetask(REDUCE_SLOT);

						fcntl(fd, F_SETFL, O_NONBLOCK);
						setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
						setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));

						connectioncount++;
						break;
					}
				}

				printf("slave node connected from %s \n", haddrp);
			}
			else if(strncmp(read_buf, "client", 6) == 0) // client connected
			{
				clients.push_back(new connclient(fd));

				// set sockets to be non-blocking socket to avoid deadlock
				fcntl(clients.back()->getfd(), F_SETFL, O_NONBLOCK);

				// get ip address of client
				haddrp = inet_ntoa(connaddr.sin_addr);
				printf("a client node connected from %s \n", haddrp);
			}
			else if(strncmp(read_buf, "job", 3) == 0)
			{
				// TODO: deal with the case that a job joined the
				// server before all slave connected
			}
			else // unknown connection
			{
				// TODO: deal with this case
				cout<<"[master]Unknown connection"<<endl;
			}

			// break if all slaves are connected
			if((unsigned)connectioncount == nodelist.size())
			{
				cout<<"[master]\033[0;32mAll slave nodes are connected successfully\033[0m"<<endl;

				break;
			}
			else if(slaves.size() > nodelist.size())
			{
				cout<<"[master]Number of slave connection exceeded allowed limits"<<endl;
				cout<<"[master]\tDebugging needed on this problem"<<endl;
			}
			// sleeps for 0.0001 seconds. change this if necessary
			// usleep(100);
		}
	}

	struct sockaddr_un serveraddr;

	// SOCK_STREAM -> tcp
	ipcfd = socket(AF_UNIX, SOCK_STREAM, 0);
	if(ipcfd < 0)
	{
		cout<<"[master]Openning unix socket error"<<endl;
		exit(1);
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sun_family = AF_UNIX;
	strcpy(serveraddr.sun_path, IPC_PATH);

	while(connect(ipcfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		usleep(1000);
	}

	// set socket to be nonblocking
	fcntl(ipcfd, F_SETFL, O_NONBLOCK);
	setsockopt(ipcfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(ipcfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));

	//dhtclient = new DHTclient(RAVENLEADER, dhtport);

	// set sockets to be non-blocking socket to avoid deadlock
	fcntl(serverfd, F_SETFL, O_NONBLOCK);
	for(int i=0;(unsigned)i<slaves.size();i++)
		fcntl(slaves[i]->getfd(), F_SETFL, O_NONBLOCK);

	// create listener thread and run
	thread_continue = true;
	pthread_t listener_thread;
	pthread_create(&listener_thread, NULL, signal_listener, (void*)&serverfd);

	// sleeping loop which prevents process termination
	while(thread_continue)
		sleep(1);
	//dhtserver->close();

	return 0;
}

void open_server(int port)
{
	struct sockaddr_in serveraddr;

	// socket open
	serverfd = socket(AF_INET, SOCK_STREAM, 0);
	if(serverfd < 0)
		cout<<"[master]Socket opening failed"<<endl;

	// bind
	int valid = 1;
	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	setsockopt(serverfd, SOL_SOCKET, SO_REUSEADDR, &valid, sizeof(valid));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons((unsigned short) port);
	if(bind(serverfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		cout<<"[master]\033[0;31mBinding failed\033[0m"<<endl;
		exit(1);
	}

	// listen
	if(listen(serverfd, BACKLOG) < 0)
	{
		cout<<"[master]Listening failed"<<endl;
		exit(1);
	}
}

void* signal_listener(void* args)
{
	int serverfd = *((int*)args);
	int readbytes = 0;
	int tmpfd = -1; // store fd of new connected node temporarily
	char* haddrp;
	struct sockaddr_in connaddr;
	int addrlen = sizeof(connaddr);
	int elapsed = 0; // time elapsed im msec

	struct timeval time_start;
	struct timeval time_end;

	gettimeofday(&time_start, NULL);
	gettimeofday(&time_end, NULL);

	// listen signals from nodes and listen to node connection
	while(1)
	{
		// check client (or job) connection
		tmpfd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);
		if(tmpfd >= 0)
		{
			// send "whoareyou" message to connected node
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, "whoareyou");
			nbwrite(tmpfd, write_buf);

			memset(read_buf, 0, BUF_SIZE);

			// blocking read to check identification of connected node
			readbytes = nbread(tmpfd, read_buf);
			if(readbytes == 0)
			{
				cout<<"[master]Connection closed from client before getting request"<<endl;

				close(tmpfd);
				tmpfd = -1;
				continue;
			}

			fcntl(tmpfd, F_SETFL, O_NONBLOCK); // set socket to be non-blocking socket to avoid deadlock

			if(strncmp(read_buf, "client", 6) == 0) // if connected node is a client
			{
				// get ip address of client
				haddrp = inet_ntoa(connaddr.sin_addr);
				printf("[master]Client node connected from %s \n", haddrp);

				clients.push_back(new connclient(tmpfd));
			}
			else if(strncmp(read_buf, "slave", 5) == 0)
			{
				cout<<"[master]Unexpected connection from slave: "<<endl;
				cout<<"[master]Closing connection to the slave..."<<endl;

				// check this code
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "close");
				nbwrite(tmpfd, write_buf);
				close(tmpfd);
			}
			else if(strncmp(read_buf, "job", 3) == 0) // if connected node is a job
			{
				// limit the maximum available job connection
				if(jobs.size() == (unsigned)max_job)
				{
					cout<<"[master]Cannot accept any more job request due to maximum job connection limit"<<endl;
					cout<<"[master]\tClosing connection from the job..."<<endl;
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "nospace");
					nbwrite(tmpfd, write_buf);
					close(tmpfd);
					break;
				}

				// send the job id to the job
				stringstream jobidss;
				jobidss<<"jobid ";
				jobidss<<jobidclock;
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, jobidss.str().c_str());
				nbwrite(tmpfd, write_buf);

				cout<<"[master]Job "<<jobidclock<<" arrived"<<endl;
				jobs.push_back(new master_job(jobidclock, tmpfd));
				jobidclock++;
			}
			else
			{
				cout<<"[master]Unidentified connected node: "<<endl;
				cout<<"[master]Closing connection to the node..."<<endl;
				close(tmpfd);
			}
		}

		// listen to slaves
		for(int i=0; (unsigned)i<slaves.size(); i++)
		{
			readbytes = nbread(slaves[i]->getfd(), read_buf);
			if(readbytes == 0) // connection closed from slave
			{
				cout<<"[master]Connection from a slave closed"<<endl;
				delete slaves[i];
				slaves.erase(slaves.begin()+i);
				i--;
				continue;
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else // signal from the slave
			{
				// remove below "key" part
				// remove below "key" part
				// remove below "key" part
				/*
				if(strncmp(read_buf, "key", 3) == 0) // key signal arrived
				{
					char* token;
					master_job* thejob;
					token = strtok(read_buf, " "); // token <- "key"
					token = strtok(NULL, "\n"); // token <- job id
					
					thejob = find_jobfromid(atoi(token));

					token = strtok(NULL, "\n"); // token <- key

					while(token != NULL)
					{
						thejob->add_key(token); // token 
						token = strtok(NULL, "\n");
					}
				}
				*/
				if(strncmp(read_buf, "peerids", 7) == 0)
				{
					char* token;

					master_job* thejob;

					token = strtok(read_buf, " "); // token <- "peerids"
					token = strtok(NULL, " "); // token <- jobid

					thejob = find_jobfromid(atoi(token));

					// token first ids
					token = strtok(NULL, " ");

					while(token != NULL)
					{
						thejob->peerids.insert(atoi(token));
						token = strtok(NULL, " "); // good
					}
				}
				else if(strncmp(read_buf, "taskcomplete", 12) == 0) // "taskcomplete" signal arrived
				{
					char* token;
					int ajobid, ataskid;
					master_job* thejob;
					master_task* thetask;

					token = strtok(read_buf, " "); // token <- "taskcomplete"
					token = strtok(NULL, " "); // token <- "jobid"
					token = strtok(NULL, " "); // token <- job id
					ajobid = atoi(token);

					token = strtok(NULL, " "); // token <- "taskid"
					token = strtok(NULL, " "); // token <- task id
					ataskid = atoi(token);

					thejob = find_jobfromid(ajobid);
					thetask = thejob->find_taskfromid(ataskid);
					thejob->finish_task(thetask, slaves[i]);

					cout<<"[master]A task completed(jobid: "<<ajobid<<", "<<thejob->get_numcompleted_tasks();
					cout<<"/"<<thejob->get_numtasks()<<")"<<endl;
				}
				else
				{
					cout<<"[master]Undefined message from slave node: "<<read_buf<<endl;
					cout<<"[master]Undefined message size:"<<readbytes<<endl;
				}
			}
		}

		// listen to clients
		for(int i=0; (unsigned)i<clients.size(); i++)
		{
			readbytes = nbread(clients[i]->getfd(), read_buf);
			if(readbytes == 0) // connection closed from client
			{
				cout<<"[master]Connection from a client closed"<<endl;
				delete clients[i];
				clients.erase(clients.begin()+i);
				i--;
				continue;
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else // signal from the client
			{
				cout<<"[master]Message accepted from client: "<<read_buf<<endl;
				if(strncmp(read_buf, "stop", 4) == 0) // "stop" signal arrived
				{
					int currfd = clients[i]->getfd(); // store the current client's fd

					// stop all slave
					for(int j = 0; (unsigned)j < slaves.size(); j++)
					{
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "close");
						nbwrite(slaves[j]->getfd(), write_buf);

						// blocking read from slave
						fcntl(slaves[j]->getfd(), F_SETFL, fcntl(slaves[j]->getfd(), F_GETFL) & ~O_NONBLOCK);
						readbytes = nbread(slaves[j]->getfd(), read_buf);
						if(readbytes == 0) // closing slave succeeded
						{
							delete slaves[j];
							slaves.erase(slaves.begin()+j);
							j--;
						}
						else // message arrived before closed
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, "ignored");
							nbwrite(slaves[j]->getfd(), write_buf);
							j--;
							continue;
						}
						cout<<"[master]Connection from a slave closed"<<endl;
					}

					cout<<"[master]All slaves closed"<<endl;

					// stop all client except the one requested stop
					for(int j = 0; (unsigned)j < clients.size(); j++)
					{
						if(currfd == clients[j]->getfd()) // except the client who requested the stop
							continue;

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "close");
						nbwrite(clients[j]->getfd(), write_buf);

						// blocking read from client
						fcntl(clients[j]->getfd(), F_SETFL, fcntl(clients[j]->getfd(), F_GETFL) & ~O_NONBLOCK);
						readbytes = nbread(clients[j]->getfd(), read_buf);
						if(readbytes == 0) // closing client succeeded
						{
							delete clients[j];
							clients.erase(clients.begin()+j);
							j--;
						}
						else // message arrived before closed
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, "ignored");
							nbwrite(clients[j]->getfd(), write_buf);
							j--;
							continue;
						}
						cout<<"[master]Connection from a client closed"<<endl;
					}
					cout<<"[master]All clients closed"<<endl;

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "result: stopping successful");
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numslave", 8) == 0) // "numslave" signal arrived
				{
					string ostring = "result: number of slave nodes = ";
					stringstream ss;
					ss<<slaves.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numclient", 9) == 0) // "numclient" signal arrived
				{
					string ostring = "result: number of client nodes = ";
					stringstream ss;
					ss<<clients.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numjob", 6) == 0) // "numjob" signal arrived
				{
					string ostring = "result: number of running jobs = ";
					stringstream ss;
					ss<<jobs.size();
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else if(strncmp(read_buf, "numtask", 7) == 0) // "numtask" signal arrived
				{
					string ostring = "result: number of running tasks = ";
					stringstream ss;
					int numtasks = 0;
					for(int j=0;(unsigned)j<jobs.size();j++)
					{
						numtasks += jobs[j]->get_numrunning_tasks();
					}
					ss<<numtasks;
					ostring.append(ss.str());
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, ostring.c_str());
					nbwrite(clients[i]->getfd(), write_buf);
				}
				else // undefined signal
				{
					cout<<"[master]Undefined signal from client: "<<read_buf<<endl;
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "result: error. the request is unknown");
					nbwrite(clients[i]->getfd(), write_buf);
				}
			}
		}

		// check messages from jobs
		for(int i=0; (unsigned)i<jobs.size(); i++)
		{
			readbytes = nbread(jobs[i]->getjobfd(), read_buf);
			if(readbytes == 0) // connection to the job closed. maybe process terminated
			{
				delete jobs[i];
				jobs.erase(jobs.begin()+i);
				i--;
				cout<<"[master]Job terminated abnormally"<<endl;
				continue;
			}
			else if(readbytes < 0)
			{
				// do nothing
			}
			else // signal from the job
			{
				if(strncmp(read_buf, "complete", 8) == 0) // "succompletion" signal arrived
				{
					cout<<"[master]Job "<<jobs[i]->getjobid()<<" successfully completed"<<endl;

					// clear up the completed job
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "terminate");
					nbwrite(jobs[i]->getjobfd(), write_buf);

					// delete the job from the vector jobs
					delete jobs[i];
					jobs.erase(jobs.begin()+i);
					i--;
				}
				else if(strncmp(read_buf, "jobconf", 7) == 0) // "jobconf" message arrived
				{
					char* token;
					token = strtok(read_buf, " "); // token -> jobconf
					token = strtok(NULL, " "); // token -> number of inputpaths

					// parse all configure
					while(token != NULL)
					{
						if(strncmp(token, "argcount", 8) == 0)
						{
							// NOTE: there should be at least 1 arguments(program path name)
							token = strtok(NULL, " "); // token <- argument count
							jobs[i]->setargcount(atoi(token));

							// process next configure
							token = strtok(NULL, " "); // token -> argvalues

							// check the protocol
							if(strncmp(token, "argvalues", 9) != 0) // if the token is not 'argvalues'
								cout<<"Debugging: the 'jobconf' protocol conflicts."<<endl;

							char** arguments = new char*[jobs[i]->getargcount()];
							for(int j=0;j<jobs[i]->getargcount();j++)
							{
								token = strtok(NULL, " ");
								arguments[j] = new char[strlen(token)+1];
								strcpy(arguments[j], token);
							}
							jobs[i]->setargvalues(arguments);
						}
						/*
						else if(strncmp(token, "inputpath", 9) == 0)
						{
							int numpath;
							string tmp;
							token = strtok(NULL, " "); // token -> number of input paths

							numpath = atoi(token);
							for(int j=0;j<numpath;j++)
							{
								tmp = strtok(NULL, " ");
								jobs[i]->add_inputpath(tmp);
							}
						}
						*/
						else if(strncmp(token, "nummap", 6) == 0)
						{
							int nummap;
							token = strtok(NULL, " "); // token <- number of maps
							nummap = atoi(token);

							jobs[i]->setnummap(nummap);
						}
						else if(strncmp(token, "numreduce", 9) == 0)
						{
							int numreduce;
							token = strtok(NULL, " "); // token <- number of reduces
							numreduce = atoi(token);

							jobs[i]->setnumreduce(numreduce);

							// numreduce is the last token of this message
							// read another message, which is inputpath message
							int numpath;
							int iter = 0;

							readbytes = -1;

							while(readbytes < 0)
								readbytes = nbread(jobs[i]->getjobfd(), read_buf);

							token = strtok(read_buf, " "); // token <- "inputpath"
							token = strtok(NULL, " "); // token <- number of input paths
							numpath = atoi(token);

							while(iter < numpath)
							{
								token = strtok(NULL, " "); // next input path or NULL pointer

								if(token == NULL) // a null pointer
								{
									readbytes = -1;

									while(readbytes < 0)
									{
										readbytes = nbread(jobs[i]->getjobfd(), read_buf);
									}

									token = strtok(read_buf, " "); // must be a valid token(input path)
									jobs[i]->add_inputpath(token);
								}
								else // a valid input path
								{
									jobs[i]->add_inputpath(token);
								}

								iter++;
							}
						}
						else
						{
							cout<<"[master]Unknown job configure message from job: "<<token<<endl;
						}

						// process next configure
						token = strtok(NULL, " ");
					}

					if(jobs[i]->getnummap() == 0)
						jobs[i]->setnummap(jobs[i]->get_numinputpaths());

					// create map tasks
					for(int j=0;j<jobs[i]->getnummap();j++)
					{
						jobs[i]->add_task(new master_task(jobs[i], MAP));
					}

					// map inputpaths to each map tasks
					int path_iteration = 0;
					while(path_iteration<jobs[i]->get_numinputpaths())
					{
						for(int j=0;j<jobs[i]->get_numtasks() && path_iteration<jobs[i]->get_numinputpaths();j++)
						{
							jobs[i]->get_task(j)->add_inputpath(jobs[i]->get_inputpath(path_iteration));
							path_iteration++;
						}
					}

					// set job stage as MAP_STAGE
					jobs[i]->set_stage(MAP_STAGE);
				}
				else // undefined signal
				{
					cout<<"[master]Undefined signal from job: "<<read_buf<<endl;
				}
			}

			// check if all task finished
			if(jobs[i]->get_numtasks() == jobs[i]->get_numcompleted_tasks())
			{
				if(jobs[i]->get_stage() == MAP_STAGE) // if map stage is finished
				{
					if(jobs[i]->status == TASK_FINISHED) // information of numblock is gathered
					{
						// send message to the job to inform that map phase is completed
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "mapcomplete");
						nbwrite(jobs[i]->getjobfd(), write_buf);

						// request to the cache the flush of each iwriter and information of numblock from each peer
						stringstream ss;
						string message;

						ss << "iwritefinish ";
						ss << jobs[i]->getjobid();

						// append peer ids to ss
						for(set<int>::iterator it = jobs[i]->peerids.begin(); it != jobs[i]->peerids.end(); it++)
						{
							ss << " ";
							ss << *it;
						}
						
						message = ss.str();

						// send the message to the cache server
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());
						nbwrite(ipcfd, write_buf);

						jobs[i]->status = REQUEST_SENT;
					}
					else if(jobs[i]->status == REQUEST_SENT)
					{
						// do nothing(just wait for the respond)
					}
					else // status == RESPOND_RECEIVED
					{
						// determine the number of reducers
						if(jobs[i]->getnumreduce() <= 0)
						{
							jobs[i]->setnumreduce(jobs[i]->peerids.size());
						}
						else if((unsigned)jobs[i]->getnumreduce() > jobs[i]->peerids.size())
						{
							// TODO: enable much more number of reducers
							jobs[i]->setnumreduce(jobs[i]->peerids.size());
						}


						// generate reduce tasks and feed each reducer dedicated peer with numblock information

						for(int j = 0; j < jobs[i]->getnumreduce(); j++)
						{
							master_task* newtask = new master_task(jobs[i], REDUCE);
							jobs[i]->add_task(newtask);
						}

						int index = 0;
						int iteration = 0;

						// while all peerids are given to reducers
						for(set<int>::iterator it = jobs[i]->peerids.begin(); it != jobs[i]->peerids.end(); it++)
						{
							jobs[i]->get_waitingtask(iteration)->numiblocks.push_back(jobs[i]->numiblocks[index]);
							jobs[i]->get_waitingtask(iteration)->peerids.push_back(*it);

							index++;
							iteration++;

							if(iteration >= jobs[i]->getnumreduce())
								iteration = 0;
						}

						jobs[i]->set_stage(REDUCE_STAGE);
					}
				}
				else if(jobs[i]->get_stage() == REDUCE_STAGE) // if reduce stage is finished
				{
					// send message to the job to complete the job
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "complete");
					nbwrite(jobs[i]->getjobfd(), write_buf);
					cout<<"[master]Job "<<jobs[i]->getjobid()<<" completed successfully"<<endl;

					jobs[i]->set_stage(COMPLETED_STAGE);
					// clear the job from the vector and finish
					delete jobs[i];
					jobs.erase(jobs.begin()+i);
					i--;

					continue;
				}
				else
				{
					// pass the case for INITIAL_STAGE and COMPLETED_STAGE
				}
			}
		}

		// receive message from cache server
		readbytes = nbread(ipcfd, read_buf);

		if(readbytes > 0)
		{
			if(strncmp(read_buf, "numblocks", 9) == 0)
			{
				char* token;
				int jobid;
				token = strtok(read_buf, " "); // token: "numblocks"
				token = strtok(NULL, " "); // token: jobid
				jobid = atoi(token);
				token = strtok(NULL, " "); // first number of block

				for(int i = 0; jobs.size(); i++)
				{
					if(jobs[i]->getjobid() == jobid)
					{
						while(token != NULL)
						{
							jobs[i]->numiblocks.push_back(atoi(token));

							token = strtok(NULL, " ");
						}


						jobs[i]->status = RESPOND_RECEIVED;
						break;
					}
				}
			}
		}
		else if(readbytes == 0)
		{
			cout<<"[master]Connection to cache server abnormally closed"<<endl;
			usleep(100000);
		}



		// process and schedule jobs and tasks

#ifdef FCFS
		// default scheduler: FCFS-like scheduler
		for(int i=0; (unsigned)i<jobs.size(); i++)
		{
			for(int j=0;(unsigned)j<slaves.size();j++)
			{
				while((slaves[j]->getnumrunningtasks() < slaves[j]->getmaxtask())
					&& (jobs[i]->get_lastwaitingtask() != NULL)) // schedule all the slot until none of the slot is avilable
				{
					master_task* thetask = jobs[i]->get_lastwaitingtask();

					// write to the slave the task information
					stringstream ss;
					ss << "tasksubmit ";
					ss << jobs[i]->getjobid();
					ss << " ";
					ss << thetask->gettaskid();
					ss << " ";
					if(thetask->get_taskrole() == MAP)
						ss << "MAP";
					else if(thetask->get_taskrole() == REDUCE)
						ss << "REDUCE";
else
cout<<"[master]Debugging: the role of the task not defined in the initialization step";


					ss << " ";
					ss << thetask->get_job()->getargcount();

					// NOTE: there should be at leat 1 arguments(program path name)
					ss << " ";

					for(int k=0;k<thetask->get_job()->getargcount();k++)
					{
						ss<<" ";
						ss<<thetask->get_job()->getargvalue(k);
					}

					string message = ss.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(slaves[j]->getfd(), write_buf);

					// prepare inputpath message
					int iter = 0;
					message = "inputpath";

					while(iter < thetask->get_numinputpaths())
					{
						if(message.length() + thetask->get_inputpath(iter).length() + 1 <= BUF_SIZE)
						{
							message.append(" ");
							message.append(thetask->get_inputpath(iter));
						}
						else
						{
							if(thetask->get_inputpath(iter).length() + 10 > BUF_SIZE)
								cout<<"[master]The length of inputpath exceeded the limit"<<endl;

							// send message to slave
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());
							nbwrite(slaves[j]->getfd(), write_buf);

							message = "inputpath ";
							message.append(thetask->get_inputpath(iter));
						}
						iter++;
					}

					// send remaining paths
					if(message.length() > strlen("inputpath "))
					{
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());
						nbwrite(slaves[j]->getfd(), write_buf);
					}

					// notify end of inputpaths
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "Einput");
					nbwrite(slaves[j]->getfd(), write_buf);

					// forward waiting task to slave slot
					jobs[i]->schedule_task(thetask, slaves[j]);
					// sleeps for 0.0001 seconds. change this if necessary
					// usleep(100000);
				}
			}
		}
#endif

#ifdef EMKDE
		// EMKDE scheduler: schedule the task where the input is located
		for(int i = 0; (unsigned)i < jobs.size(); i++)
		{
			int nodeindex = -1;
			if(jobs[i]->get_lastwaitingtask() == NULL)
				continue;

			for(int k = 0; k < jobs[i]->get_numwaiting_tasks(); k++)
			{
				master_task* thetask = jobs[i]->get_waitingtask(k);
				if(thetask->get_taskrole() == MAP)
				{
					string thepath = thetask->get_inputpath(0); // first input as a representative input
					string address; 
					stringstream tmpss;

					memset(write_buf, 0, HASHLENGTH);
					strcpy(write_buf, thepath.c_str());

					// determine the hash value and count the query
					uint32_t hashvalue = h(write_buf, HASHLENGTH);
					nodeindex = thehistogram->get_index(hashvalue);

					/*
					if(slaves[nodeindex]->getnumrunningtasks() >= slaves[nodeindex]->getmaxmaptask()) // choose alternative slot
						continue;
					*/
					if(slaves[nodeindex]->getnumrunningtasks() >= slaves[nodeindex]->getmaxmaptask()) // choose alternative slot
					{
						nodeindex = -1;
						for(int h = 0; (unsigned)h < slaves.size(); h++)
						{
							if(slaves[h]->getnumrunningtasks() >= slaves[h]->getmaxmaptask())
							{
								continue;
							}
							else
							{
								nodeindex = h;
								break;
							}
						}
						if(nodeindex == -1)
							continue;
					}

					thehistogram->count_query(hashvalue);

					// write to the slave the task information
					stringstream ss;
					ss << "tasksubmit ";
					ss << jobs[i]->getjobid();
					ss << " ";
					ss << thetask->gettaskid();
					ss << " ";
					ss << "MAP";
					ss << " ";
					ss << thetask->get_job()->getargcount();

					for(int j = 0; j < thetask->get_job()->getargcount(); j++)
					{
						ss << " ";
						ss << thetask->get_job()->getargvalue(j);
					}

					string message = ss.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(slaves[nodeindex]->getfd(), write_buf);

					// prepare inputpath message
					int iter = 0;
					message = "inputpath";

					while(iter < thetask->get_numinputpaths())
					{
						if(message.length() + thetask->get_inputpath(iter).length() + 1 < BUF_SIZE)
						{
							message.append(" ");
							message.append(thetask->get_inputpath(iter));
						}
						else
						{
							if(thetask->get_inputpath(iter).length() + 10 > BUF_SIZE)
								cout<<"[master]The length of inputpath exceeded the limit"<<endl;

							// send message to slave
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());
							nbwrite(slaves[nodeindex]->getfd(), write_buf);

							message = "inputpath ";
							message.append(thetask->get_inputpath(iter));
						}
						iter++;
					}

					// send remaining paths
					if(message.length() > strlen("inputpath "))
					{
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());
						nbwrite(slaves[nodeindex]->getfd(), write_buf);
					}

					// notify end of inputpaths
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "Einput");
					nbwrite(slaves[nodeindex]->getfd(), write_buf);

					// forward waiting task to slave slot
					jobs[i]->schedule_task(thetask, slaves[nodeindex]);
				}
				else // reduce
				{
					nodeindex = thetask->peerids[0];

					if(slaves[nodeindex]->getnumrunningtasks() >= slaves[nodeindex]->getmaxreducetask()) // no available task slot
						continue;

					// write to the slave the task information
					stringstream ss;
					ss << "tasksubmit ";
					ss << jobs[i]->getjobid();
					ss << " ";
					ss << thetask->gettaskid();
					ss << " ";
					ss << "REDUCE";
					ss << " ";
					ss << thetask->get_job()->getargcount();

					for(int j = 0; j < thetask->get_job()->getargcount(); j++)
					{
						ss << " ";
						ss << thetask->get_job()->getargvalue(j);
					}

					string message = ss.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(slaves[nodeindex]->getfd(), write_buf);

					message = "inputpath";

					for(int j = 0; (unsigned)j < thetask->peerids.size(); j++) // don't need to worry about BUF_SIZE overflow in reducer case
					{
						stringstream ss;

						ss << " ";
						ss << thetask->peerids[j];
						ss << " ";
						ss << thetask->numiblocks[j];
						message.append(ss.str());
					}

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(slaves[nodeindex]->getfd(), write_buf);
					// forward waiting task to slave slot
					jobs[i]->schedule_task(thetask, slaves[nodeindex]);
				}

				continue;
			}
		}

		gettimeofday(&time_end, NULL);
		elapsed += 1000*(time_end.tv_sec - time_start.tv_sec);
		elapsed += (time_end.tv_usec - time_start.tv_usec)/1000;

		if(elapsed > UPDATEINTERVAL) // UPDATE INTERVAL from EM-KDE
		{
			// EM-KDE: calculate the new boundary according to the query counts
			thehistogram->updateboundary();

			// EM-KDE: send the boundariees of each histogram to cache server
			string message;
			stringstream ss;
			ss << "boundaries";
			for(int i = 0; i < thehistogram->get_numserver(); i++) // total numserver - 1 boundary
			{
				ss << " ";
				ss << thehistogram->get_boundary(i);
			}

			message = ss.str();

			// send the boundary message to the cache server
			memset(write_buf, 0, BUF_SIZE);
			strcpy(write_buf, message.c_str());
			nbwrite(ipcfd, write_buf);

			gettimeofday(&time_start, NULL);
			elapsed = 0;
		}
#endif

		// break if all slaves and clients are closed
		if(slaves.size() == 0 && clients.size() == 0)
			break;

		// sleeps for 1 msec. change this if necessary
		// usleep(1000);
	}

	// close master socket
	close(serverfd);
	cout<<"[master]Master server closed"<<endl;

	cout<<"[master]Exiting master..."<<endl;

	thread_continue = false;
	return NULL;
}

master_job* find_jobfromid(int id)
{
	for(int i=0;(unsigned)i<jobs.size();i++)
	{
		if(jobs[i]->getjobid() == id)
			return jobs[i];
	}
	return NULL;
}
#ifndef __MASTER__
#define __MASTER__

#include <iostream>
#include <string>
#include "../master_job.hh"


void open_server(int port); // function which receive connections from slaves
void *accept_client(void *args); // thread function used to receive connections from clients
void *signal_listener(void *args); // thread function used to communicate with connected nodes
void run_job(char* buf_content, master_job* thejob); // run submitted job
master_job* find_jobfromid(int id); // find and return job pointer fro its jobid

#endif
#ifndef __CONNCLIENT__
#define __CONNCLIENT__

#include <iostream>

class connclient // connection to the client
{
private:
	int fd;

public:
	connclient(int fd);
	~connclient();
	int getfd();
	void setfd(int num);

};

connclient::connclient(int fd)
{
	this->fd = fd;
}

connclient::~connclient()
{
	close(fd);
}

int connclient::getfd()
{
	return this->fd;
}

void connclient::setfd(int num)
{
	this->fd = num;
}

#endif
#ifndef __CONNSLAVE__
#define __CONNSLAVE__

#include <iostream>
#include <mapreduce/definitions.hh>
#include "master_task.hh"

class connslave // connection to the slave
{
private:
	int fd;
	int maxmaptask;
	int maxreducetask;
	string address;
	vector<master_task*> running_tasks;

public:
	connslave(int fd);
	connslave(int maxtask, int fd);
	connslave(int maxtask, int fd, string anaddress);
	connslave(string anaddress);
	~connslave();
	int getfd();
	int getmaxmaptask();
	int getmaxreducetask();
	void setmaxmaptask(int num);
	void setmaxreducetask(int num);
	int getnumrunningtasks();
	master_task* getrunningtask(int index);
	void add_runningtask(master_task* atask);
	void remove_runningtask(master_task* atask);
	void set_address(string anaddress);
	void setfd(int number);
	string get_address();
};

connslave::connslave(int fd)
{
	this->maxmaptask = 0;
	this->maxreducetask = 0;
	this->fd = fd;
}

connslave::connslave(string anaddress)
{
	this->maxmaptask = 0;
	this->maxreducetask = 0;
	this->address = anaddress;
}

connslave::connslave(int maxtask, int fd)
{
	this->maxmaptask = maxtask;
	this->maxreducetask = maxtask;
	this->fd = fd;
}

connslave::connslave(int maxtask, int fd, string anaddress)
{
	this->maxmaptask = maxtask;
	this->maxreducetask = maxtask;
	this->fd = fd;
	this->address = anaddress;
}

connslave::~connslave()
{
	close(fd);
}

int connslave::getfd()
{
	return this->fd;
}

void connslave::setfd(int number)
{
	this->fd = number;
}

int connslave::getmaxmaptask()
{
	return this->maxmaptask;
}

int connslave::getmaxreducetask()
{
	return this->maxreducetask;
}

int connslave::getnumrunningtasks()
{
	return this->running_tasks.size();
}

void connslave::setmaxmaptask(int num)
{
	this->maxmaptask = num;
}

void connslave::setmaxreducetask(int num)
{
	this->maxreducetask = num;
}

master_task* connslave::getrunningtask(int index)
{
	if((unsigned)index>=this->running_tasks.size())
	{
		cout<<"Index out of bound in the connslave::getrunningtask() function."<<endl;
		return NULL;
	}
	else
		return this->running_tasks[index];
}

void connslave::add_runningtask(master_task* atask)
{
	if(atask != NULL)
		running_tasks.push_back(atask);
	else
		cout<<"A NULL task is assigned to the running task vector in the connslave::add_runningtask() function."<<endl;
}

void connslave::remove_runningtask(master_task* atask)
{
	for(int i=0;(unsigned)i<running_tasks.size();i++)
	{
		if(running_tasks[i] == atask)
		{
			running_tasks.erase(running_tasks.begin()+i);
			break;
		}
	}
}

void connslave::set_address(string anaddress)
{
	this->address = anaddress;
}

string connslave::get_address()
{
	return this->address;
}

#endif
#ifndef __MASTER_JOB__
#define __MASTER_JOB__

#include <iostream>
#include <mapreduce/definitions.hh>
#include <string>
#include <vector>
#include <set>
#include "master_task.hh"
#include "connslave.hh"

using namespace std;

enum mapstatus
{
	TASK_FINISHED,
	REQUEST_SENT,
	RESPOND_RECEIVED
};
class master_job
{
private:
	int jobid;
	int jobfd;
	int argcount;
	int nummap;
	int numreduce;
	char** argvalues; // contains program name
	job_stage stage;
	vector<string> inputpaths;
	vector<master_task*> tasks;
	vector<master_task*> waiting_tasks;
	vector<master_task*> running_tasks;
	vector<master_task*> completed_tasks;

public:
	enum mapstatus status;
	set<int> peerids;
	vector<int> numiblocks; // the order is matched with peerids(set)




	int scheduled;







	master_job();
	master_job(int id, int fd);
	~master_job();

	void setjobid(int num);
	int getjobid();
	void setjobfd(int num);
	int getjobfd();
	void setnummap(int num);
	int getnummap();
	void setnumreduce(int num);
	int getnumreduce();
	void setargcount(int num);
	int getargcount();
	void setargvalues(char** values);
	char** getargvalues();
	string getargvalue(int index);
	void add_inputpath(string path);
	string get_inputpath(int index);
	int get_numinputpaths();
	void add_task(master_task* atask);
	master_task* get_task(int index);
	master_task* get_waitingtask(int index);
	int get_numtasks();
	int get_numwaiting_tasks();
	int get_numrunning_tasks();
	int get_numcompleted_tasks();
	job_stage get_stage();
	void set_stage(job_stage astage);
	master_task* get_lastwaitingtask();
	void schedule_task(master_task* atask, connslave* aslave);
	void finish_task(master_task* atask, connslave* aslave);
	master_task* find_taskfromid(int id);
	
};

master_job::master_job()
{
	this->jobid = -1;
	this->jobfd = -1;
	this->nummap = 0;
	this->numreduce = 0;
	this->argcount = -1;
	this->argvalues = NULL;
	this->stage = INITIAL_STAGE;
	status = TASK_FINISHED;
}

master_job::master_job(int id, int fd)
{













	scheduled = 0;










	this->jobid = id;
	this->jobfd = fd;
	this->nummap = 0;
	this->numreduce = 0;
	this->argcount = -1;
	this->argvalues = NULL;
	this->stage = INITIAL_STAGE;
	status = TASK_FINISHED;
}

master_job::~master_job()
{
	if(argvalues != NULL)
	{
		for(int i=0;i<this->argcount;i++)
		{
			delete[] argvalues[i];
		}
	}
	delete[] argvalues;

	// delete all the tasks of the job
	for(int i=0;(unsigned)i<tasks.size();i++)
		delete tasks[i];

	close(jobfd);
}

void master_job::setjobid(int num)
{
	this->jobid = num;
}

int master_job::getjobid()
{
	return this->jobid;
}

void master_job::setjobfd(int num)
{
	this->jobfd = num;
}

int master_job::getjobfd()
{
	return this->jobfd;
}

void master_job::setargcount(int num)
{
	this->argcount = num;
}

int master_job::getargcount()
{
	return this->argcount;
}

void master_job::setargvalues(char** values)
{
	this->argvalues = values;
}

char** master_job::getargvalues()
{
	return this->argvalues;
}

void master_job::add_inputpath(string path)
{
	this->inputpaths.push_back(path);
}

string master_job::get_inputpath(int index)
{
	if((unsigned) index < inputpaths.size())
	{
		return this->inputpaths[index];
	}
	else
	{
		cout<<"index out of bound in master_job::get_inputpath()"<<endl;
		return "";
	}
}

int master_job::get_numinputpaths()
{
	return this->inputpaths.size();
}

void master_job::add_task(master_task* atask)
{
	// set the task id of the input task
	atask->settaskid(tasks.size());
	atask->set_job(this);
	this->tasks.push_back(atask);
	this->waiting_tasks.push_back(atask);
}

master_task* master_job::get_task(int index)
{
	if((unsigned)index>=tasks.size())
	{
		cout<<"Debugging: index out of bound in the matser_job::get_task() function"<<endl;
		return NULL;
	}
	else
	{
		return this->tasks[index];
	}
}

master_task* master_job::get_waitingtask(int index)
{
	if((unsigned)index >= waiting_tasks.size())
	{
		cout<<"Debugging: index out of bound in the matser_job::get_waitingtask() function"<<endl;
		cout<<"index: "<<index<<", waiting_tasks.size(): "<<waiting_tasks.size()<<endl;
		return NULL;
	}
	else
	{
		return waiting_tasks[index];
	}
}

int master_job::get_numtasks()
{
	return this->tasks.size();
}

master_task* master_job::get_lastwaitingtask()
{
	if(waiting_tasks.size() == 0)
		return NULL;
	else
		return waiting_tasks.back();
}

void master_job::schedule_task(master_task* atask, connslave* aslave)
{
	for(int i=0;(unsigned)i<waiting_tasks.size();i++)
	{
		if(waiting_tasks[i] == atask)
		{
			running_tasks.push_back(atask);
			aslave->add_runningtask(atask);
			atask->set_status(RUNNING);
			waiting_tasks.erase(waiting_tasks.begin()+i);
			return;
		}
	}
}

void master_job::finish_task(master_task* atask, connslave* aslave)
{
	for(int i=0;(unsigned)i<running_tasks.size();i++)
	{
		if(running_tasks[i] == atask)
		{
			completed_tasks.push_back(atask);
			aslave->remove_runningtask(atask);
			atask->set_status(COMPLETED);
			running_tasks.erase(running_tasks.begin()+i);
			return;
		}
	}
}

int master_job::get_numwaiting_tasks()
{
	return this->waiting_tasks.size();
}

int master_job::get_numrunning_tasks()
{
	return this->running_tasks.size();
}

int master_job::get_numcompleted_tasks()
{
	return this->completed_tasks.size();
}

master_task* master_job::find_taskfromid(int id)
{
	for(int i=0;(unsigned)i<tasks.size();i++)
	{
		if(tasks[i]->gettaskid() == id)
			return tasks[i];
	}
cout<<"There is no such a task with the id in master_job::find_taskfromid() function."<<endl;
	return NULL;
}

void master_job::setnummap(int num)
{
	this->nummap = num;
}

int master_job::getnummap()
{
	return this->nummap;
}

void master_job::setnumreduce(int num)
{
	this->numreduce = num;
}

int master_job::getnumreduce()
{
	return this->numreduce;
}

string master_job::getargvalue(int index)
{
	if(index>=argcount)
	{
		cout<<"Debugging: index out of bound in the master_job::getargvalue() function.";
		return "";
	}
	else
	{
		return this->argvalues[index];
	}
}

job_stage master_job::get_stage()
{
	return this->stage;
}

void master_job::set_stage(job_stage astage)
{
	this->stage = astage;
}


// member functions of master_task class


master_task::master_task()
{
	this->taskid = -1;
	this->job = NULL;
	this->role = JOB; // this should be changed to MAP or REDUCE
	this->status = WAITING;
}

master_task::master_task(mr_role arole)
{
	this->taskid = -1;
	this->job = NULL;
	this->role = arole;
	this->status = WAITING;
}

master_task::master_task(master_job* ajob)
{
	this->taskid = -1;
	this->job = ajob;
	this->role = JOB; // this should be changed to MAP ro REDUCE
	this->status = WAITING;
}

master_task::master_task(master_job* ajob, mr_role arole)
{
	this->taskid = -1;
	this->job = ajob;
	this->role = arole;
	this->status = WAITING;
}

int master_task::gettaskid()
{
	return this->taskid;
}

void master_task::settaskid(int num)
{
	this->taskid = num;
}

void master_task::add_inputpath(string path)
{
	this->inputpaths.push_back(path);
}

mr_role master_task::get_taskrole()
{
	return this->role;
}

int master_task::get_numinputpaths()
{
	return this->inputpaths.size();
}

string master_task::get_inputpath(int index)
{
	if((unsigned)index < this->inputpaths.size())
		return this->inputpaths[index];
	else if(index < 0)
	{
		cout<<"Negative index in the master_task::get_inputpath() function."<<endl;
		return "";
	}
	else
	{
		cout<<"Index out of bound in the master_task::get_inputpath() function."<<endl;
		return "";
	}
}

void master_task::set_status(task_status astatus)
{
	this->status = astatus;
}

task_status master_task::get_status()
{
	return this->status;
}

void master_task::set_job(master_job* ajob)
{
	this->job = ajob;
}

master_job* master_task::get_job()
{
	return this->job;
}

void master_task::set_taskrole(mr_role arole)
{
	this->role = arole;
}

#endif
#ifndef __MASTER_TASK__
#define __MASTER_TASK__

#include <iostream>
#include <mapreduce/definitions.hh>

using namespace std;

class master_job;

class master_task
{
private:
	int taskid;
	master_job* job;
	mr_role role; // MAP or REDUCE
	task_status status;

	// FOR MAP
	vector<string> inputpaths;// a vector of inputpaths. inputpaths can be multiple

public:
	// FOR REDUCER
	vector<int> peerids; // list of peer ids in which the idata is located
	vector<int> numiblocks; // list of number of blocks for each peer

	master_task();	
	master_task(mr_role arole);
	master_task(master_job* ajob);
	master_task(master_job* ajob, mr_role arole);

	int gettaskid();
	void settaskid(int num);
	master_job* get_job();
	void set_job(master_job* ajob);
	mr_role get_taskrole();
	void set_taskrole(mr_role arole);
	int get_numinputpaths();
	string get_inputpath(int index);
	void add_inputpath(string path);
	void set_status(task_status astatus);
	task_status get_status();
};

#endif
#include <iostream>
#include <mapreduce/definitions.hh>
#include "mcc.hh"

using namespace std;

int main(int argc, char** argv)
{
	if(argc<2)
	{
		cout<<"Insufficient arguments: at least 1 argument needed"<<endl;
		cout<<"usage: mcc [source code] (options)"<<endl;
		cout<<"Exiting..."<<endl;
		return 1;
	}
	else
	{
		cout<<"Compiling the code..."<<endl;
		cout<<"\tRemember, your program cannot use the words 'MAP', 'REDUCE' as arguments of your program."<<endl;
		cout<<"\t(If using those words as arguments is inevitable, please avoid them to be the last argument.)"<<endl;
	}

	char** argvalue = new char*[argc+3];
	//argvalue[0] = "/usr/bin/g++";
	argvalue[0] = new char[strlen("/opt/centos/devtoolset-1.1/root/usr/bin/g++")+1];
	strcpy(argvalue[0], "/opt/centos/devtoolset-1.1/root/usr/bin/g++");

	string libpath = LIB_PATH;
	libpath.append("mapreduce/nfs/");

	for(int i=1;i<argc;i++)
	{
		argvalue[i] = new char[strlen(argv[i]+1)];
		strcpy(argvalue[i], argv[i]);
	}
	argvalue[argc] = new char[3];
	strcpy(argvalue[argc], "-I");

	argvalue[argc+1] = new char[strlen(libpath.c_str())+1];
	strcpy(argvalue[argc+1], libpath.c_str());

	argvalue[argc+2] = NULL;

	execv(argvalue[0], argvalue);
	return 0;
}
#ifndef __MCC__
#define __MCC__
#include <iostream>


#endif
#include <iostream>
#include <mapreduce/definitions.hh>
#include "mcc.hh"

using namespace std;

int main(int argc, char** argv)
{
	if(argc<2)
	{
		cout<<"Insufficient arguments: at least 1 argument needed"<<endl;
		cout<<"usage: mcc [source code] (options)"<<endl;
		cout<<"Exiting..."<<endl;
		return 1;
	}
	else
	{
		cout<<"Compiling the code..."<<endl;
		cout<<"\tRemember, your program cannot use the words 'MAP', 'REDUCE' as arguments of your program."<<endl;
		cout<<"\t(If using those words as arguments is inevitable, please avoid them to be the last argument.)"<<endl;
	}

	char** argvalue = new char*[argc+11];
	//argvalue[0] = "/usr/bin/g++";
	argvalue[0] = new char[strlen("/opt/centos/devtoolset-1.1/root/usr/bin/g++")+1];
	strcpy(argvalue[0], "/opt/centos/devtoolset-1.1/root/usr/bin/g++");

	string libpath = LIB_PATH;
	libpath.append("mapreduce/hdfs/");

	for(int i=1;i<argc;i++)
	{
		argvalue[i] = new char[strlen(argv[i]+1)];
		strcpy(argvalue[i], argv[i]);
	}
	argvalue[argc] = new char[3];
	strcpy(argvalue[argc], "-I");

	argvalue[argc+1] = new char[strlen(libpath.c_str())+1];
	strcpy(argvalue[argc+1], libpath.c_str());

	argvalue[argc+2] = new char[3];
	strcpy(argvalue[argc+2], "-I");

	argvalue[argc+3] = new char[strlen(HDFS_PATH)+1];
	strcpy(argvalue[argc+3], HDFS_PATH);

	argvalue[argc+4] = new char[3];
	strcpy(argvalue[argc+4], "-L");

	argvalue[argc+5] = new char[strlen(HDFS_LIB)+1];
	strcpy(argvalue[argc+5], HDFS_LIB);

	argvalue[argc+6] = new char[3];
	strcpy(argvalue[argc+6], "-L");

	argvalue[argc+7] = new char[strlen(JAVA_LIB)+1];
	strcpy(argvalue[argc+7], JAVA_LIB);

	argvalue[argc+8] = new char[strlen(HADOOP_FLAG)+1];
	strcpy(argvalue[argc+8], HADOOP_FLAG);

	argvalue[argc+9] = new char[strlen(JAVA_FLAG)+1];
	strcpy(argvalue[argc+9], JAVA_FLAG);

	argvalue[argc+10] = NULL;

	execv(argvalue[0], argvalue);
	return 0;
}
#ifndef __MCC__
#define __MCC__
#include <iostream>


#endif
#include <iostream>
#include <mapreduce/definitions.hh>
#include "mcc.hh"

using namespace std;

int main(int argc, char** argv)
{
	if(argc<2)
	{
		cout<<"Insufficient arguments: at least 1 argument needed"<<endl;
		cout<<"usage: mcc [source code] (options)"<<endl;
		cout<<"Exiting..."<<endl;
		return 1;
	}
	else
	{
		cout<<"Compiling the code..."<<endl;
		cout<<"\tRemember followings,"<<endl;
		cout<<"\t1. Your program cannot use the words 'MAP', 'REDUCE' as arguments of your program."<<endl;
		cout<<"\t (If using those words as arguments is inevitable, please avoid them to be the last argument.)"<<endl;
	}

	char** argvalue = new char*[argc+6];
	//argvalue[0] = "/usr/bin/g++";
	argvalue[0] = new char[strlen("/usr/bin/g++") + 1];
	memset(argvalue[0], 0, strlen("/usr/bin/g++") + 1);
	strcpy(argvalue[0], "/usr/bin/g++");

	string libpath = LIB_PATH;
	libpath.append("mapreduce/dht/");
	string hashpath = LIB_PATH;
	hashpath.append("common/hash.o");

	for(int i=1;i<argc;i++)
	{
		argvalue[i] = new char[strlen(argv[i] + 1)];
		memset(argvalue[i], 0, strlen(argv[i]) + 1);
		strcpy(argvalue[i], argv[i]);
	}
	argvalue[argc] = new char[3];
	memset(argvalue[argc], 0, strlen("-I") + 1);
	strcpy(argvalue[argc], "-I");

	argvalue[argc+1] = new char[libpath.length() + 1];
	memset(argvalue[argc+1], 0, strlen(libpath.c_str()) + 1);
	strcpy(argvalue[argc+1], libpath.c_str());

	argvalue[argc+2] = new char[3];
	memset(argvalue[argc+2], 0, strlen("-I") + 1);
	strcpy(argvalue[argc+2], "-I");

	argvalue[argc+3] = new char[strlen(LIB_PATH) + 1];
	memset(argvalue[argc+3], 0, strlen(LIB_PATH) + 1);
	strcpy(argvalue[argc+3], LIB_PATH);

	argvalue[argc+4] = new char[hashpath.length()+1];
	memset(argvalue[argc+4], 0, strlen(hashpath.c_str()) + 1);
	strcpy(argvalue[argc+4], hashpath.c_str());

	argvalue[argc+5] = NULL;

	execv(argvalue[0], argvalue);
	return 0;
}
#ifndef __MCC__
#define __MCC__
#include <iostream>


#endif
#include <iostream>
#include <errno.h>
#include <fstream>
#include <sstream>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <arpa/inet.h>
#include <assert.h>
#include <netdb.h>
#include <unistd.h>
#include <mapreduce/definitions.hh>
#include "slave.hh"
#include "slave_job.hh"
#include "slave_task.hh"

using namespace std;

char read_buf[BUF_SIZE];
char write_buf[BUF_SIZE];

int port = -1;
int dhtport = -1;
int masterfd = -1;
bool master_is_set = false;
char master_address[BUF_SIZE];
vector<slave_job*> running_jobs; // a vector of job, one or multiple tasks of which are running on this slave node
vector<slave_task*> running_tasks; // a vector of running tasks

int main(int argc, char** argv)
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "num_slave")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			conf>>token;
			strcpy(master_address, token.c_str());
			master_is_set = true;
		}
		else
		{
			cout<<"[slave]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// verify initialization
	if(port == -1)
	{
		cout<<"[slave]port should be specified in the setup.conf"<<endl;
		return 1;
	}
	if(master_is_set == false)
	{
		cout<<"[slave]master_address should be specified in the setup.conf"<<endl;
		return 1;
	}

	// connect to master
	masterfd = connect_to_server(master_address, port);
	if(masterfd<0)
	{
		cout<<"[slave]Connecting to master failed"<<endl;
		return 1;
	}

	// set master socket to be non-blocking socket to avoid deadlock
	fcntl(masterfd, F_SETFL, O_NONBLOCK);

	signal_listener();

	return 0;
}

int connect_to_server(char* host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent* hp;

	//SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd < 0)
	{
		cout<<"[slave]Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);

	if (hp == NULL)
		cout<<"[slave]Cannot find host by host name"<<endl;

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void signal_listener()
{
	// get signal from master, jobs and tasks
	int readbytes = 0;
	while(1)
	{
		// check signal arrived from master
		readbytes = nbread(masterfd, read_buf);
		if(readbytes == 0) //connection closed from master
		{
			cout<<"[slave]Connection from master is abnormally closed"<<endl;
			if(close(masterfd)<0)
				cout<<"[slave]Closing socket failed"<<endl;
			cout<<"[slave]Exiting slave..."<<endl;
			exit(0);
		}
		else if(readbytes < 0)
		{
			// do nothing
		}
		else // signal arrived from master
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "slave");
				nbwrite(masterfd, write_buf);
			}
			else if(strncmp(read_buf, "close", 5) == 0)
			{
				cout<<"[slave]Close request from master"<<endl;
				if(close(masterfd<0))
					cout<<"[slave]Close failed"<<endl;
				cout<<"[slave]Exiting slave..."<<endl;
				exit(0);
			}
			else if(strncmp(read_buf, "tasksubmit", 10) == 0)
			{
				// launch the forwarded task
				slave_job* thejob = NULL;
				slave_task* thetask = NULL;
				char* token;
				token = strtok(read_buf, " "); // token -> tasksubmit
				token = strtok(NULL, " "); // token -> jobid expected

				// parse task configure
				while(token != NULL)
				{
					if(strncmp(token, "jobid", 5) == 0)
					{
						int id;
						token = strtok(NULL, " ");
						id = atoi(token);

						thejob = find_jobfromid(id);

						if(thejob == NULL) // if task in this job already running in this slave
						{
							thejob = new slave_job(id);
							running_jobs.push_back(thejob);
						}
					}
					else if(strncmp(token, "taskid", 6) == 0)
					{
						int id;
						if(thejob == NULL)
						{
							cout<<"Debugging: the job is set to null in";
							cout<<"the slave side when a task is forwarded."<<endl;
							token = strtok(NULL, " ");
							continue;
						}
						token = strtok(NULL, " ");
						id = atoi(token);
						thetask = new slave_task(id); // the status is running by default

						// add to the running_tasks vector
						running_tasks.push_back(thetask);

						// add this task in 'thejob'
						thejob->add_task(thetask);
					}
					else if(strncmp(token, "role", 4) == 0)
					{
						if(thetask == NULL)
						{
							cout<<"Debugging: the task is set to null in ";
							cout<<"the slave side when a task is forwarded."<<endl;
							token = strtok(NULL, " ");
							continue;
						}
						token = strtok(NULL, " "); // "MAP" or "REDUCE"
						if(strncmp(token, "MAP", 3) == 0)
						{
							thetask->set_taskrole(MAP);
						}
						else if(strncmp(token, "REDUCE", 6) == 0)
						{
							thetask->set_taskrole(REDUCE);
						}
						else
						{
							cout<<"Debugging: the task role is undefined well."<<endl;
							thetask->set_taskrole(JOB);
						}
					}
					else if(strncmp(token, "inputpath", 9) == 0)
					{
						string tmp; // used for temporarily storing the paths
						int numpaths;
						token = strtok(NULL, " "); // token -> number of input paths
						numpaths = atoi(token);
						for(int i=0; i<numpaths; i++)
						{
							token = strtok(NULL, " ");
							tmp = token;
							thetask->add_inputpath(tmp);
						}
					}
					else if(strncmp(token, "argcount", 8) == 0)
					{
						// deal with argcount and argvalues together in this bracket
						// because both configure should be successive
						int count;
						token = strtok(NULL, " "); // token -> arguments count
						count = atoi(token);
						thetask->set_argcount(count);

						char** values = new char*[count];

						token = strtok(NULL, " "); // token -> argvalues

						// check the message protocol
						if(strncmp(token, "argvalues", 9) != 0)
						{
							cout<<"Debugging: the 'tasksubmit' protocol conflicts in the slave."<<endl;
							// process next configure
							token = strtok(NULL, " ");
							continue;
						}

						// parse all arguments
						for(int i=0;i<count;i++)
						{
							token = strtok(NULL, " ");
							values[i] = new char[strlen(token)+1];
							strcpy(values[i], token);
						}
						thetask->set_argvalues(values);
					}
					else
					{
						cout<<token<<": unknown task configure in the slave side"<<endl;
					}

					// process next configure
					token = strtok(NULL, " ");
				}

				// launch the forwarded task
				launch_task(thetask);
			}
			else
			{
				cout<<"[slave]Undefined signal from master: "<<read_buf<<endl;
				cout<<"[slave]Undefined signal size: "<<readbytes<<endl;
			}
		}

		// check the running_jobs
		for(int i=0;(unsigned)i<running_jobs.size();i++)
		{
			// send key information of the job to the master node
			while(running_jobs[i]->is_unreportedkey())
			{
				stringstream ss;
				string key = running_jobs[i]->pop_unreportedkey();
				string keystr = "key";

				ss<<" jobid ";
				ss<<running_jobs[i]->get_jobid();
				keystr.append(ss.str());

				keystr.append(" ");
				keystr.append(key);
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, keystr.c_str());

				// send message to the master node
				nbwrite(masterfd, write_buf);
			}

			// check if all tasks in the job are finished
			if(running_jobs[i]->get_numrunningtasks() == 0) // all task is finished
			{
				// clear job from the vectors
				slave_job* deleted_job = running_jobs[i];
				running_jobs.erase(running_jobs.begin()+i);
				i--;
				delete deleted_job;
				continue;
			}
		}

		// check message from tasks through pipe
		for(int i=0;(unsigned)i<running_tasks.size();i++)
		{
			readbytes = nbread(running_tasks[i]->get_readfd(), read_buf);
			if(readbytes == 0)
			{
				// ignore this case as default
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else
			{
				if(strncmp(read_buf, "complete", 8) == 0)
				{
					cout<<"[slave]Task with taskid "<<running_tasks[i]->get_taskid();
					cout<<" and job id "<<running_tasks[i]->get_job()->get_jobid();
					cout<<" completed successfully"<<endl;

					// send terminate message
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "terminate");
					nbwrite(running_tasks[i]->get_writefd(), write_buf);

					// mark the task as completed
					running_tasks[i]->set_status(COMPLETED);
				}
				else if(strncmp(read_buf, "requestconf", 11) == 0)
				{
					// parse all task configure
					stringstream message;
					message<<"taskconf ";

					// job id
					message<<"jobid ";
					message<<running_tasks[i]->get_job()->get_jobid();

					// task id
					message<<" taskid ";
					message<<running_tasks[i]->get_taskid();

					// input paths
					message<<" inputpaths ";
					message<<running_tasks[i]->get_numinputpaths(); // number of inputpaths
					for(int j=0;j<running_tasks[i]->get_numinputpaths();j++)
					{
						message<<" ";
						message<<running_tasks[i]->get_inputpath(j);
					}
					
					// send message to the task
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.str().c_str());
					nbwrite(running_tasks[i]->get_writefd(), write_buf);
				}
				else if(strncmp(read_buf, "key", 3) == 0)
				{
					char* token;
					token = strtok(read_buf, " "); // token <- key
					token = strtok(NULL, " "); // token <- key value
					running_tasks[i]->get_job()->add_key(token);
				}
				else
				{
					cout<<"[slave]Undefined message protocol from task"<<endl;
					cout<<"       Message: "<<read_buf<<endl;
				}
			}
		}

		// check task clear
		for(int i=0;(unsigned)i<running_tasks.size();i++)
		{
			if(waitpid(running_tasks[i]->get_pid(), &(running_tasks[i]->pstat), WNOHANG)) // waitpid returned nonzero 
			{
				if(running_tasks[i]->get_status() == COMPLETED) // successful termination
				{
					// send 'taskcomplete' message to the master
					stringstream ss;
					string msg = "taskcomplete";
					ss<<" jobid ";
					ss<<running_tasks[i]->get_job()->get_jobid();
					ss<<" taskid ";
					ss<<running_tasks[i]->get_taskid();
					msg.append(ss.str());

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, msg.c_str());
					nbwrite(masterfd, write_buf);

					// clear all to things related to this task
					running_tasks[i]->get_job()->finish_task(running_tasks[i]);
					delete running_tasks[i];
					running_tasks.erase(running_tasks.begin()+i);
					i--;
				}
				else
				{
					cout<<"[slave]A ";
					if(running_tasks[i]->get_taskrole() == MAP)
						cout<<"map ";
					else if(running_tasks[i]->get_taskrole() == REDUCE)
						cout<<"reduce ";
					cout<<"task with taskid "<<running_tasks[i]->get_taskid();
					cout<<" and jobid "<<running_tasks[i]->get_job()->get_jobid();
					cout<<" terminated abnormally"<<endl;
					cout<<"pid: "<<running_tasks[i]->get_pid()<<endl;
					// TODO: clear data structures for the task

					// TODO: launch the failed task again
				}
			}
		}

		// sleeps for 0.0001 seconds. change this if necessary
		// usleep(100);
	}
	if(close(masterfd)<0)
		cout<<"[slave]Close failed"<<endl;
	cout<<"[slave]Exiting slave..."<<endl;
	exit(0);
}

void launch_task(slave_task* atask)
{
	int pid;
	int fd1[2]; // two set of fds between slave and task(1)
	int fd2[2]; // two set of fds between slave and task(2)
	pipe(fd1); // fd1[0]: slave read, fd1[1]: task write
	pipe(fd2); // fd2[0]: task read, fd2[1]: slave write

	// set pipe fds to be non-blocking to avoid deadlock
	fcntl(fd1[0], F_SETFL, O_NONBLOCK);
	fcntl(fd1[1], F_SETFL, O_NONBLOCK);
	fcntl(fd2[0], F_SETFL, O_NONBLOCK);
	fcntl(fd2[1], F_SETFL, O_NONBLOCK);

	// set pipe fds
	atask->set_readfd(fd1[0]);
	atask->set_writefd(fd2[1]);


	pid = fork();

	if(pid == 0) // child side
	{
		// pass all arguments
		char** args;
		int count;
		stringstream ss1;
		stringstream ss2;

		// origianl arguments + pipe fds + task type
		count = atask->get_argcount();
		args = new char*[count+4];

		// pass original arguments
		for(int i=0;i<count;i++)
		{
			args[i] = new char[strlen(atask->get_argvalues()[i])+1];
			strcpy(args[i], atask->get_argvalues()[i]);
		}

		// pass pipe fds
		ss1<<fd2[0];
		ss2<<fd1[1];
		args[count] = new char[ss1.str().length()+1];
		args[count+1] = new char[ss2.str().length()+1];
		strcpy(args[count], ss1.str().c_str());
		strcpy(args[count+1], ss2.str().c_str());

		// pass task type
		if(atask->get_taskrole() == MAP)
		{
			args[count+2] = new char[4];
			strcpy(args[count+2], "MAP");
			//args[count+2] = "MAP";
		}
		else if(atask->get_taskrole() == REDUCE)
		{
			args[count+2] = new char[6];
			strcpy(args[count+2], "REDUCE");
			//args[count+2] = "REDUCE";
		}
		else
		{
			cout<<"[slave]Debugging: the role of the task is not defined in launch_task() function"<<endl;
			args[count+2] = new char[4];
			strcpy(args[count+2], "JOB");
			//args[count+2] = "JOB";
		}
		// pass null to last parameter
		args[count+3] = NULL;

		// launch the task with the passed arguments
		while(execv(args[0], args) == -1)
		{
			cout<<"Debugging: execv failed"<<endl;
			cout<<"Arguments:";
			for(int i=0;i<count+3;i++)
			{
				cout<<" "<<args[i];
			}
			cout<<endl;

			// sleeps for 1 seconds and retry execv. change this if necessary
			sleep(1);
		}
	}
	else if(pid < 0)
	{
		cout<<"[slave]Task could not have been started due to child process forking failure"<<endl;
	}
	else // parent side
	{
		// close pipe fds for task side
		close(fd2[0]);
		close(fd1[1]);

		// register the pid of the task process
		atask->set_pid(pid);

		// print the launch message
		cout<<"[slave]A ";
		if(atask->get_taskrole() == MAP)
			cout<<"map ";
		else if(atask->get_taskrole() == REDUCE)
			cout<<"reduce ";
		cout<<"task launched with taskid "<<atask->get_taskid()<<" and jobid "<<atask->get_job()->get_jobid();
		cout<<endl;
		return;
	}
}

slave_job* find_jobfromid(int id)
{
	for(int i=0;(unsigned)i<running_jobs.size();i++)
	{
		if(running_jobs[i]->get_jobid() == id)
		{
			return running_jobs[i];
		}
	}
	return NULL;
}
#ifndef _SLAVE_
#define _SLAVE_

#include "slave_task.hh"

int connect_to_server(char *host, unsigned short port); // function which connect to the master
void signal_listener(void); // function used to communicate with the master
void launch_task(slave_task* atask); // launch forwarded task
slave_job* find_jobfromid(int id); // return the slave_job with input id if it exist

#endif
#include <iostream>
#include "slave.hh"
#include <pthread.h>
#include <errno.h>
#include <fstream>
#include <sstream>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <mapreduce/definitions.hh>
#include "../slave_job.hh"
#include "../slave_task.hh"

using namespace std;

char read_buf[BUF_SIZE];
char write_buf[BUF_SIZE];

int port = -1;
int dhtport = -1;
int masterfd = -1;

int buffersize = 8388608; // 8 MB buffer size

bool master_is_set = false;
char master_address[BUF_SIZE];
string localhostname;
vector<slave_job*> running_jobs; // a vector of job, one or multiple tasks of which are running on this slave node
vector<slave_task*> running_tasks; // a vector of running tasks

int main(int argc, char** argv)
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "num_slave")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			conf>>token;
			strcpy(master_address, token.c_str());
			master_is_set = true;
		}
		else
		{
			cout<<"[slave]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// verify initialization
	if(port == -1)
	{
		cout<<"[slave]port should be specified in the setup.conf"<<endl;
		return 1;
	}
	if(master_is_set == false)
	{
		cout<<"[slave]master_address should be specified in the setup.conf"<<endl;
		return 1;
	}

	// read hostname from hostname file
	ifstream hostfile;
	string hostpath = DHT_PATH;
	hostpath.append("hostname");
	hostfile.open(hostpath.c_str());
	hostfile>>localhostname;

	// connect to master
	masterfd = connect_to_server(master_address, port);
	if(masterfd<0)
	{
		cout<<"[slave]Connecting to master failed"<<endl;
		return 1;
	}

	// set master socket to be non-blocking socket to avoid deadlock
	fcntl(masterfd, F_SETFL, O_NONBLOCK);
	setsockopt(masterfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(masterfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));


	signal_listener();

	return 0;
}

int connect_to_server(char* host, unsigned short port)
{
	int clientfd;
	struct sockaddr_in serveraddr;
	struct hostent* hp;

	//SOCK_STREAM -> tcp
	clientfd = socket(AF_INET, SOCK_STREAM, 0);
	if(clientfd < 0)
	{
		cout<<"[slave]Openning socket failed"<<endl;
		exit(1);
	}

	hp = gethostbyname(host);

	if (hp == NULL)
		cout<<"[slave]Cannot find host by host name"<<endl;

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
	serveraddr.sin_port = htons(port);

	connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr));
	return clientfd;
}

void signal_listener()
{
	//ofstream logfile = new ofstream("slave" + id + ".log");
	// get signal from master, jobs and tasks
	int readbytes = 0;
	//int writeidclock = 0;
	struct timeval time_start;
	struct timeval time_end;

	gettimeofday(&time_start, NULL);
	gettimeofday(&time_end, NULL);

	while(1)
	{
		readbytes = nbread(masterfd, read_buf);
		if(readbytes == 0) //connection closed from master
		{
//logfile << gettimeofday
			cout<<"[slave]Connection from master is abnormally closed"<<endl;
			while(close(masterfd)<0)
			{
				cout<<"[slave]Closing socket failed"<<endl;

				// sleeps for 1 milli second
				usleep(1000);
			}
			cout<<"[slave]Exiting slave..."<<endl;
			exit(0);
		}
		else if(readbytes < 0)
		{
			// do nothing
		}
		else // signal arrived from master
		{
			if(strncmp(read_buf, "whoareyou", 9) == 0)
			{
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, "slave");
				nbwrite(masterfd, write_buf);
			}
			else if(strncmp(read_buf, "close", 5) == 0)
			{
				cout<<"[slave]Close request from master"<<endl;
				while(close(masterfd) < 0)
				{
					cout<<"[slave]Close failed"<<endl;

					// sleeps for 1 milli seconds
					usleep(1000);
				}
				cout<<"[slave]Exiting slave..."<<endl;
				return;
			}
			else if(strncmp(read_buf, "tasksubmit", 10) == 0)
			{
				// launch the forwarded task
				slave_job* thejob = NULL;
				slave_task* thetask = NULL;

				int jobid;
				int taskid;


				char* token;
				token = strtok(read_buf, " "); // token <- "tasksubmit"
				token = strtok(NULL, " "); // token <- jobid

				jobid = atoi(token);

				thejob = find_jobfromid(jobid);

				if(thejob == NULL) // if any task in this job are not running in this slave
				{
					thejob = new slave_job(jobid, masterfd);
					running_jobs.push_back(thejob);
				}

				token = strtok(NULL, " "); // token <- taskid

				taskid = atoi(token);

				thetask = new slave_task(taskid); // the status is running by default

				// add to the running_tasks vector
				running_tasks.push_back(thetask);

				// add this task in 'thejob'
				thejob->add_task(thetask);

				token  = strtok(NULL, " "); // token <- role

				if(strncmp(token, "MAP", 3) == 0)
				{
					thetask->set_taskrole(MAP);

					token = strtok(NULL, " ");

					int argc = atoi(token);

					thetask->set_argcount(argc);

					char** values = new char*[argc];

					for(int i = 0; i < argc; i++)
					{
						token = strtok(NULL, " ");;
						values[i] = new char[strlen(token) + 1];
						strcpy(values[i], token);
					}

					thetask->set_argvalues(values);

					// read messages from master until getting Einput
					while(1)
					{
						readbytes = nbread(masterfd, read_buf);
						if(readbytes == 0)
						{
							cout<<"[slave]Connection from master is abnormally closed"<<endl;
						}
						else if(readbytes < 0)
						{
							continue;
						}
						else // a message
						{

							if(strncmp(read_buf, "inputpath", 9) == 0)
							{
								token = strtok(read_buf, " "); // token <- "inputpath"

								token = strtok(NULL, " ");

								while(token != NULL)
								{
									// add the input path to the task
									thetask->add_inputpath(token);

									token = strtok(NULL, " ");
								}
							}
							else if(strncmp(read_buf, "Einput", 6) == 0)
							{
								// break the while loop
								break;
							}
							else
							{
								cout<<"[slave]Unexpected message order from master"<<endl;
							}
						}
					}

					// launch the forwarded task
					launch_task(thetask);
				}
				else if(strncmp(token, "REDUCE", 6) == 0)
				{
					thetask->set_taskrole(REDUCE);

					token = strtok(NULL, " ");

					int argc = atoi(token);

					thetask->set_argcount(argc);

					char** values = new char*[argc];

					for(int i = 0; i < argc; i++)
					{
						token = strtok(NULL, " ");;
						values[i] = new char[strlen(token) + 1];
						strcpy(values[i], token);
					}

					thetask->set_argvalues(values);

					// read messages from master
					while(1)
					{
						readbytes = nbread(masterfd, read_buf);
						if(readbytes == 0)
						{
							cout<<"[slave]Connection from master is abnormally closed"<<endl;
						}
						else if(readbytes < 0)
						{
							continue;
						}
						else // a message
						{
							break;
						}
					}

					token = strtok(read_buf, " "); // <- "inputpath"
					token = strtok(NULL, " "); // <- first peer id

					while(token != NULL)
					{
						thetask->peerids.push_back(atoi(token));

						token = strtok(NULL, " "); // <- numiblock

						thetask->numiblocks.push_back(atoi(token));

						token = strtok(NULL, " "); // <- next peerid
					}

					// launch the forwarded task
					launch_task(thetask);
				}
				else
				{
					cout<<"Debugging: the task role is undefined well."<<endl;
					thetask->set_taskrole(JOB);
				}

			}
			else
			{
				cout<<"[slave]Undefined signal from master: "<<read_buf<<endl;
				cout<<"[slave]Undefined signal size: "<<readbytes<<endl;
			}
		}

		// check the running_jobs
		for(int i=0;(unsigned)i<running_jobs.size();i++)
		{
			// check if all tasks in the job are finished
			if(running_jobs[i]->get_numrunningtasks() == 0) // all task is finished
			{
				// clear job from the vectors
				slave_job* deleted_job = running_jobs[i];
				running_jobs.erase(running_jobs.begin()+i);
				i--;
				delete deleted_job;
				continue;
			}
		}

		// check message from tasks through pipe
		for(int i=0;(unsigned)i<running_tasks.size();i++)
		{
			readbytes = nbread(running_tasks[i]->get_readfd(), read_buf);
			if(readbytes == 0)
			{
				// ignore this case as default
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else
			{
				if(strncmp(read_buf, "complete", 8) == 0)
				{
					char* token;

					if(running_tasks[i]->get_taskrole() == MAP) // map task
					{
						string message = "peerids ";
						stringstream ss;
						ss << running_tasks[i]->get_job()->get_jobid();

						// receive peerids
						token = strtok(read_buf, " ");
						token = strtok(NULL, " "); // first token(peer id)

						while(token != NULL)
						{
							ss << " ";
							ss << atoi(token);
							token = strtok(NULL, " ");
						}

						message.append(ss.str());
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						nbwrite(masterfd, write_buf);
					}


					//cout<<"[slave]Task with taskid "<<running_tasks[i]->get_taskid();
					//cout<<" and job id "<<running_tasks[i]->get_job()->get_jobid();
					//cout<<" completed successfully"<<endl;

					// send terminate message
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, "terminate");
					nbwrite(running_tasks[i]->get_writefd(), write_buf);

					// mark the task as completed
					running_tasks[i]->set_status(COMPLETED);
				}
				else if(strncmp(read_buf, "requestconf", 11) == 0)
				{
					// parse all task configure
					string message;
					stringstream ss;
					ss<<"taskconf ";

					// job id
					ss<<running_tasks[i]->get_job()->get_jobid();

					// task id
					ss<<" ";
					ss<<running_tasks[i]->get_taskid();
					message = ss.str();

					// send message to the task
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());
					nbwrite(running_tasks[i]->get_writefd(), write_buf);

					if(running_tasks[i]->get_taskrole() == MAP)
					{
						// send input paths
						message = "inputpath";

						int iter = 0;
						while(iter < running_tasks[i]->get_numinputpaths())
						{
							if(message.length() + running_tasks[i]->get_inputpath(iter).length() + 1 <= BUF_SIZE)
							{
								message.append(" ");
								message.append(running_tasks[i]->get_inputpath(iter));
							}
							else
							{
								if(running_tasks[i]->get_inputpath(iter).length() + 10 > BUF_SIZE)
									cout<<"[master]The length of inputpath excceded the limit"<<endl;

								// send message to slave
								memset(write_buf, 0, BUF_SIZE);
								strcpy(write_buf, message.c_str());
								nbwrite(running_tasks[i]->get_writefd(), write_buf);

								message = "inputpath ";
								message.append(running_tasks[i]->get_inputpath(iter));
							}
							iter++;
						}

						// send remaining paths
						if(message.length() > strlen("inputpath "))
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());
							nbwrite(running_tasks[i]->get_writefd(), write_buf);
						}

						// notify end of inputpaths
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, "Einput");
						nbwrite(running_tasks[i]->get_writefd(), write_buf);

						/*
						// input paths
						message<<" inputpaths ";
						message<<running_tasks[i]->get_numinputpaths(); // number of inputpaths
						for(int j=0;j<running_tasks[i]->get_numinputpaths();j++)
						{
						message<<" ";
						message<<running_tasks[i]->get_inputpath(j);
						}

						// send message to the task
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.str().c_str());
						nbwrite(running_tasks[i]->get_writefd(), write_buf);
						*/
					}
					else
					{
						// send input paths
						message = "inputpath";
						stringstream ss;

						for(int j = 0; (unsigned)j < running_tasks[i]->peerids.size(); j++)
						{
							ss << " ";
							ss << running_tasks[i]->peerids[j];
							ss << " ";
							ss << running_tasks[i]->numiblocks[j];
						}

						message.append(ss.str());

						// notify end of inputpaths
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());
						nbwrite(running_tasks[i]->get_writefd(), write_buf);
					}
				}
				else
				{
					cout<<"[slave]Undefined message protocol from task"<<endl;
					cout<<"       Message: "<<read_buf<<endl;
				}
			}
		}

		// check task clear
		for(int i=0;(unsigned)i<running_tasks.size();i++)
		{
			if(waitpid(running_tasks[i]->get_pid(), &(running_tasks[i]->pstat), WNOHANG)) // waitpid returned nonzero 
			{
				if(running_tasks[i]->get_status() == COMPLETED) // successful termination
				{
					// send 'taskcomplete' message to the master
					stringstream ss;
					string msg = "taskcomplete";
					ss << " jobid ";
					ss << running_tasks[i]->get_job()->get_jobid();
					ss << " taskid ";
					ss << running_tasks[i]->get_taskid();

					msg.append(ss.str());

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, msg.c_str());
					nbwrite(masterfd, write_buf);

					// clear all to things related to this task
					running_tasks[i]->get_job()->finish_task(running_tasks[i]);
					delete running_tasks[i];
					running_tasks.erase(running_tasks.begin()+i);
					i--;
				}
				else
				{
					cout<<"[slave]A ";
					if(running_tasks[i]->get_taskrole() == MAP)
						cout<<"map ";
					else if(running_tasks[i]->get_taskrole() == REDUCE)
						cout<<"reduce ";
					cout<<"task with taskid "<<running_tasks[i]->get_taskid();
					cout<<" and jobid "<<running_tasks[i]->get_job()->get_jobid();
					cout<<" terminated abnormally"<<endl;
					cout<<"pid: "<<running_tasks[i]->get_pid()<<endl;

					sleep(1);
					// TODO: clear data structures for the task

					// TODO: launch the failed task again
				}
			}
		}

		gettimeofday(&time_end, NULL);
		if(time_end.tv_sec - time_start.tv_sec > 20.0)
		{
			//cout<<"[Slave Heartbeat]";
			//cout<<"numjob: "<<running_jobs.size()<<", ";
			//cout<<"numtask: "<<running_tasks.size()<<"("<<localhostname<<")"<<endl;
			//gettimeofday(&time_start, NULL);
		}
	}
	while(close(masterfd)<0)
	{
		cout<<"[slave]Close failed"<<endl;
		
		// sleeps for 1 milliseconds
		usleep(1000);
	}
	cout<<"[slave]Exiting slave..."<<endl;
	exit(0);
}

void launch_task(slave_task* atask)
{
	int pid;
	int fd1[2]; // two set of fds between slave and task(1)
	int fd2[2]; // two set of fds between slave and task(2)
	pipe(fd1); // fd1[0]: slave read, fd1[1]: task write
	pipe(fd2); // fd2[0]: task read, fd2[1]: slave write

	// set pipe fds to be non-blocking to avoid deadlock
	fcntl(fd1[0], F_SETFL, O_NONBLOCK);
	fcntl(fd1[1], F_SETFL, O_NONBLOCK);
	fcntl(fd2[0], F_SETFL, O_NONBLOCK);
	fcntl(fd2[1], F_SETFL, O_NONBLOCK);

	// set pipe fds
	atask->set_readfd(fd1[0]);
	atask->set_writefd(fd2[1]);

	pid = fork();

	if(pid == 0) // child side
	{
		// pass all arguments
		char** args;
		int count;
		stringstream ss;
		stringstream ss1;
		stringstream ss2;

		// origianl arguments + write id + pipe fds + task type
		count = atask->get_argcount();
		args = new char*[count+4];

		// pass original arguments
		for(int i=0;i<count;i++)
		{
			args[i] = new char[strlen(atask->get_argvalues()[i])+1];
			strcpy(args[i], atask->get_argvalues()[i]);
			args[i][strlen(atask->get_argvalues()[i])] = 0;
		}

		// pass pipe fds
		ss1<<fd2[0];
		ss2<<fd1[1];

		args[count] = new char[ss1.str().length()+1];
		args[count+1] = new char[ss2.str().length()+1];
		strcpy(args[count], ss1.str().c_str());
		strcpy(args[count+1], ss2.str().c_str());
		args[count][ss1.str().length()] = 0;
		args[count+1][ss2.str().length()] = 0;

		// pass task type
		if(atask->get_taskrole() == MAP)
		{
			args[count+2] = new char[4];
			strcpy(args[count+2], "MAP");
			args[count+2][3] = 0;
			//args[count+2] = "MAP";
		}
		else if(atask->get_taskrole() == REDUCE)
		{
			args[count+2] = new char[7];
			strcpy(args[count+2], "REDUCE");
			args[count+2][6] = 0;
			//args[count+2] = "REDUCE";
		}
		else
		{
			cout<<"[slave]Debugging: the role of the task is not defined in launch_task() function"<<endl;
			args[count+2] = new char[4];
			strcpy(args[count+2], "JOB");
			args[count+2][3] = 0;
			//args[count+2] = "JOB";
		}

		// pass null to last parameter
		args[count+3] = NULL;

		// launch the task with the passed arguments
		while(execv(args[0], args) == -1)
		{
			cout<<"Debugging: execv failed"<<endl;
			cout<<"Arguments:";
			for(int i=0;i<count+3;i++)
			{
				cout<<" "<<args[i];
			}
			cout<<endl;

			// sleeps for 1 seconds and retry execv. change this if necessary
			sleep(1);
		}
	}
	else if(pid < 0)
	{
		cout<<"[slave]Task could not have been started due to child process forking failure"<<endl;
	}
	else // parent side
	{
		// close pipe fds for task side
		close(fd2[0]);
		close(fd1[1]);

		// register the pid of the task process
		atask->set_pid(pid);

		// print the launch message
		//cout<<"[slave]A ";
		//if(atask->get_taskrole() == MAP)
		//	cout<<"map ";
		//else if(atask->get_taskrole() == REDUCE)
		//	cout<<"reduce ";
		//cout<<"task launched with taskid "<<atask->get_taskid()<<" and jobid "<<atask->get_job()->get_jobid();
		//cout<<endl;
		return;
	}
}

slave_job* find_jobfromid(int id)
{
	for(int i=0;(unsigned)i<running_jobs.size();i++)
	{
		if(running_jobs[i]->get_jobid() == id)
		{
			return running_jobs[i];
		}
	}
	return NULL;
}
#ifndef _SLAVE_
#define _SLAVE_

#define DHT_SLAVE

#include "../slave_task.hh"

int connect_to_server(char *host, unsigned short port); // function which connect to the master
void signal_listener(void); // function used to communicate with the master
void launch_task(slave_task* atask); // launch forwarded task
slave_job* find_jobfromid(int id); // return the slave_job with input id if it exist

#endif
#ifdef DHT_SLAVE

///////////////
// DHT_SLAVE //
///////////////

#ifndef _SLAVE_JOB_
#define _SLAVE_JOB_


#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <mapreduce/definitions.hh>
#include <common/msgaggregator.hh>
#include "slave_task.hh"

using namespace std;

class slave_job
{
private:
	int jobid;
	int masterfd;
	vector<slave_task*> tasks;
	vector<slave_task*> running_tasks;
	vector<slave_task*> completed_tasks;
	
public:
	slave_job();
	slave_job(int id, int fd);
	~slave_job();

	void set_jobid(int id);
	int get_jobid();
	void finish_task(slave_task* atask);
	slave_task* find_taskfromid(int id);
	int get_numtasks(); // tasks of this job assigned to this slave
	int get_numrunningtasks(); // running tasks of this job assigned to this slave
	int get_numcompletedtasks(); // completed tasks of this job assigned to this slave
	slave_task* get_completedtask(int index);
	void add_task(slave_task* atask);
	slave_task* get_task(int index);
};

void slave_job::finish_task(slave_task* atask)
{
	for(int i=0;(unsigned)i<this->running_tasks.size();i++)
	{
		if(this->running_tasks[i] == atask)
		{
			this->running_tasks.erase(this->running_tasks.begin()+i);
			this->completed_tasks.push_back(atask);
			atask->set_status(COMPLETED);
			return;
		}
	}
}

slave_job::slave_job()
{
	this->jobid = -1;
	masterfd = -1;
}

slave_job::slave_job(int id, int fd)
{
	this->jobid = id;
	masterfd = fd;
}

slave_job::~slave_job()
{
	// do nothing as default
}

void slave_job::set_jobid(int id)
{
	this->jobid = id;
}

int slave_job::get_jobid()
{
	return this->jobid;
}

slave_task* slave_job::find_taskfromid(int id)
{
	for(int i=0;(unsigned)i<this->tasks.size();i++)
	{
		if(this->tasks[i]->get_taskid() == id)
			return this->tasks[i];
	}
	cout<<"No such a task with that index in this job assigned to this slave"<<endl; 
	return NULL;
}

int slave_job::get_numtasks()
{
	return this->tasks.size();
}

int slave_job::get_numrunningtasks()
{
	return this->running_tasks.size();
}

int slave_job::get_numcompletedtasks()
{
	return this->completed_tasks.size();
}

void slave_job::add_task(slave_task* atask)
{
	if(atask->get_status() != RUNNING)
		cout<<"Debugging: The added task is not at running state."<<endl;
	atask->set_job(this);
	this->tasks.push_back(atask);
	this->running_tasks.push_back(atask); // tasks are in running state initially
}

slave_task* slave_job::get_task(int index)
{
	if((unsigned)index>=this->tasks.size())
	{
		cout<<"Debugging: index of bound in the slave_job::get_task() function."<<endl;
		return NULL;
	}
	else 
		return this->tasks[index];
}

slave_task* slave_job::get_completedtask(int index)
{
	if((unsigned)index < completed_tasks.size())
	{
		return completed_tasks[index];
	}
	else
	{
		cout<<"Debugging: Index out of range in the slave_job::get_completedtask() function"<<endl;
		return NULL;
	}

}


// member functioin of slave_task class


slave_task::slave_task()
{
	this->taskid = -1;
	this->role = JOB; // this should be changed to MAP or REDUCE 
	this->status = RUNNING; // the default is RUNNING because here is slave side
	this->pipefds[0] = -1;
	this->pipefds[1] = -1;
	this->argcount = -1;
	this->argvalues = NULL;
	this-> job = NULL;
	this->pid = 0;
}

slave_task::slave_task(int id)
{
	this->taskid = id;
	this->role = JOB; // this should be changed to MAP or REDUCE 
	this->status = RUNNING; // the default is RUNNING because here is slave side
	this->pipefds[0] = -1;
	this->pipefds[1] = -1;
	this->argcount = -1;
	this->argvalues = NULL;
	this-> job = NULL;
	this->pid = 0;
}

slave_task::~slave_task()
{
	// close all pipe fds
	close(this->pipefds[0]);
	close(this->pipefds[1]);

	// delete argvalues
	if(argvalues != NULL)
	{
		for(int i=0;i<this->argcount;i++)
		{
			delete[] argvalues[i];
		}
		delete[] argvalues;
	}
}

void slave_task::set_taskid(int id)
{
	this->taskid = id;
}

int slave_task::get_taskid()
{
	return this->taskid;
}

void slave_task::set_pid(int id)
{
	this->pid = id;
}

int slave_task::get_pid()
{
	return this->pid;
}

void slave_task::set_taskrole(mr_role arole)
{
	this->role = arole;
}

mr_role slave_task::get_taskrole()
{
	return this->role;
}

void slave_task::set_status(task_status astatus)
{
	this->status = astatus;
}

task_status slave_task::get_status()
{
	return this->status;
}

void slave_task::set_readfd(int fd)
{
	this->pipefds[0] = fd;
}

void slave_task::set_writefd(int fd)
{
	this->pipefds[1] = fd;
}

int slave_task::get_readfd()
{
	return this->pipefds[0];
}

int slave_task::get_writefd()
{
	return this->pipefds[1];
}

int slave_task::get_argcount()
{
	return this->argcount;
}

void slave_task::set_argcount(int num)
{
	this->argcount = num;
}

char** slave_task::get_argvalues()
{
	return this->argvalues;
}

void slave_task::set_argvalues(char** argv)
{
	this->argvalues = argv;
}

slave_job* slave_task::get_job()
{
	return this->job;
}

void slave_task::set_job(slave_job* ajob)
{
	this->job = ajob;
}

void slave_task::add_inputpath(string apath)
{
	inputpaths.push_back(apath);
}

string slave_task::get_inputpath(int index)
{
	if((unsigned)index>=inputpaths.size())
	{
		cout<<"Index out of bound in the slave_task::get_inputpath() function."<<endl;
		return "";
	}
	else
		return inputpaths[index];
}

int slave_task::get_numinputpaths()
{
	return this->inputpaths.size();
}

#endif

#else

///////////////////////////
// DHT_SLAVE NOT DEFINED //
///////////////////////////

#ifndef _SLAVE_JOB_
#define _SLAVE_JOB_


#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <mapreduce/definitions.hh>
#include "slave_task.hh"

using namespace std;

class slave_job
{
private:
	int jobid;
	vector<slave_task*> tasks;
	vector<slave_task*> running_tasks;
	vector<slave_task*> completed_tasks;
	
public:
	slave_job();
	slave_job(int id);
	~slave_job();

	void set_jobid(int id);
	int get_jobid();
	void finish_task(slave_task* atask);
	slave_task* find_taskfromid(int id);
	int get_numtasks(); // tasks of this job assigned to this slave
	int get_numrunningtasks(); // running tasks of this job assigned to this slave
	int get_numcompletedtasks(); // completed tasks of this job assigned to this slave
	slave_task* get_completedtask(int index);
	void add_task(slave_task* atask);
	slave_task* get_task(int index);
};

void slave_job::finish_task(slave_task* atask)
{
	for(int i=0;(unsigned)i<this->running_tasks.size();i++)
	{
		if(this->running_tasks[i] == atask)
		{
			this->running_tasks.erase(this->running_tasks.begin()+i);
			this->completed_tasks.push_back(atask);
			atask->set_status(COMPLETED);
			return;
		}
	}
}

slave_job::slave_job()
{
	this->jobid = -1;
}

slave_job::slave_job(int id)
{
	this->jobid = id;
}

slave_job::~slave_job()
{
	// do nothing as default
}

void slave_job::set_jobid(int id)
{
	this->jobid = id;
}

int slave_job::get_jobid()
{
	return this->jobid;
}

slave_task* slave_job::find_taskfromid(int id)
{
	for(int i=0;(unsigned)i<this->tasks.size();i++)
	{
		if(this->tasks[i]->get_taskid() == id)
			return this->tasks[i];
	}
	cout<<"No such a task with that index in this job assigned to this slave"<<endl; 
	return NULL;
}

int slave_job::get_numtasks()
{
	return this->tasks.size();
}

int slave_job::get_numrunningtasks()
{
	return this->running_tasks.size();
}

int slave_job::get_numcompletedtasks()
{
	return this->completed_tasks.size();
}

void slave_job::add_task(slave_task* atask)
{
	if(atask->get_status() != RUNNING)
		cout<<"Debugging: The added task is not at running state."<<endl;
	atask->set_job(this);
	this->tasks.push_back(atask);
	this->running_tasks.push_back(atask); // tasks are in running state initially
}

slave_task* slave_job::get_task(int index)
{
	if((unsigned)index>=this->tasks.size())
	{
		cout<<"Debugging: index of bound in the slave_job::get_task() function."<<endl;
		return NULL;
	}
	else 
		return this->tasks[index];
}

slave_task* slave_job::get_completedtask(int index)
{
	if((unsigned)index < completed_tasks.size())
	{
		return completed_tasks[index];
	}
	else
	{
		cout<<"Debugging: Index out of range in the slave_job::get_completedtask() function"<<endl;
		return NULL;
	}

}


// member functioin of slave_task class


slave_task::slave_task()
{
	this->taskid = -1;
	this->role = JOB; // this should be changed to MAP or REDUCE 
	this->status = RUNNING; // the default is RUNNING because here is slave side
	this->pipefds[0] = -1;
	this->pipefds[1] = -1;
	this->argcount = -1;
	this->argvalues = NULL;
	this-> job = NULL;
	this->pid = 0;
}

slave_task::slave_task(int id)
{
	this->taskid = id;
	this->role = JOB; // this should be changed to MAP or REDUCE 
	this->status = RUNNING; // the default is RUNNING because here is slave side
	this->pipefds[0] = -1;
	this->pipefds[1] = -1;
	this->argcount = -1;
	this->argvalues = NULL;
	this-> job = NULL;
	this->pid = 0;
}

slave_task::~slave_task()
{
	// close all pipe fds
	close(this->pipefds[0]);
	close(this->pipefds[1]);

	// delete argvalues
	if(argvalues != NULL)
	{
		for(int i=0;i<this->argcount;i++)
		{
			delete[] argvalues[i];
		}
		delete[] argvalues;
	}
}

void slave_task::set_taskid(int id)
{
	this->taskid = id;
}

int slave_task::get_taskid()
{
	return this->taskid;
}

void slave_task::set_pid(int id)
{
	this->pid = id;
}

int slave_task::get_pid()
{
	return this->pid;
}

void slave_task::set_taskrole(mr_role arole)
{
	this->role = arole;
}

mr_role slave_task::get_taskrole()
{
	return this->role;
}

void slave_task::set_status(task_status astatus)
{
	this->status = astatus;
}

task_status slave_task::get_status()
{
	return this->status;
}

void slave_task::set_readfd(int fd)
{
	this->pipefds[0] = fd;
}

void slave_task::set_writefd(int fd)
{
	this->pipefds[1] = fd;
}

int slave_task::get_readfd()
{
	return this->pipefds[0];
}

int slave_task::get_writefd()
{
	return this->pipefds[1];
}

int slave_task::get_argcount()
{
	return this->argcount;
}

void slave_task::set_argcount(int num)
{
	this->argcount = num;
}

char** slave_task::get_argvalues()
{
	return this->argvalues;
}

void slave_task::set_argvalues(char** argv)
{
	this->argvalues = argv;
}

slave_job* slave_task::get_job()
{
	return this->job;
}

void slave_task::set_job(slave_job* ajob)
{
	this->job = ajob;
}

void slave_task::add_inputpath(string apath)
{
	inputpaths.push_back(apath);
}

string slave_task::get_inputpath(int index)
{
	if((unsigned)index>=inputpaths.size())
	{
		cout<<"Index out of bound in the slave_task::get_inputpath() function."<<endl;
		return "";
	}
	else
		return inputpaths[index];
}

int slave_task::get_numinputpaths()
{
	return this->inputpaths.size();
}

#endif

#endif
#ifndef _SLAVE_TASK_
#define _SLAVE_TASK_

#include <iostream>
#include <mapreduce/definitions.hh>
#include <vector>
#include <string>

using namespace std;

class slave_job;

class slave_task
{
private:
	int taskid;
	int pid;
	mr_role role; // MAP or REDUCE
	task_status status;
	int pipefds[2]; // 0 for read, 1 for write
	int argcount;
	char** argvalues;
	slave_job* job;
	vector<string> inputpaths; // a vector of inputpaths. inputpaths can be multiple

public:
	vector<int> peerids;
	vector<int> numiblocks;
	slave_task();
	slave_task(int id);
	~slave_task();

	int pstat; // status value for waitpid()

	void set_taskid(int id);
	int get_taskid();
	void set_pid(int id);
	int get_pid();
	void set_taskrole(mr_role arole);
	mr_role get_taskrole();
	void set_status(task_status astatus);
	task_status get_status();
	void set_readfd(int fd);
	void set_writefd(int fd);
	int get_readfd();
	int get_writefd();
	int get_argcount();
	void set_argcount(int num);
	char** get_argvalues();
	void set_argvalues(char** argv);
	slave_job* get_job();
	void set_job(slave_job* ajob);
	void add_inputpath(string apath);
	string get_inputpath(int index);
	int get_numinputpaths();
};

#endif
#ifndef __FILECLIENT__
#define __FILECLIENT__

#include <iostream>
#include <set>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <fcntl.h>
#include <sys/time.h>
#include <common/msgaggregator.hh>
#include <mapreduce/definitions.hh>

using namespace std;

class fileclient // each task process will have two objects(read/write) of fileclient
{
private:
	int serverfd;
	char* token;
	char* ptr;
	datatype readdatatype;
	string currentkey;
	string Owritepath;
	char read_buf[BUF_SIZE];
	char write_buf[BUF_SIZE];

public:
	msgaggregator Iwritebuffer; // a buffer for the Iwrite
	msgaggregator Owritebuffer; // a buffer for the Owrite

	fileclient();
	~fileclient();
	bool write_record(string filename, string data, datatype atype); // append mode, write a record
	void close_server(); // this function is used to notify the server that writing is done
	void wait_write(set<int>* peerids); // wait until write is done
	bool read_request(string req, datatype atype); // connect to read file
	bool read_record(string& record); // read sentences from connected file(after read_request())
	int connect_to_server(); // returns fd of file server
	void configure_buffer_initial(string jobdirpath, string appname, string inputfilepath, bool isIcache); // set the initial string of the Iwritebuffer
};

fileclient::fileclient()
{
	serverfd = -1;
	token = NULL;
}

fileclient::~fileclient()
{
	close(serverfd);
	serverfd = -1;
}

int fileclient::connect_to_server()
{
	int fd;
	int buffersize = 8388608; // 8 MB buffer
	struct sockaddr_un serveraddr;

	// SOCK_STREAM -> tcp
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if(fd < 0)
	{
		cout<<"[fileclient]Openning unix socket failed"<<endl;
		exit(1);
	}

	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sun_family = AF_UNIX;
	strcpy(serveraddr.sun_path, IPC_PATH);

//struct timeval time_start;
//struct timeval time_end;
//double elapsed = 0.0;
//gettimeofday(&time_start, NULL);

	while(connect(fd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		// sleep for 1 miilisecond
		usleep(1000);
	}

	// set socket to be nonblocking
	fcntl(fd, F_SETFL, O_NONBLOCK);
	setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));

//gettimeofday(&time_end, NULL);
//elapsed = 1000000.0*(time_end.tv_sec - time_start.tv_sec);
//elapsed += (time_end.tv_usec - time_start.tv_usec);
//elapsed /= 1000.0;
//if(elapsed > 10.0)
//cout<<"\033[0;33m\tconnect() elapsed: "<<elapsed<<" milli seconds\033[0m"<<endl;

	serverfd = fd;

	// buffer for Iwrite and Owrite
	Iwritebuffer.set_fd(fd);
	Owritebuffer.set_fd(fd);

	return fd;
}

void fileclient::configure_buffer_initial(string jobdirpath, string appname, string inputfilepath, bool isIcache)
{
	// buffer for Iwrite
	string initial;
	if(isIcache)
	{
		initial = "ICwrite ";
		initial.append(jobdirpath);
		initial.append(" ");
		initial.append(appname);
		initial.append(" ");
		initial.append(inputfilepath);
		initial.append("\n");
	}
	else
	{
		initial = "Iwrite ";
		initial.append(jobdirpath);
		initial.append("\n");
	}

	Iwritebuffer.flush();
	Iwritebuffer.configure_initial(initial);
}

// close should be done exclusively with close_server() function
bool fileclient::write_record(string filename, string data, datatype atype)
{
	if(atype == INTERMEDIATE)
	{
		// generate request string
		string str = filename;
		str.append(" ");
		str.append(data);
		Iwritebuffer.add_record(str);
	}
	else if(atype == OUTPUT)// atype == OUTPUT
	{
		// generate request string
		if(Owritepath == filename) // serial write
		{
			Owritebuffer.add_record(data);
		}
		else // different output
		{
			Owritepath = filename;
			// flush and configure initial string of Owritebuffer
			Owritebuffer.flush();
			string initial = "Owrite ";
			initial.append(filename);
			initial.append("\n");

			Owritebuffer.configure_initial(initial);
			Owritebuffer.add_record(data);
		}
	}
	else // atype == RAW
	{
		cout<<"[fileclient]Wrong data type for write_record()"<<endl;
	}

//cout<<"\033[0;33m\trecord sent from client: \033[0m"<<write_buf<<endl;
	return true;
}

void fileclient::close_server()
{
	close(serverfd);
}

void fileclient::wait_write(set<int>* peerids) // wait until write is done
{
	// flush the write buffer
	Iwritebuffer.flush();
	Owritebuffer.flush();

	// generate request string
	string str;
	if(peerids != NULL) // map task
		str = "MWwrite";
	else // reduce task
		str = "RWwrite"; 

	// send the message to the fileserver
	memset(write_buf, 0, BUF_SIZE);
	strcpy(write_buf, str.c_str());
	nbwrite(serverfd, write_buf);

	if(peerids != NULL) // map task
	{
		// receive the node list to which idata is written
		int readbytes;
		while(1)
		{
			readbytes = nbread(serverfd, read_buf);
			if(readbytes == 0) // closed abnormally
			{
				cout<<"[fileclient]Connection from file server abnormally closed"<<endl;
			}
			else if(readbytes > 0)
			{
				if(read_buf[0] == 0)
				{
					break;
				}
				else
				{
					char* token;
					int id;
					token = strtok(read_buf, " ");

					while(token != NULL)
					{
						id = atoi(token);
						peerids->insert(id);

						// tokenize next peer id
						token = strtok(NULL, " ");
					}
					break;
				}
			}
			else // didn't receive packets
			{
				continue;
			}

			usleep(1000);
		}

		// wait close from fileserver
		while(1)
		{
			readbytes = nbread(serverfd, read_buf);
			if(readbytes == 0) // close detected
			{
				break;
			}
			else if(readbytes > 0)
			{
				if(read_buf[0] == 0)
				{
					break;
				}
			}
			usleep(1000);
		}

		close(serverfd);

		return;
	}
	else // reduce task
	{
		// don't need to wait for the peer ids
		close(serverfd);

		return;
	}
}

bool fileclient::read_request(string request, datatype atype)
{
	// generate request string to send file server
	readdatatype = atype;

	string str;
	if(atype == RAW)
	{
		str = "Rread ";
		str.append(request);

		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, str.c_str());

		nbwrite(serverfd, write_buf);

		// return true if 1 is returned, false if 0 is returned
		int readbytes;
		while(1)
		{
			readbytes = nbread(serverfd, read_buf); 

			if(readbytes == 0) // connection closed abnormally
			{
				close_server();

				cout<<"[fileclient]Connection abnormally closed"<<endl;

				return false;
			}
			else if(readbytes < 0)
			{
				continue;
			}
			else
			{
				if(read_buf[0] == 1) // intermediate cache hit
				{
					while(1)
					{
						readbytes = nbread(serverfd, read_buf);

						if(readbytes == 0) // connection closed abnormally
						{
							close_server();

							cout<<"[fileclient]Connection closed abnormally"<<endl;

							return false;
						}
						else if(readbytes < 0)
						{
							// sleeps for 1 millisecond
							usleep(1000);
							continue;
						}
						else
						{
							if(read_buf[0] == 1) // distributing intermediate data finished
							{
								return true;
							}
							else // key arrived
							{
								cout<<"[fileclient]Unexpected message during waiting distributing idata"<<endl;
							}
						}
					}
					return true;
				}
				else if(read_buf[0] == 0) // intermediate cache miss
				{
					return false;
				}
			}
		}
		return true;
	}
	else if(atype == INTERMEDIATE)
	{
		str = "Iread ";
		str.append(request);

		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, str.c_str());

		nbwrite(serverfd, write_buf);

		return false;
	}
	else // atype <- OUTPUT
	{
		cout<<"[fileclient]Unexpected datatype in the read_request()"<<endl;
	}

	return false;
}

bool fileclient::read_record(string& record) // read through the socket with blocking way and token each record
{
	if(readdatatype == RAW)
	{
		if(token != NULL)
		{
			token = strtok(ptr, "\n");
		}

		if(token == NULL)
		{
			int readbytes;
			while(1)
			{
				readbytes = nbread(serverfd, read_buf);
				if(readbytes == 0) // connection closed abnormally
				{
					cout<<"[fileclient]Connection abnormally closed"<<endl;
					close_server();

					// return empty string
					record = "";
					return false;
				}
				else if(readbytes < 0)
				{
					continue;
				}
				else // successful read
				{
					//cout<<"\tread stream at client: "<<read_buf<<endl;
					//cout<<"\tread stream bytes: "<<readbytes<<endl;
					if(read_buf[0] == -1) // the read stream is finished(Eread)
					{
						//cout<<"\t\tEnd of read stream at client"<<endl;
						record = "";
						return false;
					}
					else
					{
						token = strtok(read_buf, "\n");
						if(token == NULL)
						{
							continue;
						}
						else
						{
							ptr = read_buf + strlen(token) + 1;
							record = token;
							//cout<<"read stream at client side: "<<record<<endl;
							return true;
						}
					}
					//cout<<"\033[0;32m\trecord received in client: \033[0m"<<*record<<endl;
					//cout<<"\033[0;32m\treadbytes: \033[0m"<<readbytes<<endl;
				}
			}
			return false;
		}
		else
		{
			record = token;
			ptr = token + strlen(token) + 1;
			//cout<<"read stream at client side: "<<record<<endl;
			return true;
		}
	}
	else // INTERMEDIATE
	{
		if(token != NULL)
		{
			token = strtok(ptr, "\n");
		}

		if(token == NULL)
		{
			int readbytes;
			while(1)
			{
				readbytes = nbread(serverfd, read_buf);
				if(readbytes == 0) // connection closed abnormally
				{
					cout<<"[fileclient]Connection abnormally closed"<<endl;
					close_server();

					// return empty string
					record = "";
					return false;
				}
				else if(readbytes < 0)
				{
					continue;
					usleep(1000);
				}
				else // successful read
				{
					if(read_buf[0] == 0) // end of key
					{
						record = "";
						return false;
					}
					else
					{
						token = strtok(read_buf, "\n");
						if(token == NULL)
						{
							continue;
						}
						else
						{
							ptr = read_buf + strlen(token) + 1;
							record = token;
							return true;
						}
					}
				}
			}
		}
		else
		{
			record = token;
			ptr = token + strlen(token) + 1;
			return true;
		}
	}
}

#endif
#ifndef __MSGAGGREGATOR__
#define __MSGAGGREGATOR__

#include <mapreduce/definitions.hh>
#include <file_distributor/messagebuffer.hh>
#include <orthrus/dataentry.hh>
#include <iostream>
#include <errno.h>
#include <string.h>
#include <vector>
#include <unistd.h>
#include <stdlib.h>

using namespace std;

class msgaggregator
{
	private:
		int fd;
		int pos;
		char message[BUF_SIZE];
		string initial;

	public:
		vector<messagebuffer*>* msgbuf;
		entrywriter* dwriter;

		// public functions
		msgaggregator(); // constructor
		msgaggregator(int number); // constructor
		int get_available(); // remaining capacity, not the full capacity
		bool add_record(string& record); // <- automatically flushed??
		bool add_record(char*& record); // <- automatically flushed??
		void flush(); // flush and re-initialize the message 

		void configure_initial(string record);
		void set_initial();
		void set_msgbuf(vector<messagebuffer*>* target);
		void set_dwriter(entrywriter* awriter);
		void set_fd(int num);
		int get_fd();
		char* get_buf();
};

msgaggregator::msgaggregator()
{
	// set fd and pos
	fd = -1;
	pos = 0;
	initial = "";
	msgbuf = NULL;
	dwriter = NULL;
}

msgaggregator::msgaggregator(int number)
{
	// set fd and pos
	fd = number;
	pos = 0;
	initial = "";
	msgbuf = NULL;
	dwriter = NULL;
}

int msgaggregator::get_available()
{
	return BUF_SIZE - pos - 2; // -1 for null character and another -1 for newline character
}

bool msgaggregator::add_record(string& record) // return true when flushed
{
	// check whether the new record can be added
	if((unsigned)get_available() > record.length()) // new record can be added
	{
		// add newline character at the end of current message
		if((unsigned)pos != initial.length())
		{
			message[pos] = '\n';
			pos++;
		}

		// append the content(record)
		strcpy(message+pos, record.c_str());
		pos += record.length();

		// check if the current buffer size exceeds threshold
		if(pos > BUF_THRESHOLD)
		{
			flush();
			return true;
		}
		else
			return false;
	}
	else // new record should be added to next buffer and current buffer should be flushed 
	{
		flush();
		//message[pos] = '\n';
		//pos++;

		// append the content(record)
		strcpy(message+pos, record.c_str());
		pos += record.length();

		// check if the current buffer size exceeds threshold
		if(pos > BUF_THRESHOLD)
			flush();

		return true;
	}
}

bool msgaggregator::add_record(char*& record) // <- automatically flushed??
{
	string input = record;
	return add_record(input);
}

void msgaggregator::configure_initial(string record) // the white space should be explicitly added to the parameter string
{
	initial = record;
	set_initial();
}

void msgaggregator::set_initial()
{
	memset(message, 0, BUF_SIZE);
	strcpy(message, initial.c_str());
	pos = initial.length();
}

void msgaggregator::set_msgbuf(vector<messagebuffer*>* target)
{
	msgbuf = target;
}

void msgaggregator::flush() // return false when new messagebuffer is needed to be created
{
	// do not flush when message have no information
	if((unsigned)pos == initial.length())
	{
		return;
	}

	// write to the cache if writing is ongoing
	if(dwriter != NULL)
	{
		dwriter->write_record(message);
	}

	// write to the fd
	if(msgbuf == NULL) // no target messagebuf(client side)
	{
//cout<<"flushed message: "<<message<<endl<<endl;
		nbwrite(fd, message);


		// set initial contents
		set_initial();
		return;
	}
	else // write to target messagebuf(fileserver side)
	{
		if(msgbuf->size() > 1)
		{
			//cout<<"flushed message: "<<message<<endl<<endl;
			msgbuf->back()->set_buffer(message, fd);
			msgbuf->push_back(new messagebuffer());

			// set initial contents
			set_initial();
			return;
		}
		else
		{
//cout<<"flushed message: "<<message<<endl<<endl;
			if(nbwritebuf(fd, message, msgbuf->back()) <= 0)
			{
				// append new message buffer
				msgbuf->push_back(new messagebuffer());

				// set initial contents
				set_initial();
				return;
			}
			else
			{
				// set initial contents
				set_initial();
				return;
			}
		}
	}
}

void msgaggregator::set_fd(int num)
{
	fd = num;
}

int msgaggregator::get_fd()
{
	return fd;
}

char* msgaggregator::get_buf()
{
	return message;
}

void msgaggregator::set_dwriter(entrywriter* awriter)
{
	dwriter = awriter;
}

#endif
#ifndef __WRITECOUNT__
#define __WRITECOUNT__

#include <iostream>
#include <set>

using namespace std;

class writecount
{
	private:
	public:
		set<int> peerids;

		writecount();
		int size();
		bool add_peer(int peerid);
		bool clear_peer(int peerid);
};

writecount::writecount()
{
	// do nothing
}

bool writecount::add_peer(int peerid)
{
	if(peerids.find(peerid) == peerids.end())
	{
		peerids.insert(peerid);
		return true;
	}
	return false;

}

bool writecount::clear_peer(int peerid)
{
	int ret = peerids.erase(peerid);
	if(ret == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int writecount::size()
{
	return peerids.size();
}

#endif
#ifndef __IWRITER__
#define __IWRITER__

#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <mapreduce/definitions.hh>

using namespace std;

class iwriter
{
	private:
		char write_buf[BUF_SIZE];
		bool iswriting;
		int jobid;
		int networkidx;
		int numblock;
		int filefd;
		int vectorindex;

		vector<map<string, vector<string>*>*> themaps;

		int writingblock;
		int availableblock;
		int pos; // position in the write_buf
		map<string, vector<string>*>::iterator writing_it;
		string filepath;

		long currentsize;

	public:
		iwriter(int ajobid, int anetworkidx);
		~iwriter();

		int get_jobid();
		int get_numblock();
		void add_keyvalue(string key, string value);
		bool is_writing();
		bool write_to_disk(); // return true if write_to_disk should be stopped, return false if write should be continued
		void flush();
};

iwriter::iwriter(int ajobid, int anetworkidx)
{
	jobid = ajobid;
	iswriting = false;
	networkidx = anetworkidx;
	numblock = 0;
	writingblock = -1;
	availableblock = -1; // until this index, write should be progressed
	currentsize = 0;
	filefd = -1;
	vectorindex = -1;
	pos = -1;

	// generate first map
	themaps.push_back(new map<string, vector<string>*>);

	// we can increase the numblock because first write is guaranteed after the iwriter is initialized
	numblock++;

}

iwriter::~iwriter()
{
}

int iwriter::get_jobid()
{
	return jobid;
}
int iwriter::get_numblock()
{
	return numblock;
}

void iwriter::add_keyvalue(string key, string value)
{
	pair<map<string, vector<string>*>::iterator, bool> ret;

	ret = themaps.back()->insert(pair<string, vector<string>*>(key, NULL));

	if(ret.second) // first key element
	{
		ret.first->second = new vector<string>;
		ret.first->second->push_back(value);

		currentsize += key.length() + value.length() + 2; // +2 for two '\n' character
	}
	else // key already exist
	{
		ret.first->second->push_back(value);

		currentsize += value.length() + 1; // +1 for '\n' character
	}

	// determine the new size
	if(currentsize > IBLOCKSIZE)
	{
		// new map generated
		themaps.push_back(new map<string, vector<string>*>);

		// trigger writing
		availableblock++;

		if(!iswriting) // if file is not open for written when it is avilable
		{
			writingblock++;

			// prepare iterator and indices
			writing_it = themaps[writingblock]->begin();
			vectorindex = 0;
			pos = 0;

			// determine the path of file
			filepath = DHT_PATH;
			stringstream ss;
			ss << ".job_";
			ss << jobid;
			ss << "_";
			ss << networkidx;
			ss << "_";
			ss << writingblock;
			filepath.append(ss.str());

			// open write file
			filefd = open(filepath.c_str(), O_APPEND|O_WRONLY|O_CREAT, 0644);

			if(filefd < 0)
				cout<<"[iwriter]Opening write file failed"<<endl;

			iswriting = true;
		}

		numblock++;
		currentsize = 0;
	}
}

bool iwriter::is_writing()
{
	return iswriting;
}

bool iwriter::write_to_disk() // return true if write_to_disk should be stopped, return false if write should be continued
{
	while(pos < BUF_THRESHOLD && writing_it != themaps[writingblock]->end())
	{
		// append key and number of values if vectorindex is 0
		if(vectorindex == 0)
		{
			strcpy(write_buf + pos, writing_it->first.c_str());
			pos += writing_it->first.length();
			write_buf[pos] = '\n';
			pos++;

			stringstream ss;
			string message;
			ss << writing_it->second->size();
			message = ss.str();
			strcpy(write_buf + pos, message.c_str());
			pos += message.length();

			write_buf[pos] = '\n';
			pos++;
		}

		strcpy(write_buf + pos, (*writing_it->second)[vectorindex].c_str());
		pos += (*writing_it->second)[vectorindex].length();

		write_buf[pos] = '\n';
		pos++;

		vectorindex++;

		if((unsigned)vectorindex == writing_it->second->size())
		{
			writing_it++;
			vectorindex = 0;
		}
	}

	// write to the disk
	int ret = write(filefd, write_buf, pos);

	if(ret < 0)
	{
		cout<<"[iwriter]Writing to write file failed"<<endl;
	}

	pos = 0;

	// check if writing_it is themaps[writingblock]->end()
	if(writing_it == themaps[writingblock]->end()) // writing current block finished
	{
		// clear up current map, close open file and clear writing
		iswriting = false;
		close(filefd);
		filefd = -1;

		for(writing_it = themaps[writingblock]->begin(); writing_it != themaps[writingblock]->end(); writing_it++)
		{
			delete writing_it->second;
		}

		vectorindex = 0;
		pos = 0;

		// check whether this block was the last block
		if(writingblock == numblock - 1)
		{
			// delete element of themaps
			for(int i = 0; (unsigned)i < themaps.size(); i++)
			{
				delete themaps[i];
			}

			return true;
		}

		// check whether next block needs to be written
		if(writingblock < availableblock)
		{
			iswriting = true;
			writingblock++;

			// prepare iterator and indices
			writing_it = themaps[writingblock]->begin();
			vectorindex = 0;
			pos = 0;

			// determine the path of file
			filepath = DHT_PATH;
			stringstream ss;
			ss << ".job_";
			ss << jobid;
			ss << "_";
			ss << networkidx;
			ss << "_";
			ss << writingblock;
			filepath.append(ss.str());

			// open write file
			filefd = open(filepath.c_str(), O_APPEND|O_WRONLY|O_CREAT, 0644);

			if(filefd < 0)
				cout<<"[iwriter]Opening write file failed"<<endl;
		}
	}
	return false;
}

void iwriter::flush() // last call before iwriter is deleted. this is not an immediate flush()
{
	// let last block avilable for write
	availableblock++;

	if(!iswriting) // write was ongoing
	{
		iswriting = true;
		writingblock++;

		// prepare iterator and indices
		writing_it = themaps[writingblock]->begin();
		vectorindex = 0;
		pos = 0;

		// determine the path of file
		filepath = DHT_PATH;
		stringstream ss;
		ss << ".job_";
		ss << jobid;
		ss << "_";
		ss << networkidx;
		ss << "_";
		ss << writingblock;
		filepath.append(ss.str());

		// open write file
		filefd = open(filepath.c_str(), O_APPEND|O_WRONLY|O_CREAT, 0644);

		if(filefd < 0)
			cout<<"[iwriter]Opening write file failed"<<endl;
	}
}

#endif
#ifndef __IDISTRIBUTOR__
#define __IDISTRIBUTOR__

#include <iostream>
#include <sstream>
#include "writecount.hh"
#include "iwriter.hh"
#include <mapreduce/definitions.hh>
#include <common/msgaggregator.hh>

using namespace std;

class idistributor
{
	private:
		vector<filepeer*>* peers; // node lists
		vector<msgaggregator*> msgbuffers;
		vector<iwriter*>* iwriters;
		iwriter* thewriter;
		writecount* thecount;
		int jobid;
		int networkidx;

	public:
		idistributor(vector<filepeer*>* apeers, vector<iwriter*>* aniwriters, writecount* acount, int ajobid, int anetworkidx);
		~idistributor();

		void process_message(char* token, char * buf);
		void flush();
};

idistributor::idistributor(vector<filepeer*>* apeers, vector<iwriter*>* aniwriters, writecount* acount, int ajobid, int anetworkidx)
{
	peers = apeers;
	iwriters = aniwriters;
	thewriter = NULL;
	thecount = acount;
	jobid = ajobid;
	networkidx = anetworkidx;

	// set up initial configuration of message buffers
	for(int i = 0; (unsigned)i < peers->size(); i++)
	{
		stringstream ss;

		ss << "Iwrite ";
		ss << jobid;
		ss << "\n";

		if(i == networkidx)
		{
			msgbuffers.push_back(NULL);
		}
		else
		{
			msgbuffers.push_back(new msgaggregator((*peers)[i]->get_fd()));
			msgbuffers[i]->configure_initial(ss.str()); // Iwrite [job id] [node index]\n[file name]\n[record] ...
			msgbuffers[i]->set_msgbuf(&(*peers)[i]->msgbuf);
		}
	}
}

idistributor::~idistributor()
{
	// flush remaining messages
	flush();

	// clear up message buffers
	for(int i = 0; (unsigned)i < peers->size(); i++)
	{
		if(i != networkidx)
			delete msgbuffers[i];
	}
}

void idistributor::process_message(char* token, char* buf)
{
	string key;

	token = strtok(token,  " "); // tokenize first key

	while(token != NULL)
	{
		key = token;
		token = strtok(NULL, "\n"); // tokenize value

		memset(buf, 0, HASHLENGTH);
		strcpy(buf, key.c_str());
		uint32_t hashvalue = h(buf, HASHLENGTH);
		hashvalue = hashvalue%(peers->size());
		
		if(hashvalue == (unsigned)networkidx)
		{
			if(thewriter == NULL)
			{
				// write to the local iwriter
				for(int i = 0; (unsigned)i < iwriters->size(); i++)
				{
					if((*iwriters)[i]->get_jobid() == jobid)
					{
						thewriter = (*iwriters)[i];
						break;
					}
				}

				if(thewriter == NULL) // no iwriter with the job id
				{
					// create new iwriter
					thewriter = new iwriter(jobid, networkidx);
					iwriters->push_back(thewriter);
				}
			}

			// add key value pair to the iwriter
			thewriter->add_keyvalue(key, token);
				
			thecount->add_peer(hashvalue);
		}
		else
		{
			key.append(" ");
			key.append(token);
			msgbuffers[hashvalue]->add_record(key);
		}

		thecount->add_peer(hashvalue);
		
		token = strtok(NULL, " "); // next key
	}
}

void idistributor::flush()
{
	// flush all message aggregator
	for(int i = 0; (unsigned)i < peers->size(); i++)
	{
		if(i != networkidx)
			msgbuffers[i]->flush();
	}
}

#endif
#ifndef __IREADER__
#define __IREADER__

#include <iostream>
#include <fstream>
#include <sstream>
#include "filepeer.hh"
#include "file_connclient.hh"
#include <mapreduce/definitions.hh>

using namespace std;

class ireader
{
	private:
		int jobid;
		int pos;
		int numiblock;
		int networkidx;
		int bridgeid;
		int readingfile;
		int finishedcount;

		string filename;
		filepeer* dstpeer;
		file_connclient* dstclient;

		char write_buf[BUF_SIZE];

		vector<ifstream*> files;
		vector<string> filepaths;
		vector<string> currentkeys;
		vector<int> remaining_record;

		string currentkey;

		map<string, vector<int>*> keyorder;

		bridgetype dsttype; // PEER, DISK, CACHE or CLIENT

		int get_jobid();
		int get_numiblock();
		file_connclient* get_dstclient();
		filepeer* get_dstpeer();
		void set_bridgeid(int anid);

	public:
		ireader(int ajobid, int anumiblock, int anetworkidx, int abridgeid, bridgetype adsttype);
		void set_dstpeer(filepeer* apeer);
		void set_dstclient(file_connclient* aclient);
		bool read_idata();
};

ireader::ireader(int ajobid, int anumiblock, int anetworkidx, int abridgeid, bridgetype adsttype)
{
	jobid = ajobid;
	numiblock = anumiblock;
	networkidx = anetworkidx;
	dstclient = NULL;
	dstpeer = NULL;
	readingfile = -1;
	finishedcount = 0;
	bridgeid = abridgeid;
	dsttype = adsttype;
	pos = 0;

	// prepare reading idata from multiple file block according to jobid and numiblock
	for(int i = 0; i < numiblock; i++)
	{
		string filename;
		stringstream ss;
		ss << DHT_PATH;
		ss << ".job_";
		ss << jobid;
		ss << "_";
		ss << networkidx;
		ss << "_";
		ss << i;
		filename = ss.str();

		files.push_back(new ifstream(filename.c_str()));
		filepaths.push_back(filename);

		// read first key and remaining record of the file
		string key;
		string remainstr;
		int remain;
		getline(*files[i], key);
		getline(*files[i], remainstr);
		remain = atoi(remainstr.c_str());
		currentkeys.push_back(key);
		remaining_record.push_back(remain);

		// insert into the keyorder map
		pair<map<string, vector<int>*>::iterator, bool> ret;
		ret = keyorder.insert(pair<string, vector<int>*>(key, NULL));

		if(ret.second) // currently unique key
		{
			ret.first->second = new vector<int>;
			ret.first->second->push_back(i);
		}
		else // key already exist
		{
			// add file index to the vector
			ret.first->second->push_back(i);
		}
	}

	// determine the first current key
	currentkey = keyorder.begin()->first;
	readingfile = keyorder.begin()->second->back();
	keyorder.begin()->second->pop_back();
	if(keyorder.begin()->second->size() == 0)
	{
		delete keyorder.begin()->second;
		keyorder.erase(keyorder.begin());
	}
	
	// prepare write_buf
	if(dsttype == CLIENT)
	{
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf + pos, currentkey.c_str());
		pos += currentkey.length();
		write_buf[pos] = '\n';
		pos++;
	}
	else
	{
		string bidstring;
		stringstream ss;
		ss << bridgeid;
		bidstring = ss.str();
		
		memset(write_buf, 0, BUF_SIZE);

		strcpy(write_buf + pos, bidstring.c_str());
		pos += bidstring.length();
		write_buf[pos] = '\n';
		pos++;
		strcpy(write_buf + pos, currentkey.c_str());
		pos += currentkey.length();
		write_buf[pos] = '\n';
		pos++;
	}
}

bool ireader::read_idata()
{
	while(pos < BUF_THRESHOLD)
	{
		// read one record
		string record;

		getline(*files[readingfile], record);
		remaining_record[readingfile]--;

		if(pos + record.length() >= BUF_SIZE) // overflow if this record is added to the write_buf
		{
			if(dsttype == CLIENT)
			{
				// flush
				if(dstclient->msgbuf.size() > 1)
				{
					dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
					dstclient->msgbuf.push_back(new messagebuffer());
				}
				else
				{
					if(nbwritebuf(dstclient->get_fd(),
								write_buf, dstclient->msgbuf.back()) <= 0)
					{
						dstclient->msgbuf.push_back(new messagebuffer());
					}
				}

				// prepare another write_buf
				pos = 0;
				memset(write_buf, 0, BUF_SIZE);

			}
			else // PEER
			{
				// flush
				if(dstpeer->msgbuf.size() > 1)
				{
					dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
					dstpeer->msgbuf.push_back(new messagebuffer());
				}
				else
				{
					if(nbwritebuf(dstpeer->get_fd(),
								write_buf, dstpeer->msgbuf.back()) <= 0)
					{
						dstpeer->msgbuf.push_back(new messagebuffer());
					}
				}

				// prepare another write_buf
				pos = 0;
				string bidstring;
				stringstream ss;
				ss << bridgeid;
				bidstring = ss.str();

				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf + pos, bidstring.c_str());
				pos += bidstring.length();
				write_buf[pos] = '\n';
				pos++;
			}

			strcpy(write_buf + pos, record.c_str());
			pos += record.length();
			write_buf[pos] = '\n';
			pos++;

			return true;
		}

		strcpy(write_buf + pos, record.c_str());
		pos += record.length();
		write_buf[pos] = '\n';
		pos++;

		if(remaining_record[readingfile] == 0) // [another file for same key] or [next key]
		{
			// read next key of the file
			string key;
			int remain;
			getline(*files[readingfile], key);

			if(files[readingfile]->eof()) // no more key value for this file
			{
				// clear this file
				files[readingfile]->close();
				delete files[readingfile];
				finishedcount++;

				if(files.size() == (unsigned)finishedcount) // all key value are sent
				{
					if(dsttype == CLIENT)
					{
						// flush current record
						if(dstclient->msgbuf.size() > 1)
						{
							dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
							dstclient->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstclient->get_fd(),
										write_buf, dstclient->msgbuf.back()) <= 0)
							{
								dstclient->msgbuf.push_back(new messagebuffer());
							}
						}

						// notify target the end of idata(send zero packet twice)
						pos = 0;
						memset(write_buf, 0, BUF_SIZE);

						if(dstclient->msgbuf.size() > 1)
						{
							dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
							dstclient->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstclient->get_fd(),
										write_buf, dstclient->msgbuf.back()) <= 0)
							{
								dstclient->msgbuf.push_back(new messagebuffer());
							}
						}

						if(dstclient->msgbuf.size() > 1)
						{
							dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
							dstclient->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstclient->get_fd(),
										write_buf, dstclient->msgbuf.back()) <= 0)
							{
								dstclient->msgbuf.push_back(new messagebuffer());
							}
						}
					}
					else // PEER
					{
						// flush current record
						if(dstpeer->msgbuf.size() > 1)
						{
							dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
							dstpeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstpeer->get_fd(),
										write_buf, dstpeer->msgbuf.back()) <= 0)
							{
								dstpeer->msgbuf.push_back(new messagebuffer());
							}
						}

						// notify target the end of idata(send zero packet twice)
						pos = 0;
						string bidstring;
						stringstream ss;
						ss << bridgeid;
						bidstring = ss.str();

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf + pos, bidstring.c_str());
						pos += bidstring.length();
						write_buf[pos] = '\n';

						if(dstpeer->msgbuf.size() > 1)
						{
							dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
							dstpeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstpeer->get_fd(),
										write_buf, dstpeer->msgbuf.back()) <= 0)
							{
								dstpeer->msgbuf.push_back(new messagebuffer());
							}
						}

						if(dstpeer->msgbuf.size() > 1)
						{
							dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
							dstpeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(dstpeer->get_fd(),
										write_buf, dstpeer->msgbuf.back()) <= 0)
							{
								dstpeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}

					// return false to notify the end of idata to fileserver
					return false;
				}
			}
			else  // another key in this file
			{

				// register another key of this file to the map
				string remainstr;
				pair<map<string, vector<int>*>::iterator, bool> ret;
				ret = keyorder.insert(pair<string, vector<int>*>(key, NULL));

				if(ret.second) // currently unique key
				{
					ret.first->second = new vector<int>;
					ret.first->second->push_back(readingfile);
				}
				else // key already exist
				{
					// add file index to the vector
					ret.first->second->push_back(readingfile);
				}

				getline(*files[readingfile], remainstr);
				remain = atoi(remainstr.c_str());

				remaining_record[readingfile] = remain;
			}

			// determine next key(same or different from current key)
			if(currentkey == keyorder.begin()->first) // another file for same key
			{
				readingfile = keyorder.begin()->second->back();
				keyorder.begin()->second->pop_back();

				if(keyorder.begin()->second->size() == 0)
				{
					delete keyorder.begin()->second;
					keyorder.erase(keyorder.begin());
				}
			}
			else // different key
			{
				currentkey = keyorder.begin()->first;
				readingfile = keyorder.begin()->second->back();
				keyorder.begin()->second->pop_back();

				if(keyorder.begin()->second->size() == 0)
				{
					delete keyorder.begin()->second;
					keyorder.erase(keyorder.begin());
				}

				if(dsttype == CLIENT)
				{
					// flush 
					if(dstclient->msgbuf.size() > 1)
					{
						dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
						dstclient->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(dstclient->get_fd(),
									write_buf, dstclient->msgbuf.back()) <= 0)
						{
							dstclient->msgbuf.push_back(new messagebuffer());
						}
					}

					// prepare another write_buf
					pos = 0;
					memset(write_buf, 0, BUF_SIZE);

					// notify target end of key
					if(dstclient->msgbuf.size() > 1)
					{
						dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
						dstclient->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(dstclient->get_fd(),
									write_buf, dstclient->msgbuf.back()) <= 0)
						{
							dstclient->msgbuf.push_back(new messagebuffer());
						}
					}
				}
				else // PEER
				{
					// flush
					if(dstpeer->msgbuf.size() > 1)
					{
						dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
						dstpeer->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(dstpeer->get_fd(),
									write_buf, dstpeer->msgbuf.back()) <= 0)
						{
							dstpeer->msgbuf.push_back(new messagebuffer());
						}
					}

					// prepare another write_buf
					pos = 0;
					string bidstring;
					stringstream ss;
					ss << bridgeid;
					bidstring = ss.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf + pos, bidstring.c_str());
					pos += bidstring.length();
					write_buf[pos] = '\n';
					pos++;

					// notify target end of key
					if(dstpeer->msgbuf.size() > 1)
					{
						dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
						dstpeer->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(dstpeer->get_fd(),
									write_buf, dstpeer->msgbuf.back()) <= 0)
						{
							dstpeer->msgbuf.push_back(new messagebuffer());
						}
					}
				}

				// add key to the write_buf
				strcpy(write_buf + pos, currentkey.c_str());
				pos += currentkey.length();
				write_buf[pos] = '\n';
				pos++;

				return true;
			}
		}
	}

	// write to the target
	if(dsttype == CLIENT)
	{
		// flush
		if(dstclient->msgbuf.size() > 1)
		{
			dstclient->msgbuf.back()->set_buffer(write_buf, dstclient->get_fd());
			dstclient->msgbuf.push_back(new messagebuffer());
		}
		else
		{
			if(nbwritebuf(dstclient->get_fd(),
						write_buf, dstclient->msgbuf.back()) <= 0)
			{
				dstclient->msgbuf.push_back(new messagebuffer());
			}
		}

		// prepare another write_buf
		pos = 0;
		memset(write_buf, 0, BUF_SIZE);
	}
	else // PEER
	{
		// flush
		if(dstpeer->msgbuf.size() > 1)
		{
			dstpeer->msgbuf.back()->set_buffer(write_buf, dstpeer->get_fd());
			dstpeer->msgbuf.push_back(new messagebuffer());
		}
		else
		{
			if(nbwritebuf(dstpeer->get_fd(),
						write_buf, dstpeer->msgbuf.back()) <= 0)
			{
				dstpeer->msgbuf.push_back(new messagebuffer());
			}
		}

		// prepare another write_buf
		pos = 0;
		string bidstring;
		stringstream ss;
		ss << bridgeid;
		bidstring = ss.str();

		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf + pos, bidstring.c_str());
		pos += bidstring.length();
		write_buf[pos] = '\n';
		pos++;
	}

	return true;
}

file_connclient* ireader::get_dstclient()
{
	return dstclient;
}

filepeer* ireader::get_dstpeer()
{
	return dstpeer;
}

int ireader::get_jobid()
{
	return jobid;
}

int ireader::get_numiblock()
{
	return numiblock;
}

void ireader::set_bridgeid(int anid)
{
	bridgeid = anid;
}

void ireader::set_dstpeer(filepeer* apeer)
{
	dsttype = PEER;
	dstpeer = apeer;
}

void ireader::set_dstclient(file_connclient* aclient)
{
	dsttype = CLIENT;
	dstclient = aclient;
}

#endif
#include <iostream>
#include <vector>
#include <common/hash.hh>
#include <fstream>
#include <sstream>
#include <mapreduce/definitions.hh>

using namespace std;

int main(int argc, char** argv)
{
	// initialize data structures from nodelist.conf
	ifstream nodelistfile;
	vector<string> nodelist;
	string token;
	string filepath = LIB_PATH;
	char buf[BUF_SIZE];
	filepath.append("nodelist.conf");
	nodelistfile.open(filepath.c_str());

	nodelistfile>>token;
	while(!nodelistfile.eof())
	{
		nodelist.push_back(token);
		nodelistfile>>token;
	}

	// argv[1] name of input file which includes list of input files 
	// argv[2] name of output file which will match the input files and target address
	string inputfilename = MR_PATH;
	string outputfilename = MR_PATH;
	inputfilename.append(argv[1]);
	outputfilename.append(argv[2]);

	string filename;
	ifstream input;
	ofstream output;
	input.open(inputfilename.c_str());
	output.open(outputfilename.c_str());

	while(1)
	{
		getline(input, filename);
		if(input.eof())
		{
			break;
		}
		else
		{
			string address;
			stringstream ss;

			memset(buf, 0, BUF_SIZE);
			strcpy(buf, filename.c_str());
			uint32_t hashvalue = h(buf, HASHLENGTH);
			hashvalue = hashvalue%nodelist.size();
			output<<"scp "<<MR_PATH<<filename<<" "<<nodelist[hashvalue]<<":"<<DHT_PATH<<endl;
		}
	}
	input.close();
	output.close();
}
#include <iostream>
#include <vector>
#include <common/hash.hh>
#include <fstream>
#include <sstream>
#include <mapreduce/definitions.hh>

using namespace std;

int main(int argc, char** argv)
{
	char filename[BUF_SIZE];
	if(argc != 2)
	{
		cout<<"Usage: mrcat [input name]"<<endl;
		return 0;
	}

	// initialize data structures from nodelist.conf
	ifstream nodelistfile;
	vector<string> nodelist;
	string token;
	string filepath = LIB_PATH;
	filepath.append("nodelist.conf");
	nodelistfile.open(filepath.c_str());

	nodelistfile>>token;
	while(!nodelistfile.eof())
	{
		nodelist.push_back(token);
		nodelistfile>>token;
	}

	memset(filename, 0, BUF_SIZE);
	strcpy(filename, argv[1]);

	string outputfilename = MR_PATH;
	outputfilename.append("mrcat.sh");

	ofstream output;
	output.open(outputfilename.c_str());

	uint32_t hashvalue = h(filename, HASHLENGTH);
	hashvalue = hashvalue%nodelist.size();
	output<<"ssh "<<nodelist[hashvalue]<<" cat "<<DHT_PATH<<filename<<endl;
	output.close();
}
#ifndef __FILESERVER__
#define __FILESERVER__

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <mapreduce/definitions.hh>
#include <common/hash.hh>
#include <common/msgaggregator.hh>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/unistd.h>
#include <sys/time.h>
#include <netdb.h>
#include <arpa/inet.h>
#include "file_connclient.hh"
#include <orthrus/histogram.hh>
#include <orthrus/cache.hh>
#include <orthrus/dataentry.hh>
#include "messagebuffer.hh"
#include "filepeer.hh"
#include "filebridge.hh"
#include "idistributor.hh"
#include "ireader.hh"
#include "iwriter.hh"
#include "writecount.hh"
#include <sys/fcntl.h>

using namespace std;

class fileserver // each slave node has an object of fileserver
{
	private:
		int serverfd;
		int cacheserverfd;
		int ipcfd;
		int fbidclock;
		int networkidx;
		string localhostname;
		histogram* thehistogram;
		cache* thecache;
		vector<string> nodelist;
		vector<file_connclient*> clients;
		vector<filebridge*> bridges;
		vector<iwriter*> iwriters;
		vector<ireader*> ireaders;

		char read_buf[BUF_SIZE];
		char write_buf[BUF_SIZE];

	public:
		vector<filepeer*> peers;

		fileserver();
		filepeer* find_peer(string& address);
		filebridge* find_bridge(int id);
		int run_server(int port, string master_address);
		bool write_file(string fname, string& record);
		filebridge* find_Icachebridge(string inputname, int& bridgeindex);
};

fileserver::fileserver()
{
	networkidx = -1;
	serverfd = -1;
	cacheserverfd = -1;
	ipcfd = -1;
	fbidclock = 0; // fb id starts from 0
}

int fileserver::run_server(int port, string master_address)
{
	int buffersize = 8388608; // 8 MB buffer size

	// read hostname from hostname file
	ifstream hostfile;
	string word;
	string hostpath = DHT_PATH;
	hostpath.append("hostname");
	hostfile.open(hostpath.c_str());
	hostfile>>localhostname;

	hostfile.close();

	ifstream nodelistfile;
	string filepath = LIB_PATH;
	filepath.append("nodelist.conf");
	nodelistfile.open(filepath.c_str());

	nodelistfile >> word;
	while(!nodelistfile.eof())
	{
		nodelist.push_back(word);
		nodelistfile >> word;
	}
	nodelistfile.close();

	if (access(IPC_PATH, F_OK) == 0)
	{
		unlink(IPC_PATH);
	}

	// determine the network topology by reading node list information
	for(int i = 0; (unsigned) i < nodelist.size(); i++)
	{
		if(nodelist[i] == localhostname)
		{
			networkidx = i;
			break;
		}
	}

	// connect to cacheserver
	{
		cacheserverfd = -1;
		struct sockaddr_in serveraddr;
		struct hostent *hp;

		// SOCK_STREAM -> tcp
		cacheserverfd = socket(AF_INET, SOCK_STREAM, 0);
		if(cacheserverfd < 0)
		{
			cout<<"[fileserver:"<<networkidx<<"]Openning socket failed"<<endl;
			exit(1);
		}

		hp = gethostbyname(master_address.c_str());

		memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
		serveraddr.sin_family = AF_INET;
		memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
		serveraddr.sin_port = htons(port);

		while(connect(cacheserverfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
		{
			cout<<"[fileserver:"<<networkidx<<"]Cannot connect to the cache server. Retrying..."<<endl;

			//cout<<"\thost name: "<<nodelist[i]<<endl;
			usleep(100000);

			continue;
		}

		fcntl(cacheserverfd, F_SETFL, O_NONBLOCK);
		setsockopt(cacheserverfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
		setsockopt(cacheserverfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
	}

	// connect to other peer eclipse nodes
	for(int i = 0; i < networkidx; i++)
	{
		int clientfd = -1;
		struct sockaddr_in serveraddr;
		struct hostent *hp = NULL;

		// SOCK_STREAM -> tcp
		clientfd = socket(AF_INET, SOCK_STREAM, 0);
		if(clientfd < 0)
		{
			cout<<"[fileserver:"<<networkidx<<"]Openning socket failed"<<endl;
			exit(1);
		}

		hp = gethostbyname(nodelist[i].c_str());

		if(hp == NULL)
		{
			cout<<"[fileserver:"<<networkidx<<"]Cannot find host by host name"<<endl;
			return -1;
		}

		memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
		serveraddr.sin_family = AF_INET;
		memcpy(&serveraddr.sin_addr.s_addr, hp->h_addr, hp->h_length);
		serveraddr.sin_port = htons(port);

		while(connect(clientfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
		{
			cout<<"[fileserver:"<<networkidx<<"]Cannot connect to: "<<nodelist[i]<<endl;
			cout<<"Retrying..."<<endl;

			usleep(100000);

			//cout<<"\thost name: "<<nodelist[i]<<endl;
			continue;
		}

		// register the file peer
		peers.push_back(new filepeer(clientfd, nodelist[i]));

		// set the peer fd as nonblocking mode
		fcntl(clientfd, F_SETFL, O_NONBLOCK);
		setsockopt(clientfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
		setsockopt(clientfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
	}

	// socket open for listen
	int fd;
	int tmpfd = -1;
	struct sockaddr_in serveraddr;

	fd = socket(AF_INET, SOCK_STREAM, 0);
	if(fd < 0)
	{
		cout<<"[fileserver:"<<networkidx<<"]Socket opening failed"<<endl;
		exit(-1);
	}

	int valid = 1;
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &valid, sizeof(valid));

	// bind
	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons((unsigned short) port);

	if(bind(fd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		cout<<"[fileserver:"<<networkidx<<"]\033[0;31mBinding failed\033[0m"<<endl;
		exit(-1);
	}

	// listen
	if(listen(fd, BACKLOG) < 0)
	{
		cout<<"[master]Listening failed"<<endl;
		exit(-1);
		return -1;
	}

	// register the current node itself to the peer list
	peers.push_back(new filepeer(-1, localhostname));

	// register the other peers in order
	for(int i = networkidx + 1; (unsigned)i < nodelist.size(); i++)
	{
		peers.push_back(new filepeer(-1, nodelist[i]));
	}

	// listen connections from peers and complete the eclipse network
	for(int i = networkidx + 1; (unsigned)i < nodelist.size(); i++)
	{
		struct sockaddr_in connaddr;
		int addrlen = sizeof(connaddr);

		tmpfd = accept(fd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);
		if(tmpfd > 0)
		{
			char* haddrp = inet_ntoa(connaddr.sin_addr);
			string address = haddrp;

			for(int j = networkidx + 1; (unsigned)j < nodelist.size(); j++)
			{
				if(peers[j]->get_address() == address)
				{
					peers[j]->set_fd(tmpfd);
				}
			}

			// set the peer fd as nonblocking mode
			fcntl(tmpfd, F_SETFL, O_NONBLOCK);
			setsockopt(tmpfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
			setsockopt(tmpfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
		}
		else if(tmpfd < 0)// connection failed
		{
			// retry with same index
			i--;
			continue;
		}
		else
		{
			cout<<"connection closed......................."<<endl;
		}
	}

	// register the server fd
	serverfd = fd;

	cout<<"[fileserver:"<<networkidx<<"]Eclipse network successfully established(id="<<networkidx<<")"<<endl;

	// prepare AF_UNIX socket for the ipc with tasks
	struct sockaddr_un serveraddr2;
	ipcfd = socket(AF_UNIX, SOCK_STREAM, 0);

	if(ipcfd < 0)
	{
		cout<<"[fileserver:"<<networkidx<<"]AF_UNIX socket openning failed"<<endl;
		exit(-1);
	}

	// bind
	memset((void*) &serveraddr2, 0, sizeof(serveraddr2));
	serveraddr2.sun_family = AF_UNIX;
	strcpy(serveraddr2.sun_path, IPC_PATH);

	if(bind(ipcfd, (struct sockaddr *)&serveraddr2, SUN_LEN(&serveraddr2)) < 0)
	{
		cout<<"[fileserver:"<<networkidx<<"]\033[0;31mIPC Binding failed\033[0m"<<endl;
		exit(-1);
	}

	// listen
	if(listen(ipcfd, BACKLOG) < 0)
	{
		cout<<"[master]Listening failed"<<endl;
		exit(-1);
	}

	// set the server fd and ipc fd as nonblocking mode
	fcntl(ipcfd, F_SETFL, O_NONBLOCK);
	fcntl(serverfd, F_SETFL, O_NONBLOCK);
	setsockopt(ipcfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(ipcfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
	setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));

	tmpfd = -1;

	// initialize the histogram
	thehistogram = new histogram(nodelist.size(), NUMBIN);

	// initialize the local cache
	thecache = new cache(CACHESIZE);

struct timeval time_start;
struct timeval time_end;
gettimeofday(&time_start, NULL);
gettimeofday(&time_end, NULL);


	// start main loop which listen to connections and signals from clients and peers
	while(1)
	{
//gettimeofday(&time_start2, NULL);
		// local clients
		tmpfd = accept(ipcfd, NULL, NULL);
		if(tmpfd > 0) // new file client is connected
		{
			// create new clients
			clients.push_back(new file_connclient(tmpfd));

			clients.back()->thecount = new writecount();

			// set socket to be non-blocking socket to avoid deadlock
			fcntl(tmpfd, F_SETFL, O_NONBLOCK);
			setsockopt(tmpfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
			setsockopt(tmpfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
		}

//gettimeofday(&time_end2, NULL);
//timeslot1 += time_end2.tv_sec*1000000 + time_end2.tv_usec - time_start2.tv_sec*1000000 - time_start2.tv_usec;
//gettimeofday(&time_start2, NULL);

		for(int i = 0; (unsigned)i < clients.size(); i++)
		{
			int readbytes = -1;

			readbytes = nbread(clients[i]->get_fd(), read_buf);
			if(readbytes > 0)
			{
				char* token;
				string filename;

//				memset(write_buf, 0, BUF_SIZE);
//				strcpy(write_buf, read_buf);

				// The message is either: Rread(raw), Iread(intermediate), Iwrite(intermediate), Owrite(output)
				if(strncmp(read_buf, "Rread", 5) == 0)
				{
					string cachekey;
					string appname;
					int jobid;
					token = strtok(read_buf, " "); // <- "Rread"

					// determine the candidate eclipse node which will have the data
					string address;

					token = strtok(NULL, " "); // <- [app name]

					appname = token; // [app name]
					cachekey = token; // [app name]
					cachekey.append("_");

					token = strtok(NULL, " "); // <- job id
					jobid = atoi(token);

					token = strtok(NULL, " "); // <- file name
					cachekey.append(token); // <- cachekey: [app name]_[file name]
					filename = token;

					// determine the cache location of data
					memset(read_buf, 0, HASHLENGTH);
					strcpy(read_buf, filename.c_str());

					int index;
					uint32_t hashvalue = h(read_buf, HASHLENGTH);
					index = thehistogram->get_index(hashvalue);

					address = nodelist[index];

					filebridge* thebridge = new filebridge(fbidclock++);
					bridges.push_back(thebridge);

					if(index == networkidx) // local input data
					{
						// check whether the intermediate result is hit
						dataentry* theentry = thecache->lookup(cachekey);


						if(theentry == NULL) // when the intermediate result is not hit
						{
							cout<<"\033[0;31mLocal Icache miss\033[0m"<<endl;
							// send 0 packet to the client to notify that Icache is not hit
							memset(write_buf, 0, BUF_CUT);

							if(clients[i]->msgbuf.size() > 1)
							{
								clients[i]->msgbuf.back()->set_buffer(write_buf, clients[i]->get_fd());
								clients[i]->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(clients[i]->get_fd(), write_buf, clients[i]->msgbuf.back()) <= 0)
								{
									clients[i]->msgbuf.push_back(new messagebuffer());
								}
							}

							theentry = thecache->lookup(filename);

							if(theentry == NULL) // when data is not in cache
							{
								cout<<"\033[0;31mLocal Cache miss\033[0m"<<endl;

								// set an entry writer
								dataentry* newentry = new dataentry(filename, hashvalue);
								thecache->new_entry(newentry);
								entrywriter* thewriter = new entrywriter(newentry);

								// determine the DHT file location
								hashvalue = hashvalue%nodelist.size();

								address = nodelist[hashvalue];

								if((unsigned)networkidx == hashvalue)
								{
									// 1. read data from disk 
									// 2. store it in the cache 
									// 3. send it to client

									thebridge->set_srctype(DISK);
									thebridge->set_dsttype(CLIENT);
									thebridge->set_entrywriter(thewriter);
									thebridge->set_dstclient(clients[i]);

									thebridge->writebuffer = new msgaggregator(clients[i]->get_fd());
									thebridge->writebuffer->configure_initial("");
									thebridge->writebuffer->set_msgbuf(&clients[i]->msgbuf);
									thebridge->writebuffer->set_dwriter(thewriter);
									//thebridge->set_filename(filename);
									//thebridge->set_dataname(filename);
									//thebridge->set_dtype(RAW);

									// open read file and start sending data to client
									thebridge->open_readfile(filename);
								}
								else // remote DHT peer
								{
									// 1. request to the DHT peer (read from peer)
									// 2. store it in the cache
									// 3. send it to client

									thebridge->set_srctype(PEER);
									thebridge->set_dsttype(CLIENT);
									thebridge->set_entrywriter(thewriter);
									thebridge->set_dstclient(clients[i]);

									// thebridge->set_filename(filename);
									// thebridge->set_dataname(filename);
									// thebridge->set_dtype(RAW);

									// send message to the target peer
									string message;
									stringstream ss;
									ss << "RDread ";
									ss << filename;
									ss << " ";
									ss << thebridge->get_id();
									message = ss.str();

									memset(write_buf, 0, BUF_SIZE);
									strcpy(write_buf, message.c_str());

									//cout<<endl;
									//cout<<"write from: "<<localhostname<<endl;
									//cout<<"write to: "<<address<<endl;
									//cout<<"message: "<<write_buf<<endl;
									//cout<<endl;

									filepeer* thepeer = find_peer(address);

									if(thepeer->msgbuf.size() > 1)
									{
										thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
										thepeer->msgbuf.push_back(new messagebuffer());
									}
									else
									{
										if(nbwritebuf(thepeer->get_fd(),
													write_buf, thepeer->msgbuf.back()) <= 0)
										{
											thepeer->msgbuf.push_back(new messagebuffer());
										}
									}
								}
							}
							else // when the data is in the cache
							{
								if(theentry->is_being_written())
								{
									// determine the DHT file location
									hashvalue = hashvalue%nodelist.size();

									address = nodelist[hashvalue];

									if((unsigned)networkidx == hashvalue)
									{
										// 1. read data from disk 
										// 2. store it in the cache 
										// 3. send it to client

										thebridge->set_srctype(DISK);
										thebridge->set_dsttype(CLIENT);
										thebridge->set_dstclient(clients[i]);

										thebridge->writebuffer = new msgaggregator(clients[i]->get_fd());
										thebridge->writebuffer->configure_initial("");
										thebridge->writebuffer->set_msgbuf(&clients[i]->msgbuf);
										//thebridge->set_filename(filename);
										//thebridge->set_dataname(filename);
										//thebridge->set_dtype(RAW);

										// open read file and start sending data to client
										thebridge->open_readfile(filename);
									}
									else // remote DHT peer
									{
										// 1. request to the DHT peer (read from peer)
										// 2. store it in the cache
										// 3. send it to client

										thebridge->set_srctype(PEER);
										thebridge->set_dsttype(CLIENT);
										thebridge->set_dstclient(clients[i]);

										// thebridge->set_filename(filename);
										// thebridge->set_dataname(filename);
										// thebridge->set_dtype(RAW);

										// send message to the target peer
										string message;
										stringstream ss;
										ss << "RDread ";
										ss << filename;
										ss << " ";
										ss << thebridge->get_id();
										message = ss.str();

										memset(write_buf, 0, BUF_SIZE);
										strcpy(write_buf, message.c_str());

										//cout<<endl;
										//cout<<"write from: "<<localhostname<<endl;
										//cout<<"write to: "<<address<<endl;
										//cout<<"message: "<<write_buf<<endl;
										//cout<<endl;

										filepeer* thepeer = find_peer(address);

										if(thepeer->msgbuf.size() > 1)
										{
											thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
											thepeer->msgbuf.push_back(new messagebuffer());
										}
										else
										{
											if(nbwritebuf(thepeer->get_fd(),
														write_buf, thepeer->msgbuf.back()) <= 0)
											{
												thepeer->msgbuf.push_back(new messagebuffer());
											}
										}
									}
								}
								else
								{
									// 1. read from cache
									// 2. and send it to client

									// set a entry reader
									entryreader* thereader = new entryreader(theentry);

									cout<<"\033[0;32m["<<networkidx<<"]Local Cache hit\033[0m"<<endl;

									thebridge->set_srctype(CACHE);
									thebridge->set_dsttype(CLIENT);
									thebridge->set_entryreader(thereader);
									thebridge->set_dstclient(clients[i]);
									//thebridge->set_filename(filename);
									//thebridge->set_dataname(filename);
									//thebridge->set_dtype(RAW);
								}
							}
						}
						else // intermediate result hit
						{
							cout<<"\033[0;32m["<<networkidx<<"]Local Icache hit\033[0m"<<endl;
//cout<<"[fileserver:"<<networkidx<<"]Cachekey hit: "<<cachekey<<endl;
							// send 1 packet to the client to notify that Icache is hit
							memset(write_buf, 0, BUF_CUT);
							write_buf[0] = 1;

							if(clients[i]->msgbuf.size() > 1)
							{
								clients[i]->msgbuf.back()->set_buffer(write_buf, clients[i]->get_fd());
								clients[i]->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(clients[i]->get_fd(), write_buf, clients[i]->msgbuf.back()) <= 0)
								{
									clients[i]->msgbuf.push_back(new messagebuffer());
								}
							}

							// set an entry reader and idistributor
							entryreader* thereader = new entryreader(theentry);
							idistributor* thedistributor = new idistributor((&peers), (&iwriters), clients[i]->thecount, jobid, networkidx);

							thebridge->set_srctype(CACHE);
							thebridge->set_dsttype(DISTRIBUTE);
							thebridge->set_dstclient(clients[i]); // to notify the end of distribution
							thebridge->set_distributor(thedistributor);
							thebridge->set_entryreader(thereader);
						}

						/*
						// check whether the input is hit
						dataentry* theentry = thecache->lookup(filename);

						if(theentry == NULL) // when data is not in cache
						{
							cout<<"\033[0;31mCache miss\033[0m"<<endl;

							// set a entry writer
							dataentry* newentry = new dataentry(filename, hashvalue);
							thecache->new_entry(newentry);
							entrywriter* thewriter = new entrywriter(newentry);

							// determine the DHT file location
							hashvalue = hashvalue%nodelist.size();

							address = nodelist[hashvalue];

							if(localhostname == address)
							{
								// 1. read data from disk 
								// 2. store it in the cache 
								// 3. send it to client

								thebridge->set_srctype(DISK);
								thebridge->set_dsttype(CLIENT);
								thebridge->set_entrywriter(thewriter);
								thebridge->set_dstclient(clients[i]);

								thebridge->writebuffer = new msgaggregator(clients[i]->get_fd());
								thebridge->writebuffer->configure_initial("");
								thebridge->writebuffer->set_msgbuf(&clients[i]->msgbuf);
								thebridge->writebuffer->set_dwriter(thewriter);
								//thebridge->set_filename(filename);
								//thebridge->set_dataname(filename);
								//thebridge->set_dtype(RAW);

								// open read file and start sending data to client
								thebridge->open_readfile(filename);
							}
							else // remote DHT peer
							{
								// 1. request to the DHT peer (read from peer)
								// 2. store it in the cache
								// 3. send it to client

								thebridge->set_srctype(PEER);
								thebridge->set_dsttype(CLIENT);
								thebridge->set_entrywriter(thewriter);
								thebridge->set_dstclient(clients[i]);

								// thebridge->set_filename(filename);
								// thebridge->set_dataname(filename);
								// thebridge->set_dtype(RAW);

								// send message to the target peer
								string message;
								stringstream ss;
								ss << "RDread ";
								ss << filename;
								ss << " ";
								ss << thebridge->get_id();
								message = ss.str();

								memset(write_buf, 0, BUF_SIZE);
								strcpy(write_buf, message.c_str());

								//cout<<endl;
								//cout<<"write from: "<<localhostname<<endl;
								//cout<<"write to: "<<address<<endl;
								//cout<<"message: "<<write_buf<<endl;
								//cout<<endl;

								filepeer* thepeer = find_peer(address);

								if(thepeer->msgbuf.size() > 1)
								{
									thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
									thepeer->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									if(nbwritebuf(thepeer->get_fd(),
												write_buf, thepeer->msgbuf.back()) <= 0)
									{
										thepeer->msgbuf.push_back(new messagebuffer());
									}
								}
							}
						}
						else // when the data is in the cache
						{
							// 1. read from cache
							// 2. and send it to client

							// set a entry reader
							entryreader* thereader = new entryreader(theentry);

							cout<<"\033[0;32mCache hit\033[0m"<<endl;

							thebridge->set_srctype(CACHE);
							thebridge->set_dsttype(CLIENT);
							thebridge->set_entryreader(thereader);
							thebridge->set_dstclient(clients[i]);
							//thebridge->set_filename(filename);
							//thebridge->set_dataname(filename);
							//thebridge->set_dtype(RAW);
						}
						*/
					}
					else // remote cache peer
					{
						// 1. request to the remote cache peer
						// 2. send it to client

						thebridge->set_srctype(PEER);
						thebridge->set_dsttype(CLIENT);
						thebridge->set_dstclient(clients[i]);
						//thebridge->set_filename(filename);
						//thebridge->set_dataname(filename);
						//thebridge->set_dtype(RAW);

						// send message to the target peer
						string message;
						stringstream ss;
						ss << "Ilook ";
						ss << appname;
						ss << " ";
						ss << filename;
						ss << " ";
						ss << jobid;
						ss << " ";
						ss << thebridge->get_id();
						message = ss.str();

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						//cout<<endl;
						//cout<<"write from: "<<localhostname<<endl;
						//cout<<"write to: "<<address<<endl;
						//cout<<"message: "<<write_buf<<endl;
						//cout<<endl;

						filepeer* thepeer = find_peer(address);

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}
				}
				else if(strncmp(read_buf, "Iread", 5) == 0)
				{
//cout<<"[fileserver:"<<networkidx<<"]Iread message: "<<read_buf<<endl;
					int jobid;
					int peerid;
					int numiblock;
					token = strtok(read_buf, " \n"); // <- "Iread"

					token = strtok(NULL, " "); // <- [job id]
					jobid = atoi(token);

					token = strtok(NULL, " "); // <- [peer id]
					peerid = atoi(token);

					token = strtok(NULL, " "); // <- numiblock
					numiblock = atoi(token);

					if(peerid == networkidx) // local
					{
						// generate ireader and link to the client
						ireader* thereader = new ireader(jobid, numiblock, peerid, 0, CLIENT);
						thereader->set_dstclient(clients[i]);
						ireaders.push_back(thereader);
					}
					else // remote
					{
						// send iwriter request to the target peer
						filebridge* thebridge = new filebridge(fbidclock++);
						bridges.push_back(thebridge);

						thebridge->set_srctype(PEER);
						thebridge->set_dsttype(CLIENT);
						thebridge->set_dstclient(clients[i]);
						//thebridge->set_filename(filename);
						//thebridge->set_dataname(filename);
						//thebridge->set_dtype(INTERMEDIATE);

						// send message to the target peer
						string message;
						stringstream ss;
						ss << "Iread ";
						ss << jobid;
						ss << " ";
						ss << numiblock;
						ss << " ";
						ss << thebridge->get_id();
						message = ss.str();

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						//cout<<endl;
						//cout<<"write from: "<<localhostname<<endl;
						//cout<<"write to: "<<address<<endl;
						//cout<<"message: "<<write_buf<<endl;
						//cout<<endl;

						filepeer* thepeer = peers[peerid];

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							//cout<<endl;
							//cout<<"from: "<<localhostname<<endl;
							//cout<<"to: "<<thepeer->get_address()<<endl;
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
						//nbwrite(find_peer(address)->get_fd(), write_buf);
					}
				}
				else if(strncmp(read_buf, "ICwrite", 6) == 0) // "ICwrite" message from client
				{
					string cachekey;
					string appname;
					string inputpath;
					int jobid;

					token = strtok(read_buf, " "); // <- "ICwrite"
					token = strtok(NULL, "_"); // <- ".job"
					token = strtok(NULL, "_\n"); // <- job id
					jobid = atoi(token);

					token = strtok(NULL, " "); // <- [app name]
					appname = token; // <- [app name]
					cachekey = token; // <- [app name]
					cachekey.append("_");
					token = strtok(NULL, "\n"); // <- [input file path]
					inputpath = token;
					cachekey.append(inputpath);

					token = strtok(NULL, ""); // token -> rest of message

//cout<<"ICwrite sent"<<endl;
//cout<<"cachekey: "<<cachekey<<endl;
//cout<<"inputpath: "<<inputpath<<endl;
//cout<<"jobdirpath: "<<jobdirpath<<endl;

					// cache the 'token'
					entrywriter* thewriter = clients[i]->get_Icachewriter();
					filepeer* thepeer = clients[i]->get_Itargetpeer();

					if(thewriter != NULL) // target is local and writing is ongoing
					{
//cout<<"[fileserver:"<<networkidx<<"]Cachekey of written data: "<<cachekey<<endl;
						thewriter->write_record(token);
					}
					else if(thepeer != NULL) // target is remote peer and writing is ongoing
					{
						string message = "Icache ";
						message.append(appname);
						message.append(" ");
						message.append(inputpath);
						message.append("\n");
						message.append(token);

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());
//cout<<"[fileserver:"<<networkidx<<"]Sending Icache message: "<<write_buf<<endl;

						// send token to the remote cache to store it
						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}
					else // target should be determined
					{
						// determine the target cache of data
						string address;
						memset(write_buf, 0, HASHLENGTH);
						strcpy(write_buf, inputpath.c_str());

						int index;
						uint32_t hashvalue = h(write_buf, HASHLENGTH);
						index = thehistogram->get_index(hashvalue);

						address = nodelist[index];

						if(index == networkidx) // local target cache
						{
							// set a entry writer
//cout<<"[fileserver:"<<networkidx<<"]Cachekey of new data entry: "<<cachekey<<endl;
							dataentry* newentry = new dataentry(cachekey, hashvalue);
							thecache->new_entry(newentry);
							entrywriter* thewriter = new entrywriter(newentry);

							clients[i]->set_Icachewriter(thewriter);

							thewriter->write_record(token);
						}
						else // remote peer cache
						{
							thepeer = peers[index];
							clients[i]->set_Itargetpeer(thepeer);
							clients[i]->set_Icachekey(cachekey);

							string message = "Icache ";
							message.append(appname);
							message.append(" ");
							message.append(inputpath);
							message.append("\n");
							message.append(token);

							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());
//cout<<"[fileserver:"<<networkidx<<"]Sending Icache message: "<<write_buf<<endl;

							// send token to the remote cache to store it
							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}
						}
					}

					// find or allocate idistributor
					if(clients[i]->thedistributor == NULL)
					{
						clients[i]->thedistributor = new idistributor((&peers), (&iwriters), clients[i]->thecount, jobid, networkidx);
						clients[i]->thedistributor->process_message(token, write_buf);
					}
					else
					{
						// process the intermediate data
						clients[i]->thedistributor->process_message(token, write_buf);
					}

					/*
					if(localhostname == address)
					{
						// open write file to write data to disk
						write_file(filename, record);
						//filebridge* thebridge = new filebridge(fbidclock++);
						//thebridge->open_writefile(filename);
						//thebridge->write_record(record, write_buf);

						//delete thebridge;
					}
					else // distant
					{
						// bridges.push_back(thebridge);

						// set up the bridge
						// thebridge->set_srctype(PEER); // source of Ewrite
						// thebridge->set_dsttype(CLIENT); // destination of Ewrite
						// thebridge->set_dstclient(NULL);
						// thebridge->set_dtype(INTERMEDIATE);
						// thebridge->set_writeid(writeid);

						// send message along with the record to the target peer
						string message;
						stringstream ss;
						ss << "write ";
						ss << filename;
						ss << " ";
						ss << record;
						message = ss.str();

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						//cout<<endl;
						//cout<<"write from: "<<localhostname<<endl;
						//cout<<"write to: "<<address<<endl;
						//cout<<"message: "<<write_buf<<endl;
						//cout<<endl;

						filepeer* thepeer = peers[hashvalue];

						if(clients[i]->thecount == NULL)
							cout<<"[fileserver]The write id is not set before the write request"<<endl;

						clients[i]->thecount->add_peer(hashvalue);

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							//cout<<endl;
							//cout<<"from: "<<localhostname<<endl;
							//cout<<"to: "<<thepeer->get_address()<<endl;
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}
					*/
				}
				else if(strncmp(read_buf, "Iwrite", 6) == 0) // "Iwrite" message from client
				{
					int jobid;

					// extract job id
					token = strtok(read_buf, " "); // <- "Iwrite"
					token = strtok(NULL, "_"); // <- ".job"
					token = strtok(NULL, "_\n"); // <- job id
					jobid = atoi(token);
					token += strlen(token) + 2; // jump "_" and " "

					// find or allocate idistributor
					if(clients[i]->thedistributor == NULL)
					{
						clients[i]->thedistributor = new idistributor((&peers), (&iwriters), clients[i]->thecount, jobid, networkidx);
						clients[i]->thedistributor->process_message(token, write_buf);
					}
					else
					{
						// process the intermediate data
						clients[i]->thedistributor->process_message(token, write_buf);
					}
				}
				else if(strncmp(read_buf, "Owrite", 6) == 0)
				{
					string record;

					// pre-copy the contents of read_buf to write_buf
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, read_buf);

					token = strtok(read_buf, " "); // <- "Owrite"

					token = strtok(NULL, "\n"); // <- file name
					filename = token;

					token += strlen(token) + 1; // <- token: writing contents
					record = token;

					// determine the target peer node
					memset(read_buf, 0, HASHLENGTH);
					strcpy(read_buf, filename.c_str());

					uint32_t hashvalue = h(read_buf, HASHLENGTH);
					hashvalue = hashvalue%nodelist.size();

					if(hashvalue == (unsigned)networkidx) // write to local disk
					{
						// write to the disk
						write_file(filename, record);
					}
					else // remote peer
					{
						// write to the peer with pre-prepared write_buf
						filepeer* thepeer = peers[hashvalue];

						if(clients[i]->thecount == NULL)
							cout<<"[fileserver:"<<networkidx<<"]The write id is not set before the write request"<<endl;


						// write to the peer
						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}
				}
				else if(strncmp(read_buf, "MWwrite", 7) == 0)
				{
//cout<<"MWwrite"<<endl;
					// flush and clear the distributor
					if(clients[i]->thedistributor != NULL)
					{
						delete clients[i]->thedistributor;
						clients[i]->thedistributor = NULL;
					}

					// send intermediate write peer list 
					stringstream ss;
					string message;

					writecount* thecount = clients[i]->thecount;
					stringstream ss1;
					ss1 << "Wack ";
					ss1 << clients[i]->get_fd();
					message = ss1.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());

					if(thecount->size() > 0)
					{
						set<int>::iterator it = thecount->peerids.begin();
						ss << *it;

						if(*it != networkidx)
						{
							if(peers[*it]->msgbuf.size() > 1)
							{
								peers[*it]->msgbuf.back()->set_buffer(write_buf, peers[*it]->get_fd());
								peers[*it]->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(peers[*it]->get_fd(),
											write_buf, peers[*it]->msgbuf.back()) <= 0)
								{
									peers[*it]->msgbuf.push_back(new messagebuffer());
								}
							}
						}

						it++;

						for(/* nothing */; it != thecount->peerids.end(); it++)
						{
							ss << " ";
							ss << *it;

							if(*it != networkidx)
							{
								if(peers[*it]->msgbuf.size() > 1)
								{
									peers[*it]->msgbuf.back()->set_buffer(write_buf, peers[*it]->get_fd());
									peers[*it]->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									if(nbwritebuf(peers[*it]->get_fd(),
												write_buf, peers[*it]->msgbuf.back()) <= 0)
									{
										peers[*it]->msgbuf.push_back(new messagebuffer());
									}
								}
							}
						}
						message = ss.str();

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						if(clients[i]->msgbuf.size() > 1)
						{
							clients[i]->msgbuf.back()->set_buffer(write_buf, clients[i]->get_fd());
							clients[i]->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(clients[i]->get_fd(), write_buf, clients[i]->msgbuf.back()) <= 0)
							{
								clients[i]->msgbuf.push_back(new messagebuffer());
							}
						}
					}
					else
					{
						// send null packet for empty peer list
						memset(write_buf, 0, BUF_SIZE);

						if(clients[i]->msgbuf.size() > 1)
						{
							clients[i]->msgbuf.back()->set_buffer(write_buf, clients[i]->get_fd());
							clients[i]->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(clients[i]->get_fd(), write_buf, clients[i]->msgbuf.back()) <= 0)
							{
								clients[i]->msgbuf.push_back(new messagebuffer());
							}
						}
					}


					thecount->clear_peer(networkidx);


					// send EIcache to the target peer
					entrywriter* thewriter = clients[i]->get_Icachewriter();
					filepeer* thepeer = clients[i]->get_Itargetpeer();
					if(thepeer != NULL)
					{
						// send End of Icache message "EIcache"
						string message = "EIcache ";
						message.append(clients[i]->get_Icachekey());

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
						clients[i]->set_Itargetpeer(NULL);
					}
					else if(thewriter != NULL)
					{
						thewriter->complete();

						delete thewriter;
						clients[i]->set_Icachewriter(NULL);
					}

					if(thecount->size() == 0)
					{
						// clear the count
						delete thecount;
						clients[i]->thecount = NULL;

						// close the client
						close(clients[i]->get_fd());

						delete clients[i];
						clients.erase(clients.begin()+i);
						i--;
					}
				}
				else if(strncmp(read_buf, "RWwrite", 7) == 0)
				{
					// clear the count
					delete clients[i]->thecount;
					clients[i]->thecount = NULL;

					// close the client
					close(clients[i]->get_fd());

					delete clients[i];
					clients.erase(clients.begin()+i);
					i--;
				}
				else
				{
					cout<<"[fileserver:"<<networkidx<<"]Debugging: Unknown message";
				}

				// enable loop acceleration
				//i--;
				//continue;
			}
		}
//gettimeofday(&time_end2, NULL);
//timeslot2 += time_end2.tv_sec*1000000 + time_end2.tv_usec - time_start2.tv_sec*1000000 - time_start2.tv_usec;
//gettimeofday(&time_start2, NULL);

		// receives read/write request or data stream
		for(int i = 0; (unsigned)i < peers.size(); i++)
		{
			// pass and continue when the conneciton to the peer have been closed
			if(peers[i]->get_fd() < 0)
				continue;

			int readbytes;
			readbytes = nbread(peers[i]->get_fd(), read_buf);

			if(readbytes > 0)
			{
				if(strncmp(read_buf, "Ilook", 5) == 0) // read request to cache(Icache)
				{
//cout<<"[fileserver:"<<networkidx<<"]Ilook message: "<<read_buf<<endl;
//cout<<"[fileserver:"<<networkidx<<"]network idx: "<<networkidx<<endl;
					char* token;
					string cachekey;
					string appname;
					string filename;
					int jobid;
					string bridgeid;
					int dstid; // same as bridgeid

					token = strtok(read_buf, " "); // <- "Ilook"

					token = strtok(NULL, " "); // <- app name
					appname = token;
					cachekey = token;
					cachekey.append("_");

					token = strtok(NULL, " "); // <- file name
					filename = token;
					cachekey.append(filename);

					token = strtok(NULL, " "); // <- job id
					jobid = atoi(token);

					token = strtok(NULL, " "); // <- bridge id
					bridgeid = token;
					dstid = atoi(token);

					// TODO: restore the remote Icache!!!
					//dataentry* theentry = thecache->lookup(cachekey);
					dataentry* theentry = NULL;

					if(theentry == NULL) // when the intermediate result is not hit
					{
						cout<<"\033[0;31mRemote Icache miss\033[0m"<<endl;
//cout<<"[fileserver:"<<networkidx<<"]Cache key not hit after receiving Ilook: "<<cachekey<<endl;

						// send "Imiss"
						string message = "Imiss ";
						message.append(bridgeid);

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						if(peers[i]->msgbuf.size() > 1)
						{
							peers[i]->msgbuf.back()->set_buffer(write_buf, peers[i]->get_fd());
							peers[i]->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(peers[i]->get_fd(),
										write_buf, peers[i]->msgbuf.back()) <= 0)
							{
								peers[i]->msgbuf.push_back(new messagebuffer());
							}
						}

						theentry = thecache->lookup(filename);

						if(theentry == NULL) // raw input data is not hit
						{
							cout<<"\033[0;31mRemote Cache miss\033[0m"<<endl;

							// determine the hash value
							memset(write_buf, 0, HASHLENGTH);
							strcpy(write_buf, filename.c_str());
							uint32_t hashvalue = h(write_buf, HASHLENGTH);

							// set an entry writer
							dataentry* newentry = new dataentry(filename, hashvalue);
							thecache->new_entry(newentry);
							entrywriter* thewriter = new entrywriter(newentry);

							// determine the DHT file location
							int index = hashvalue%nodelist.size();

							string address = nodelist[index];

							if(networkidx == index) // local DHT file
							{
								filebridge* thebridge = new filebridge(fbidclock++);
								bridges.push_back(thebridge);

								thebridge->set_srctype(DISK);
								thebridge->set_dsttype(PEER);
								thebridge->set_entrywriter(thewriter);
								thebridge->set_dstpeer(peers[i]);
								thebridge->set_dstid(dstid);

								thebridge->writebuffer = new msgaggregator(peers[i]->get_fd());
								bridgeid.append("\n");
								thebridge->writebuffer->configure_initial(bridgeid);
								thebridge->writebuffer->set_msgbuf(&peers[i]->msgbuf);
								thebridge->writebuffer->set_dwriter(thewriter);

								// open read file and start sending data to peer
								thebridge->open_readfile(filename);
							}
							else // remote DHT file
							{
								filebridge* thebridge = new filebridge(fbidclock++);
								bridges.push_back(thebridge);

								thebridge->set_srctype(PEER);
								thebridge->set_dsttype(PEER);
								thebridge->set_entrywriter(thewriter);
								thebridge->set_dstpeer(peers[i]);
								thebridge->set_dstid(dstid);

								// send message to the target peer
								string message;
								stringstream ss;
								ss << "RDread ";
								ss << filename;
								ss << " ";
								ss << thebridge->get_id();
								message = ss.str();

								memset(write_buf, 0, BUF_SIZE);
								strcpy(write_buf, message.c_str());

								filepeer* thepeer = peers[index];

								if(thepeer->msgbuf.size() > 1)
								{
									thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
									thepeer->msgbuf.push_back(new messagebuffer());
									//continue; // escape the acceleration loop
								}
								else
								{
									if(nbwritebuf(thepeer->get_fd(),
												write_buf, thepeer->msgbuf.back()) <= 0)
									{
										thepeer->msgbuf.push_back(new messagebuffer());
										//continue; // escape the acceleration loop
									}
								}
							}
						}
						else // raw input data is hit
						{
							if(theentry->is_being_written())
							{
								cout<<"\033[0;31mRemote Cache miss\033[0m"<<endl;

								// determine the hash value
								memset(write_buf, 0, HASHLENGTH);
								strcpy(write_buf, filename.c_str());
								uint32_t hashvalue = h(write_buf, HASHLENGTH);

								// determine the DHT file location
								int index = hashvalue%nodelist.size();

								string address = nodelist[index];

								if(networkidx == index) // local DHT file
								{
									filebridge* thebridge = new filebridge(fbidclock++);
									bridges.push_back(thebridge);

									thebridge->set_srctype(DISK);
									thebridge->set_dsttype(PEER);
									thebridge->set_dstpeer(peers[i]);
									thebridge->set_dstid(dstid);

									thebridge->writebuffer = new msgaggregator(peers[i]->get_fd());
									bridgeid.append("\n");
									thebridge->writebuffer->configure_initial(bridgeid);
									thebridge->writebuffer->set_msgbuf(&peers[i]->msgbuf);

									// open read file and start sending data to peer
									thebridge->open_readfile(filename);
								}
								else // remote DHT file
								{
									filebridge* thebridge = new filebridge(fbidclock++);
									bridges.push_back(thebridge);

									thebridge->set_srctype(PEER);
									thebridge->set_dsttype(PEER);
									thebridge->set_dstpeer(peers[i]);
									thebridge->set_dstid(dstid);

									// send message to the target peer
									string message;
									stringstream ss;
									ss << "RDread ";
									ss << filename;
									ss << " ";
									ss << thebridge->get_id();
									message = ss.str();

									memset(write_buf, 0, BUF_SIZE);
									strcpy(write_buf, message.c_str());

									filepeer* thepeer = peers[index];

									if(thepeer->msgbuf.size() > 1)
									{
										thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
										thepeer->msgbuf.push_back(new messagebuffer());
										//continue; // escape the acceleration loop
									}
									else
									{
										if(nbwritebuf(thepeer->get_fd(),
													write_buf, thepeer->msgbuf.back()) <= 0)
										{
											thepeer->msgbuf.push_back(new messagebuffer());
											//continue; // escape the acceleration loop
										}
									}
								}
							}
							else
							{
								cout<<"\033[0;32m["<<networkidx<<"]Remote Cache hit\033[0m"<<endl;

								// prepare the read stream from cache
								entryreader* thereader = new entryreader(theentry);

								filebridge* thebridge = new filebridge(fbidclock++);
								bridges.push_back(thebridge);

								thebridge->set_srctype(CACHE);
								thebridge->set_dsttype(PEER);
								thebridge->set_entryreader(thereader);
								thebridge->set_dstpeer(peers[i]);
								thebridge->set_dstid(dstid);
							}
						}
					}
					else // when the intermediate result is hit
					{
//cout<<"[fileserver:"<<networkidx<<"]Cache key hit after receiving Ilook: "<<cachekey<<endl;
						// send 'Ihit'
						string message = "Ihit ";
						message.append(bridgeid);

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						if(peers[i]->msgbuf.size() > 1)
						{
							peers[i]->msgbuf.back()->set_buffer(write_buf, peers[i]->get_fd());
							peers[i]->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(peers[i]->get_fd(),
										write_buf, peers[i]->msgbuf.back()) <= 0)
							{
								peers[i]->msgbuf.push_back(new messagebuffer());
							}
						}

						// prepare the distribution of intermediate result
						entryreader* thereader = new entryreader(theentry);

						filebridge* thebridge = new filebridge(fbidclock++);
						bridges.push_back(thebridge);

						thebridge->set_srctype(CACHE);
						thebridge->set_dsttype(DISTRIBUTE);
						thebridge->set_entryreader(thereader);
						thebridge->set_dstpeer(peers[i]); // to notify the end of distribution

						thebridge->thecount = new writecount();
						idistributor* thedistributor = new idistributor((&peers), (&iwriters), thebridge->thecount, jobid, networkidx);
						thebridge->set_distributor(thedistributor);
					}
				}
				else if(strncmp(read_buf, "RDread", 6) == 0) // read request to disk
				{
					string address;
					string filename;
					int dstid;
					string sdstid;
					char* token;

					token = strtok(read_buf, " "); // <- message type
					token = strtok(NULL, " "); // <- filename
					filename = token;
					token = strtok(NULL, " "); // <- dstid
					sdstid = token;
					dstid = atoi(token);

					filebridge* thebridge = new filebridge(fbidclock++);
					bridges.push_back(thebridge);

					thebridge->set_srctype(DISK);
					thebridge->set_dsttype(PEER);
					thebridge->set_dstid(dstid);
					thebridge->set_dstpeer(peers[i]);

					thebridge->writebuffer = new msgaggregator(peers[i]->get_fd());
					sdstid.append("\n");
					thebridge->writebuffer->configure_initial(sdstid);
					thebridge->writebuffer->set_msgbuf(&peers[i]->msgbuf);

					//thebridge->set_filename(filename);
					//thebridge->set_dataname(filename);
					//thebridge->set_dtype(RAW);

					// open read file and start sending data to client
//cout<<"[fileserver:"<<networkidx<<"]reading file name: "<<filename<<endl;
					thebridge->open_readfile(filename);
				}
				else if(strncmp(read_buf, "Iread", 5) == 0)
				{
					char* token;

					int jobid;
					int numiblock;
					int bridgeid;

					token = strtok(read_buf, " "); // <- "Iread"

					token = strtok(NULL, " "); // <- job id
					jobid = atoi(token);
					token = strtok(NULL, " "); // <- numiblock
					numiblock = atoi(token);
					token = strtok(NULL, " "); // <- bridge id
					bridgeid = atoi(token);

					// generate ireader and link to the peer(target: remote peer)
					ireader* thereader = new ireader(jobid, numiblock, i, bridgeid, PEER);
					thereader->set_dstpeer(peers[i]);
					ireaders.push_back(thereader);
				}
				else if(strncmp(read_buf, "Iwrite", 6) == 0)
				{
					char* token;
					int jobid;
					string key;

					token = strtok(read_buf, " "); // token <- "Iwrite"
					token = strtok(NULL, "\n"); // token <- [job id]

					jobid = atoi(token);

					iwriter* thewriter = NULL;
					for(int j = 0; (unsigned)j < iwriters.size(); j++)
					{
						if(iwriters[j]->get_jobid() == jobid)
						{
							thewriter = iwriters[j];
							break;
						}
					}

					if(thewriter == NULL) // no iwriter with the job id
					{
						// create new iwriter
						thewriter = new iwriter(jobid, networkidx);
						iwriters.push_back(thewriter);
					}

					// tokenize first key value pair
					token = strtok(NULL, " ");

					while(token != NULL)
					{
						key = token;
						token = strtok(NULL, "\n"); // tokenize value
						
						// add the key value pair to the iwriter
						thewriter->add_keyvalue(key, token);

						token = strtok(NULL, " "); // next key
					}
				}
				else if(strncmp(read_buf, "Owrite", 5) == 0)
				{
					string record;
					string address;
					string filename;
					char* token;

					token = strtok(read_buf, " "); // <- "Owrite"

					token = strtok(NULL, "\n"); // <- file name
					filename = token;

					token += strlen(token) + 1; // <- token: writing contents
					record = token;

					write_file(filename, record);
				}
				else if(strncmp(read_buf, "Eread", 5) == 0) // end of file read stream notification
				{
					char* token;
					int id;
					int bridgeindex = -1;
					bridgetype dsttype;
					token = strtok(read_buf, " "); // <- Eread
					token = strtok(NULL, " "); // <- id of bridge

					id = atoi(token);

					for(int j = 0; (unsigned)j < bridges.size(); j++)
					{
						if(bridges[j]->get_id() == id)
						{
							bridgeindex = j;
							break;
						}
					}

					if(bridgeindex == -1)
						cout<<"bridge not found with that index"<<endl;

					dsttype = bridges[bridgeindex]->get_dsttype();

					// finish write to cache if writing was ongoing
					entrywriter* thewriter = bridges[bridgeindex]->get_entrywriter();
					if(thewriter != NULL)
					{
						thewriter->complete();
						delete thewriter;
						thewriter = NULL;
					}

					if(dsttype == CLIENT)
					{
//cout<<"\033[0;32mEread received\033[0m"<<endl;

						file_connclient* theclient = bridges[bridgeindex]->get_dstclient();

/*
						// clear the client and bridge
						for(int j = 0; (unsigned)j < clients.size(); j++)
						{
							if(clients[j] == theclient)
							{
								if(theclient->msgbuf.size() > 1)
								{
									theclient->msgbuf.back()->set_endbuffer(theclient->get_fd());
									theclient->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									close(clients[j]->get_fd());
									delete clients[j];
									clients.erase(clients.begin()+j);
								}
								break;
							}
						}
*/

						// send NULL packet to the client
						memset(write_buf, 0, BUF_CUT);
						write_buf[0] = -1;

						if(theclient->msgbuf.size() > 1)
						{
//cout<<"\tgoes to buffer"<<endl;
							theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
							theclient->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
							{
//cout<<"\tgoes to buffer"<<endl;
								theclient->msgbuf.push_back(new messagebuffer());
							}
//else
//cout<<"\tsent directly"<<endl;

						}

						// clear the bridge
						delete bridges[bridgeindex];
						bridges.erase(bridges.begin() + bridgeindex);
					}
					else if(dsttype == PEER) // stores the data into cache and send data to target node
					{
						string message;
						stringstream ss;
						ss << "Eread ";
						ss << bridges[bridgeindex]->get_dstid();
						message = ss.str();
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

//cout<<endl;
//cout<<"write from: "<<localhostname<<endl;
//cout<<"write to: "<<bridges[i]->get_dstpeer()->get_address()<<endl;
//cout<<"message: "<<write_buf<<endl;
//cout<<endl;

						filepeer* thepeer = bridges[bridgeindex]->get_dstpeer();

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
									write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}

						// clear the bridge
						delete bridges[bridgeindex];
						bridges.erase(bridges.begin()+bridgeindex);
					}
//cout<<"end of read"<<endl;
				}
				else if(strncmp(read_buf, "Wack", 4) == 0)
				{
//cout<<"Wack"<<endl;
					string message;
					char* token;

					token = strtok(read_buf, " "); // <- Wack
					token = strtok(NULL, " "); // <- write id

					message = "Wre ";
					message.append(token); // append write id

					// write back immediately
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());

					if(peers[i]->msgbuf.size() > 1)
					{
						peers[i]->msgbuf.back()->set_buffer(write_buf, peers[i]->get_fd());
						peers[i]->msgbuf.push_back(new messagebuffer());
						//continue; // escape acceleration loop
					}
					else
					{
						if(nbwritebuf(peers[i]->get_fd(), write_buf, peers[i]->msgbuf.back()) <= 0)
						{
							peers[i]->msgbuf.push_back(new messagebuffer());
							//continue; // escape acceleration loop
						}
					}
				}
				/*
				else if(strncmp(read_buf, "IWack", 5) == 0)
				{
					string message;
					char* token;

					token = strtok(read_buf, " "); // <- IWack
					token = strtok(NULL, " "); // <- write id
					message = "IWre ";
					message.append(token); // append write id

					// write back immediately
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());

					if(peers[i]->msgbuf.size() > 1)
					{
						peers[i]->msgbuf.back()->set_buffer(write_buf, peers[i]->get_fd());
						peers[i]->msgbuf.push_back(new messagebuffer());
						//continue; // escape acceleration loop
					}
					else
					{
						if(nbwritebuf(peers[i]->get_fd(), write_buf, peers[i]->msgbuf.back()) <= 0)
						{
							peers[i]->msgbuf.push_back(new messagebuffer());
							//continue; // escape acceleration loop
						}
					}
				}
				*/
				else if(strncmp(read_buf, "Wre", 3) == 0)
				{
					char* token;
					int writeid;
					int clientidx = -1;

					token = strtok(read_buf, " "); // <- Wre
					token = strtok(NULL, " "); // <- write id
					writeid = atoi(token);

					writecount* thecount = NULL;

					for(int j = 0; (unsigned)j < clients.size(); j++)
					{
						if(clients[j]->get_fd() == writeid)
						{
							clientidx = j;
							thecount = clients[j]->thecount;
						}
					}
					
					if(thecount == NULL)
					{
						cout<<"[fileserver:"<<networkidx<<"]Unexpected NULL pointer..."<<endl;
					}

					thecount->clear_peer(i);

					if(thecount->peerids.size() == 0)
					{
						// send EIcache to the target peer
						filepeer* thepeer = clients[clientidx]->get_Itargetpeer();
						if(thepeer != NULL)
						{
							// send End of Icache message "EIcache"
							string message = "EIcache ";
							message.append(clients[clientidx]->get_Icachekey());

							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());

							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}
						}

						// close the target client and clear it
						close(clients[clientidx]->get_fd());
						delete clients[clientidx];
						clients.erase(clients.begin() + clientidx);
					}
				}
/*
				else if(strncmp(read_buf, "IWre", 4) == 0)
				{
//cout<<"[fileserver:"<<networkidx<<"]Received IWre"<<endl;
					char* token;
					int writeid;
					int bridgeidx = -1;

					token = strtok(read_buf, " "); // <= IWre
					token = strtok(NULL, " "); // <- write id
					writeid = atoi(token);

					writecount* thecount = NULL;

					for(int j = 0; (unsigned)j < bridges.size(); j++)
					{
						if(bridges[j]->get_id() == writeid)
						{
							bridgeidx = j;
							thecount = bridges[j]->get_dstclient()->thecount;
							break;
						}
					}

					if(thecount == NULL)
					{
						cout<<"[fileserver:"<<networkidx<<"]Unexpected NULL pointer..."<<endl;
					}

					thecount->clear_peer(i);

					if(thecount->peerids.size() == 0)
					{
						// notify the end of DISTRIBUTE to peer or client
						if(bridges[bridgeidx]->get_dstpeer() != NULL)
						{
							filepeer* thepeer = bridges[bridgeidx]->get_dstpeer();

							// send Edist message to the dstpeer
							string message;
							stringstream ss;
							ss << "Edist ";
							ss << bridges[bridgeidx]->get_dstid();

							message = ss.str();
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());
//cout<<"[fileserver:"<<networkidx<<"]Distribution finished and Edist to be transmitted"<<endl;

							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}

							// clear the entry reader
							if(bridges[bridgeidx]->get_entryreader() != NULL)
							{
								delete bridges[bridgeidx]->get_entryreader();
								bridges[bridgeidx]->set_entryreader(NULL);
							}
						}
						else if(bridges[bridgeidx]->get_dstclient() != NULL)
						{
//cout<<"[fileserver:"<<networkidx<<"]Distribution finished and notification to client to be done"<<endl;
							// notify the end of DISTRIBUTE to the dstclient
							file_connclient* theclient = bridges[bridgeidx]->get_dstclient();
							memset(write_buf, 0, BUF_CUT);
							write_buf[0] = 1;

							if(theclient->msgbuf.size() > 1)
							{
								theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
								theclient->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
								{
									theclient->msgbuf.push_back(new messagebuffer());
								}
							}
						}
						else
						{
							cout<<"Neither dstclient nor dstpeer are set"<<endl;
						}

						// clear the bridge
						delete bridges[bridgeidx];
						bridges.erase(bridges.begin() + bridgeidx);
					}
				}
*/
				else if(strncmp(read_buf, "Icache", 6) == 0)
				{
//cout<<"[fileserver:"<<networkidx<<"]Icache message network idx: "<<networkidx<<endl;
					char* token;
					int bridgeindex;
					filebridge* thebridge;
					string cachekey;

					token = strtok(read_buf, " "); // <- "Icache"
					token = strtok(NULL, " "); // <- "[app name]"
					cachekey = token;

					token = strtok(NULL, "\n"); // <- "[input path]"

					cachekey.append("_");
					cachekey.append(token);

					thebridge = find_Icachebridge(cachekey, bridgeindex);

					if(thebridge == NULL)
					{
						// determine the hash value
						uint32_t hashvalue;
						memset(write_buf, 0, HASHLENGTH);
						strcpy(write_buf, token); // token <- file name
						hashvalue = h(write_buf, HASHLENGTH);

						thebridge = new filebridge(fbidclock++);
						bridges.push_back(thebridge);
						thebridge->set_srctype(PEER);
						thebridge->set_dsttype(CACHE);

						thebridge->set_Icachekey(cachekey);
//cout<<"[fileserver:"<<networkidx<<"]Cachekey of new data entry: "<<cachekey<<endl;

						// set a entry writer
						dataentry* newentry = new dataentry(cachekey, hashvalue);
						thecache->new_entry(newentry);
						entrywriter* thewriter = new entrywriter(newentry);

						thebridge->set_entrywriter(thewriter);

						// rest of messages
						token = strtok(NULL, ""); 
						thewriter->write_record(token);
					}
					else
					{
//cout<<"[fileserver:"<<networkidx<<"]Cachekey of written data: "<<cachekey<<endl;
						// rest of messages
						token = strtok(NULL, "");
						thebridge->get_entrywriter()->write_record(token);
					}
				}
				else if(strncmp(read_buf, "Ihit", 4) == 0)
				{
					cout<<"\033[0;32m["<<networkidx<<"]Remote Icache hit\033[0m"<<endl;

					char* token;
					int dstid;

					token = strtok(read_buf, " "); // <- "Ihit"

					token = strtok(NULL, " "); // <- bridgeid

					dstid = atoi(token);
					filebridge* thebridge = find_bridge(dstid);

					file_connclient* theclient = thebridge->get_dstclient();
					memset(write_buf, 0, BUF_CUT);
					write_buf[0] = 1;

					if(theclient->msgbuf.size() > 1)
					{
						theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
						theclient->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
						{
							theclient->msgbuf.push_back(new messagebuffer());
						}
					}
				}
				else if(strncmp(read_buf, "Imiss", 5) == 0)
				{
					char* token;
					filebridge* thebridge;
					int dstid;

					token = strtok(read_buf, " ");
					token = strtok(NULL, " ");
					dstid = atoi(token);

					thebridge = find_bridge(dstid);
					file_connclient* theclient = thebridge->get_dstclient();

					memset(write_buf, 0, BUF_CUT);
					write_buf[0] = 0;

					if(theclient->msgbuf.size() > 1)
					{
						theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
						theclient->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
						{
							theclient->msgbuf.push_back(new messagebuffer());
						}
					}
				}
				else if(strncmp(read_buf, "EIcache", 7) == 0)
				{
					char* token;
					filebridge* thebridge;
					int bridgeindex;

					token = strtok(read_buf, " "); // <- "EIcache"
					token = strtok(NULL, "\n"); // <- cachekey

					thebridge = find_Icachebridge(token, bridgeindex);

					if(thebridge == NULL)
					{
						cout<<"[fileserver:"<<networkidx<<"]Unexpected NULL pointer after receiving \"EIcache\" message"<<endl;
					}
					else
					{
//cout<<"[fileserver:"<<networkidx<<"]Completed writing entry with cachekey: "<<token<<endl;
						thebridge->get_entrywriter()->complete();
						delete thebridge->get_entrywriter();
						thebridge->set_entrywriter(NULL);

						delete thebridge;
						bridges.erase(bridges.begin() + bridgeindex);
					}
				}
				else if(strncmp(read_buf, "Edist", 5) == 0)
				{
//cout<<"[fileserver:"<<networkidx<<"]Edist arrived. notifying client end of distribution..."<<endl;
					char* token;
					int bridgeid;

					token = strtok(read_buf, " "); // <- "Edist"

					token = strtok(NULL, " ");
					bridgeid = atoi(token);


					filebridge* thebridge;
					int bridgeidx;

					for(int j = 0; (unsigned)j < bridges.size(); j++)
					{
						if(bridges[j]->get_id() == bridgeid)
						{
							thebridge = bridges[j];
							bridgeidx = j;
						}
					}

					if(thebridge == NULL)
					{
						cout<<"[fileserver:"<<networkidx<<"]Unexpected filebridge NULL pointer(2)"<<endl;
					}

					// notify the end of DISTRIBUTE to dstclient
					file_connclient* theclient = bridges[bridgeidx]->get_dstclient();
					memset(write_buf, 0, BUF_CUT);
					write_buf[0] = 1;

					if(theclient->msgbuf.size() > 1)
					{
						theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
						theclient->msgbuf.push_back(new messagebuffer());
					}
					else
					{
						if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
						{
							theclient->msgbuf.push_back(new messagebuffer());
						}
					}

					// add peers to the write count of the client
					if(theclient->thecount == NULL)
					{
						theclient->thecount = new writecount();
					}

					token = strtok(NULL, " "); // <- first peer ids written

					while(token != NULL)
					{
						theclient->thecount->add_peer(atoi(token));
						token = strtok(NULL, " ");
					}

					// clear the bridge
					delete bridges[bridgeidx];
					bridges.erase(bridges.begin() + bridgeidx);
				}
				else // a filebridge id is passed. this is the case of data read stream
				{
					filebridge* thebridge;
					string record;
					char* token;
					char* buf;
					int id;
					bridgetype dsttype;

					buf = read_buf;
					token = strtok(read_buf, "\n"); // <- filebridge id


					id = atoi(token);
					buf += strlen(token) + 1; // <- record
					record = buf;

					for(int j = 0; (unsigned)j < bridges.size(); j++)
					{
						if(bridges[j]->get_id() == id)
						{
							thebridge = bridges[j];
						}
					}

					dsttype = thebridge->get_dsttype();

					if(dsttype == CLIENT)
					{
						// write to cache if writing was ongoing
						entrywriter* thewriter = thebridge->get_entrywriter();
						if(thewriter != NULL)
						{
							thewriter->write_record(record);
						}

						file_connclient* theclient = thebridge->get_dstclient();
						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, record.c_str()); // send only the record

//cout<<endl;
//cout<<"write from: "<<localhostname<<endl;
//cout<<"write to a client"<<endl;
//cout<<"message: "<<write_buf<<endl;
//cout<<endl;

						if(theclient->msgbuf.size() > 1)
						{
							theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
							theclient->msgbuf.push_back(new messagebuffer());
							//continue; // escape acceleration loop
						}
						else
						{
//cout<<endl;
//cout<<"from: "<<localhostname<<endl;
//cout<<"to: client"<<endl;
							if(nbwritebuf(theclient->get_fd(),
										write_buf, theclient->msgbuf.back()) <= 0)
							{
								theclient->msgbuf.push_back(new messagebuffer());
								//continue; // escape acceleration loop
							}
						}

						//nbwrite(theclient->get_fd(), write_buf);
					}
					else if(dsttype == PEER) // stores the data into cache and send data to target node
					{
						// write to cache if writing was ongoing
						entrywriter* thewriter = thebridge->get_entrywriter();
						if(thewriter != NULL)
						{
							thewriter->write_record(record);
						}

						string message;
						stringstream ss;
						ss << thebridge->get_dstid();
						message = ss.str();
						message.append("\n");
						message.append(record);

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

//cout<<endl;
//cout<<"write from: "<<localhostname<<endl;
//cout<<"write to: "<<bridges[i]->get_dstpeer()->get_address()<<endl;
//cout<<"message: "<<write_buf<<endl;
//cout<<endl;
						filepeer* thepeer = thebridge->get_dstpeer();

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
							//continue; // escape acceleration loop
						}
						else
						{
//cout<<endl;
//cout<<"from: "<<localhostname<<endl;
//cout<<"to: "<<thepeer->get_address()<<endl;
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
								//continue; // escape acceleration loop
							}
						}
					}
				}

				// enable loop acceleration
				//i--;
				//continue;
			}
			else if(readbytes == 0)
			{
				cout<<"[fileserver:"<<networkidx<<"]Debugging: Connection from a peer disconnected: "<<peers[i]->get_address()<<endl;

				// clear the peer
				close(peers[i]->get_fd());
				peers[i]->set_fd(-1);
			}
		}
//gettimeofday(&time_end2, NULL);
//timeslot3 += time_end2.tv_sec*1000000 + time_end2.tv_usec - time_start2.tv_sec*1000000 - time_start2.tv_usec;
//gettimeofday(&time_start2, NULL);

		// process reading from the disk or cache and send the data to peer or client
		for(int i = 0; (unsigned)i < bridges.size(); i++)
		{
			//for(int accel = 0; accel < 1000; accel++) // accelerate the reading speed by 1000
			//{
				if(bridges[i]->get_srctype() == CACHE)
				{
					if(bridges[i]->get_dsttype() == DISTRIBUTE)
					{
						bool ret;
						string record;

						ret = bridges[i]->get_entryreader()->read_record(record);

						if(ret) // successfully read
						{
							//string jobdirpath = bridges[i]->get_jobdirpath();
							//string message;
							//string value;

							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, record.c_str());

							bridges[i]->get_distributor()->process_message(write_buf, read_buf);
						}
						else // end of the cache contents
						{
							// flush and clear the distributor
							if(bridges[i]->get_distributor() != NULL)
							{
								delete bridges[i]->get_distributor();
								bridges[i]->set_distributor(NULL);
							}

							// clear the entryreader
							delete bridges[i]->get_entryreader();
							bridges[i]->set_entryreader(NULL);

							writecount* thecount = bridges[i]->get_dstclient()->thecount;

							// TODO: if dstpeer exists, thecount should be from bridge itself, not from client
							// abc

							if(bridges[i]->get_dstpeer() != NULL)
							{
								filepeer* thepeer = bridges[i]->get_dstpeer();

								// send Edist message to the dstpeer
								string message;
								stringstream ss;
								ss << "Edist ";
								ss << bridges[i]->get_dstid();

								// add to the ss the writecount peer information
								for(set<int>::iterator it = thecount->peerids.begin(); it != thecount->peerids.end(); it++)
								{
									ss << " ";
									ss << *it;
								}

								message = ss.str();
								memset(write_buf, 0, BUF_SIZE);
								strcpy(write_buf, message.c_str());

								if(thepeer->msgbuf.size() > 1)
								{
									thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
									thepeer->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									if(nbwritebuf(thepeer->get_fd(),
												write_buf, thepeer->msgbuf.back()) <= 0)
									{
										thepeer->msgbuf.push_back(new messagebuffer());
									}
								}

								// clear the entry reader
								if(bridges[i]->get_entryreader() != NULL)
								{
									delete bridges[i]->get_entryreader();
									bridges[i]->set_entryreader(NULL);
								}
							}
							else if(bridges[i]->get_dstclient() != NULL)
							{
								// notify the end of DISTRIBUTE to the dstclient
								memset(write_buf, 0, BUF_CUT);
								write_buf[0] = 1;

								// determine clientidx
								int clientidx = -1;

								for(int j = 0; (unsigned)j < clients.size(); j++)
								{
									if(clients[j] == bridges[i]->get_dstclient())
									{
										clientidx = j;
										break;
									}
								}

								if(clientidx == -1)
								{
									cout<<"[fileserver:"<<networkidx<<"]Cannot find such client"<<endl;
								}

								if(clients[clientidx]->msgbuf.size() > 1)
								{
									clients[clientidx]->msgbuf.back()->set_buffer(write_buf, clients[clientidx]->get_fd());
									clients[clientidx]->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									if(nbwritebuf(clients[clientidx]->get_fd(), write_buf, clients[clientidx]->msgbuf.back()) <= 0)
									{
										clients[clientidx]->msgbuf.push_back(new messagebuffer());
									}
								}
							}
							else
							{
								cout<<"Neither dstclient nor dstpeer are set"<<endl;
							}

							// clear the bridge
							delete bridges[i];
							bridges.erase(bridges.begin() + i);
							i--;
						}
					}
					else
					{
						bool ret;
						string record;
						memset(write_buf, 0, BUF_SIZE);

						if(bridges[i]->get_dsttype() == CLIENT)
						{
							ret = bridges[i]->get_entryreader()->read_record(record);

							strcpy(write_buf, record.c_str());
						}
						else if(bridges[i]->get_dsttype() == PEER)
						{
							stringstream ss;
							string message;
							ss << bridges[i]->get_dstid();
							message = ss.str();
							message.append("\n");

							ret = bridges[i]->get_entryreader()->read_record(record);

							message.append(record);

							strcpy(write_buf, message.c_str());
						}

						if(ret) // successfully read
						{
							if(bridges[i]->get_dsttype() == CLIENT)
							{
								//cout<<endl;
								//cout<<"write from: "<<localhostname<<endl;
								//cout<<"write to a client"<<endl;
								//cout<<"message: "<<write_buf<<endl;
								//cout<<endl;

								file_connclient* theclient = bridges[i]->get_dstclient();
								if(theclient->msgbuf.size() > 1)
								{
									theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
									theclient->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									//cout<<endl;
									//cout<<"from: "<<localhostname<<endl;
									//cout<<"to: client"<<endl;
									if(nbwritebuf(theclient->get_fd(),
												write_buf, theclient->msgbuf.back()) <= 0)
									{
										theclient->msgbuf.push_back(new messagebuffer());
									}
								}
							}
							else if(bridges[i]->get_dsttype() == PEER)
							{
								//cout<<endl;
								//cout<<"write from: "<<localhostname<<endl;
								//cout<<"write to: "<<bridges[i]->get_dstpeer()->get_address()<<endl;
								//cout<<"message: "<<write_buf<<endl;
								//cout<<endl;

								filepeer* thepeer = bridges[i]->get_dstpeer();

								if(thepeer->msgbuf.size() > 1)
								{
									thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
									thepeer->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									//cout<<endl;
									//cout<<"from: "<<localhostname<<endl;
									//cout<<"to: "<<thepeer->get_address()<<endl;
									if(nbwritebuf(thepeer->get_fd(), write_buf, thepeer->msgbuf.back()) <= 0)
									{
										thepeer->msgbuf.push_back(new messagebuffer());
									}
								}
							}
						}
						else // no more record
						{
							//cout<<"\033[0;33mEread sent!\033[0m"<<endl;
							delete bridges[i]->get_entryreader();

							if(bridges[i]->get_dsttype() == CLIENT)
							{
								//cout<<"\033[0;32mEread received\033[0m"<<endl;
								file_connclient* theclient = bridges[i]->get_dstclient();

								// send NULL packet to the client
								memset(write_buf, 0, BUF_CUT);
								write_buf[0] = -1;

								if(theclient->msgbuf.size() > 1)
								{
									//cout<<"\tgoes to buffer"<<endl;
									theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
									theclient->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
									{
										//cout<<"\tgoes to buffer"<<endl;
										theclient->msgbuf.push_back(new messagebuffer());
									}
									//else
									//cout<<"\tsent directly"<<endl;
								}
							}
							else if(bridges[i]->get_dsttype() == PEER)
							{
								stringstream ss1;
								string message1;
								ss1 << "Eread ";
								ss1 << bridges[i]->get_dstid();
								message1 = ss1.str();
								memset(write_buf, 0, BUF_SIZE);
								strcpy(write_buf, message1.c_str());

								//cout<<endl;
								//cout<<"write from: "<<localhostname<<endl;
								//cout<<"write to: "<<bridges[i]->get_dstpeer()->get_address()<<endl;
								//cout<<"message: "<<write_buf<<endl;
								//cout<<endl;

								filepeer* thepeer = bridges[i]->get_dstpeer();

								if(thepeer->msgbuf.size() > 1)
								{
									thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
									thepeer->msgbuf.push_back(new messagebuffer());
								}
								else
								{
									//cout<<endl;
									//cout<<"from: "<<localhostname<<endl;
									//cout<<"to: "<<thepeer->get_address()<<endl;
									if(nbwritebuf(thepeer->get_fd(),
												write_buf, thepeer->msgbuf.back()) <= 0)
									{
										thepeer->msgbuf.push_back(new messagebuffer());
									}
								}
							}

							delete bridges[i];
							bridges.erase(bridges.begin()+i);
							i--;
							// break the accel loop
							//break;
						}
					}
				}
				else if(bridges[i]->get_srctype() == DISK)
				{
					bool is_success;
					string record;
					is_success = bridges[i]->read_record(record);

					while(is_success) // some remaining record
					{
						if(bridges[i]->writebuffer->add_record(record))
						{
							break;
						}

						is_success = bridges[i]->read_record(record);
					}

					if(!is_success) // no more record to read
					{
//cout<<"\033[0;33mEread sent!\033[0m"<<endl;
						// flush the write buffer
						bridges[i]->writebuffer->flush();

						// complete writing to cache if writing was ongoing
						entrywriter* thewriter = bridges[i]->get_entrywriter();

						if(thewriter != NULL)
						{
							thewriter->complete();
							delete thewriter;
						}

						if(bridges[i]->get_dsttype() == CLIENT)
						{
//cout<<"\033[0;32mEread received\033[0m"<<endl;
							file_connclient* theclient = bridges[i]->get_dstclient();

							// send NULL packet to the client
							memset(write_buf, 0, BUF_CUT);
							write_buf[0] = -1;

							if(theclient->msgbuf.size() > 1)
							{
//cout<<"\tgoes to buffer"<<endl;
								theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
								theclient->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
								{
//cout<<"\tgoes to buffer"<<endl;
									theclient->msgbuf.push_back(new messagebuffer());
								}
//else
//cout<<"\tsent directly"<<endl;
							}

							// clear the bridge
							delete bridges[i];
							bridges.erase(bridges.begin()+i);
						}
						else if(bridges[i]->get_dsttype() == PEER)
						{
							stringstream ss;
							string message;
							ss << "Eread ";
							ss << bridges[i]->get_dstid();
							message = ss.str();

							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());

							filepeer* thepeer = bridges[i]->get_dstpeer();

							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}

							delete bridges[i];
							bridges.erase(bridges.begin()+i);
						}
					}

/*
					if(is_success) // some remaining record
					{
						// write to cache if writing was ongoing
						entrywriter* thewriter = bridges[i]->get_entrywriter();
						if(thewriter != NULL)
						{
							thewriter->write_record(record);
						}

						if(bridges[i]->get_dsttype() == CLIENT)
						{
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, record.c_str());

							file_connclient* theclient = bridges[i]->get_dstclient();
							if(theclient->msgbuf.size() > 1)
							{
								theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
								theclient->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(theclient->get_fd(),
											write_buf, theclient->msgbuf.back()) <= 0)
								{
									theclient->msgbuf.push_back(new messagebuffer());
								}
							}

							//nbwrite(bridges[i]->get_dstclient()->get_fd(), write_buf);
						}
						else if(bridges[i]->get_dsttype() == PEER)
						{
							stringstream ss;
							string message;
							ss << bridges[i]->get_dstid();
							message = ss.str();
							message.append(" ");
							message.append(record);

							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());

							filepeer* thepeer = bridges[i]->get_dstpeer();

							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}

							//nbwrite(bridges[i]->get_dstpeer()->get_fd(), write_buf);
						}
					}
					else // end of data(file)
					{
						// write to cache if writing was ongoing
						entrywriter* thewriter = bridges[i]->get_entrywriter();

						if(thewriter != NULL)
						{
							thewriter->complete();
							delete thewriter;
							thewriter = NULL;
						}

						if(bridges[i]->get_dsttype() == CLIENT)
						{
							file_connclient* theclient = bridges[i]->get_dstclient();

							// send NULL packet to the client
							memset(write_buf, -1, BUF_CUT);

							if(theclient->msgbuf.size() > 1)
							{
								theclient->msgbuf.back()->set_buffer(write_buf, theclient->get_fd());
								theclient->msgbuf.push_back(new messagebuffer());
							}
							else
							{
								if(nbwritebuf(theclient->get_fd(), write_buf, theclient->msgbuf.back()) <= 0)
								{
									theclient->msgbuf.push_back(new messagebuffer());
								}
							}

							// clear the bridge
							delete bridges[i];
							bridges.erase(bridges.begin()+i);
						}
						else if(bridges[i]->get_dsttype() == PEER)
						{
							stringstream ss;
							string message;
							ss << "Eread ";
							ss << bridges[i]->get_dstid();
							message = ss.str();
							memset(write_buf, 0, BUF_SIZE);
							strcpy(write_buf, message.c_str());

//cout<<endl;
//cout<<"write from: "<<localhostname<<endl;
//cout<<"write to: "<<bridges[i]->get_dstpeer()->get_address()<<endl;
//cout<<"message: "<<write_buf<<endl;
//cout<<endl;

							filepeer* thepeer = bridges[i]->get_dstpeer();

							if(thepeer->msgbuf.size() > 1)
							{
								thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
								thepeer->msgbuf.push_back(new messagebuffer());
							}
							else
							{
//cout<<endl;
//cout<<"from: "<<localhostname<<endl;
//cout<<"to: "<<thepeer->get_address()<<endl;
								if(nbwritebuf(thepeer->get_fd(),
											write_buf, thepeer->msgbuf.back()) <= 0)
								{
									thepeer->msgbuf.push_back(new messagebuffer());
								}
							}
							//nbwrite(bridges[i]->get_dstpeer()->get_fd(), write_buf);

							delete bridges[i];
							bridges.erase(bridges.begin()+i);
						}

						// break the accel loop
						//break;
					}
*/
				}
			//}
		}
//gettimeofday(&time_end2, NULL);
//timeslot4 += time_end2.tv_sec*1000000 + time_end2.tv_usec - time_start2.tv_sec*1000000 - time_start2.tv_usec;
//gettimeofday(&time_start2, NULL);

		// process write of iwriters
		for(int i = 0; (unsigned)i < iwriters.size(); i++)
		{
			if(iwriters[i]->is_writing())
			{
				bool ret;

				ret = iwriters[i]->write_to_disk();

				if(ret) // writing finished
				{
					// send the numblock information to the cache server
					string message;
					stringstream ss;

					ss << "iwritefinish ";
					ss << iwriters[i]->get_jobid();
					ss << " ";
					ss << iwriters[i]->get_numblock();
					message = ss.str();

					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, message.c_str());

					nbwrite(cacheserverfd, write_buf);

					// clear the iwriter
					delete iwriters[i];
					iwriters.erase(iwriters.begin() + i);
					i--;
				}
			}
		}

		for(int i = 0; (unsigned)i < ireaders.size(); i++)
		{
			bool end = ireaders[i]->read_idata();

			if(!end) // end of reading idata
			{
				delete ireaders[i];
				ireaders.erase(ireaders.begin() + i);
				i--;
			}
		}

		// process buffered stream through peers
		for(int i = 0; (unsigned)i < peers.size(); i++)
		{
			while(peers[i]->msgbuf.size() > 1)
			{
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, peers[i]->msgbuf.front()->get_message().c_str());

				if(nbwritebuf(peers[i]->get_fd(), write_buf,
							peers[i]->msgbuf.front()->get_remain(), peers[i]->msgbuf.front()) > 0) // successfully transmitted
				{
					delete peers[i]->msgbuf.front();
					peers[i]->msgbuf.erase(peers[i]->msgbuf.begin());
				}
				else // not transmitted completely
				{
					break;
				}
			}
		}

		// process buffered stream through clients
		for(int i = 0; (unsigned)i < clients.size(); i++)
		{
			while(clients[i]->msgbuf.size() > 1)
			{
				if(clients[i]->msgbuf.front()->is_end())
				{
					//cout<<"\t\t\t\tdon't come here"<<endl;
					close(clients[i]->get_fd());

					// send EIcache to the target peer
					filepeer* thepeer = clients[i]->get_Itargetpeer();
					if(thepeer != NULL)
					{
						// send End of Icache message "EIcache"
						string message = "EIcache ";
						message.append(clients[i]->get_Icachekey());

						memset(write_buf, 0, BUF_SIZE);
						strcpy(write_buf, message.c_str());

						if(thepeer->msgbuf.size() > 1)
						{
							thepeer->msgbuf.back()->set_buffer(write_buf, thepeer->get_fd());
							thepeer->msgbuf.push_back(new messagebuffer());
						}
						else
						{
							if(nbwritebuf(thepeer->get_fd(),
										write_buf, thepeer->msgbuf.back()) <= 0)
							{
								thepeer->msgbuf.push_back(new messagebuffer());
							}
						}
					}

					delete clients[i];
					clients.erase(clients.begin()+i);
					i--;
					break;
				}
				else
				{
					memset(write_buf, 0, BUF_SIZE);
					strcpy(write_buf, clients[i]->msgbuf.front()->get_message().c_str());

					if(nbwritebuf(clients[i]->get_fd(), write_buf,
						clients[i]->msgbuf.front()->get_remain(), clients[i]->msgbuf.front()) > 0) // successfully transmitted
					{
						delete clients[i]->msgbuf.front();
						clients[i]->msgbuf.erase(clients[i]->msgbuf.begin());
					}
					else
					{
						break;
					}
				}
			}
		}

//gettimeofday(&time_end2, NULL);
//timeslot6 += time_end2.tv_sec*1000000 + time_end2.tv_usec - time_start2.tv_sec*1000000 - time_start2.tv_usec;
//gettimeofday(&time_start2, NULL);

/*
		for(int i = 0; (unsigned)i < waitingclients.size(); i++)
		{
			int writeid;
			int countindex = -1;
			writeid = waitingclients[i]->get_writeid();

			writecount* thecount = NULL;

			for(int j = 0; (unsigned)j < writecounts.size(); j++)
			{
				if(writecounts[j]->get_id() == writeid)
				{
					thecount = writecounts[j];
					countindex = j;
				}
			}

			if(thecount == NULL)
			{
				// close the client
				close(waitingclients[i]->get_fd());
				delete waitingclients[i];
				waitingclients.erase(waitingclients.begin()+i);
				i--;
			}
			else
			{
				if(thecount->get_count() == 0) // the writing is already cleared
				{
					// close the client
					close(waitingclients[i]->get_fd());
					delete waitingclients[i];
					waitingclients.erase(waitingclients.begin()+i);
					i--;

					delete thecount;
					writecounts.erase(writecounts.begin()+countindex);
				}
				else if(thecount->get_count() > 0)
				{
					continue;
				}
				else
				{
					cout<<"[fileserver]Debugging: An abnormal write count."<<endl;
				}
			}
		}
*/

		// listen signal from cache server
		{
			int readbytes;
			readbytes = nbread(cacheserverfd, read_buf);
			if(readbytes > 0)
			{
				if(strncmp(read_buf, "boundaries", 10) == 0)
				{
					string token;
					double doubletoken;
					stringstream ss;

					// raed boundary information and parse it to update the boundary
					ss << read_buf;

					ss >> token; // boundaries

					for(int i = 0; (unsigned)i < nodelist.size(); i++)
					{
						ss >> doubletoken;
						thehistogram->set_boundary(i, doubletoken);
					}
				}
				else if(strncmp(read_buf, "iwritefinish", 12) == 0)
				{
					char* token;
					int jobid;

					token = strtok(read_buf, " "); // token <- "iwritefinish"
					token = strtok(NULL, " "); // token <- jobid

					jobid =  atoi(token);

					for(int i = 0; (unsigned)i < iwriters.size(); i++)
					{
						if(iwriters[i]->get_jobid() == jobid)
						{
							iwriters[i]->flush();
							break;
						}
					}
				}
				else // unknown message
				{
					cout<<"[cacheserver]Unknown message from master node"<<endl;
				}
			}
			else if(readbytes == 0)
			{
				for(int i = 0; (unsigned)i < clients.size(); i++)
				{
					cout<<"[fileserver:"<<networkidx<<"]Closing connection to a client..."<<endl;
					close(clients[i]->get_fd());
				}

				for(int i = 0; (unsigned)i < peers.size(); i++)
					close(peers[i]->get_fd());

				close(ipcfd);
				close(serverfd);
				close(cacheserverfd);

				cout<<"[fileserver:"<<networkidx<<"]Connection from cache server disconnected. exiting..."<<endl;

				return 0;
			}
		}

		thecache->update_size();
	}

	return 0;
}

filepeer* fileserver::find_peer(string& address)
{
	for(int i = 0; (unsigned)i < peers.size(); i++)
	{
		if(peers[i]->get_address() == address)
			return peers[i];
	}

	cout<<"[fileserver:"<<networkidx<<"]Debugging: No such a peer. in find_peer()"<<endl;
	return NULL;
}

filebridge* fileserver::find_bridge(int id)
{
	for(int i = 0; (unsigned)i < bridges.size(); i++)
	{
		if(bridges[i]->get_id() == id)
			return bridges[i];
	}

	cout<<"[fileserver:"<<networkidx<<"]Debugging: No such a bridge. in find_bridge(), id: "<<id<<endl;
	return NULL;
}

filebridge* fileserver::find_Icachebridge(string inputname, int& bridgeindex)
{
	for(int i = 0; (unsigned)i < bridges.size(); i++)
	{
		if(bridges[i]->get_Icachekey() == inputname)
		{
			bridgeindex = i;
			return bridges[i];
		}
	}
	bridgeindex = -1;
	return NULL;
}

bool fileserver::write_file(string fname, string& record)
{
	string fpath = DHT_PATH;
	int writefilefd = -1;
	int ret;
	fpath.append(fname);

	writefilefd = open(fpath.c_str(), O_APPEND|O_WRONLY|O_CREAT, 0644);

	if(writefilefd < 0)
		cout<<"[filebridge]Opening write file failed"<<endl;

	record.append("\n");

	// memset(write_buf, 0, BUF_SIZE); <- memset may be not necessary
	strcpy(write_buf, record.c_str());
	ret = write(writefilefd, write_buf, record.length());

	if(ret < 0)
	{
		cout<<"[fileserver:"<<networkidx<<"]Writing to write file failed"<<endl;
		close(writefilefd);
		return false;
	}
	else
	{
		close(writefilefd);
		return true;
	}
}

//writecount* fileserver::find_writecount(int id, int* idx)
//{
//	for(int i = 0; (unsigned)i < writecounts.size(); i++)
//	{
//		if(writecounts[i]->get_id() == id)
//		{
//			if(idx != NULL)
//				*idx = i;
//			return writecounts[i];
//		}
//	}
//
//	return NULL;
//}

#endif
#ifndef __FILEBRIDGE__
#define __FILEBRIDGE__

#include <iostream>
#include <fstream>
#include <fcntl.h>
#include <mapreduce/definitions.hh>
#include <orthrus/dataentry.hh>
#include "filepeer.hh"
#include "writecount.hh"
#include "file_connclient.hh"

using namespace std;

class filebridge
{
	private:
		int id; // this id will be sent to peer to link this filebridge
		int dstid; // the bridge id of remote peer, -1 as default, positive value when the dsttype is PEER
		//int writefilefd; // deprecated
		bridgetype srctype; // PEER, DISK, CACHE or CLIENT
		bridgetype dsttype; // PEER, DISK, CACHE or CLIENT
		filepeer* dstpeer; // destination peer
		file_connclient* dstclient; // destination client
		idistributor* theidistributor;
		entrywriter* dstentrywriter; // when this is not null, data should be written to the entry
		entryreader* srcentryreader; // when the srctype is CACHE, srcentryreader should be set and it should read data from cache
		fstream readfilestream;

		string Icachekey;
		string jobdirpath; // used for the distribution of Icache contents

		//char read_buf[BUF_SIZE]; // this is not for reading message from other connection, but for buffering reading file
		//string dataname; // the key of the data which is used as input of hash function
		//string filename; // the key of the data which is used as input of hash function
		//datatype dtype; // RAW, INTERMEDIATE, OUTPUT

	public:
		writecount* thecount; // list of nodes the to which the outputs(RAW, INTERMEDIATE) are transffered
		msgaggregator* writebuffer;

		filebridge(int anid);
		~filebridge();

		void set_dstpeer(filepeer* apeer);
		//void set_role(file_role arole);
		void set_srctype(bridgetype atype);
		void set_dsttype(bridgetype atype);
		void set_id(int num);
		void set_dstid(int num);
		void set_dstclient(file_connclient* aclient);
		void set_entryreader(entryreader* areader);
		void set_entrywriter(entrywriter* awriter);
		void set_distributor(idistributor* thedistributor);

		idistributor* get_distributor();

		void set_jobdirpath(string path);
		string get_jobdirpath();

		void set_Icachekey(string key);
		string get_Icachekey();
		//void set_dataname(string aname);
		//void set_filename(string aname);
		//void set_dtype(datatype atype);
		//void set_writeid(int num);

		int get_id();
		int get_dstid();
		filepeer* get_dstpeer();
		//int get_writeid();
		
		//file_role get_role();
		file_connclient* get_dstclient();
		bridgetype get_srctype();
		bridgetype get_dsttype();
		entryreader* get_entryreader();
		entrywriter* get_entrywriter();
		//datatype get_dtype();
		//string get_dataname();
		//string get_filename();

		void open_readfile(string fname);
		//void open_writefile(string fname); // deprecated
		//void write_record(string& record, char* write_buf); // deprecated
		bool read_record(string& record); // reads next record
};

filebridge::filebridge(int anid)
{
	id = anid;
	dstid = -1;
	//writefilefd = -1;
	thecount = NULL;
	dstpeer = NULL;
	dstclient = NULL;
	srcentryreader = NULL;
	dstentrywriter = NULL;
	writebuffer = NULL;
	theidistributor = NULL;

	//keybuffer.configure_initial("Ikey\n");
}

filebridge::~filebridge()
{
	// clear up all things
	if(thecount != NULL)
		delete thecount;

	readfilestream.close();
	if(writebuffer != NULL)
		delete writebuffer;
	//close(this->writefilefd);
}

void filebridge::set_entryreader(entryreader* areader)
{
	srcentryreader = areader;
}

void filebridge::set_entrywriter(entrywriter* awriter)
{
	dstentrywriter = awriter;
}

void filebridge::set_dstpeer(filepeer* apeer)
{
	this->dstpeer = apeer;
}

void filebridge::set_distributor(idistributor* thedistributor)
{
	theidistributor = thedistributor;
}

idistributor* filebridge::get_distributor()
{
	return theidistributor;
}

//void filebridge::set_role(file_role arole)
//{
//	if(this->dstclient == NULL)
//	{
//		cout<<"[filebridge]The destination client of a filebridge is not set and modifying the member client tried"<<endl;
//		return;
//	}
//	this->dstclient->set_role(arole);
//}

//void filebridge::set_dataname(string aname)
//{
//	this->dataname = aname;
//}

//void filebridge::set_dtype(datatype atype)
//{
//	this->dtype = atype;
//}

filepeer* filebridge::get_dstpeer()
{
	return dstpeer;
}

//string filebridge::get_dataname()
//{
//	return dataname;
//}

//datatype filebridge::get_dtype()
//{
//	return dtype;
//}

//void filebridge::set_filename(string aname)
//{
//	this->filename = aname;
//}

//string filebridge::get_filename()
//{
//	return this->filename;
//}

entryreader* filebridge::get_entryreader()
{
	return srcentryreader;
}

entrywriter* filebridge::get_entrywriter()
{
	return dstentrywriter;
}

void filebridge::open_readfile(string fname)
{
	string fpath = DHT_PATH;
	fpath.append(fname);

	this->readfilestream.open(fpath.c_str());

	if(!this->readfilestream.is_open())
		cout<<"[filebridge]File does not exist for reading: "<<fname<<endl;

	return;
}

bool filebridge::read_record(string& record) // reads next record
{
	getline(this->readfilestream, record);

	if(this->readfilestream.eof())
		return false;
	else
		return true;
}

/*
// deprecated
void filebridge::open_writefile(string fname)
{
	string fpath = DHT_PATH;
	fpath.append(fname);
	this->writefilefd = open(fpath.c_str(), O_APPEND|O_SYNC|O_WRONLY|O_CREAT, 0644);
	if(this->writefilefd < 0)
		cout<<"filebridge]Opening write file failed"<<endl;
	return;
}
*/

/*
void filebridge::write_record(string& record, char* write_buf)
{
	struct flock alock;
	struct flock ulock;

	// set lock
	alock.l_type = F_WRLCK;
	alock.l_start = 0;
	alock.l_whence = SEEK_SET;
	alock.l_len = 0;

	// set unlock
	ulock.l_type = F_UNLCK;
	ulock.l_start = 0;
	ulock.l_whence = SEEK_SET;
	ulock.l_len = 0;


	// acquire file lock
	fcntl(this->writefilefd, F_SETLKW, &alock);

	// critical section
	{
		int ret;
		record.append("\n");
		memset(write_buf, 0, BUF_SIZE);
		strcpy(write_buf, record.c_str());
		ret = write(this->writefilefd, write_buf, record.length());

		if(ret < 0)
			cout<<"[filebridge]Writing to write file failed"<<endl;
	}

	// release file lock
	fcntl(this->writefilefd, F_SETLK, &ulock);
}
*/

file_connclient* filebridge::get_dstclient()
{
	return this->dstclient;
}

void filebridge::set_srctype(bridgetype atype)
{
	this->srctype = atype;
}

void filebridge::set_dsttype(bridgetype atype)
{
	this->dsttype = atype;
}

bridgetype filebridge::get_srctype()
{
	return this->srctype;
}

bridgetype filebridge::get_dsttype()
{
	return this->dsttype;
}

int filebridge::get_id()
{
	return id;
}

int filebridge::get_dstid()
{
	return dstid;
}

void filebridge::set_id(int num)
{
	id = num;
}

void filebridge::set_dstid(int num)
{
	dstid = num;
}

//file_role filebridge::get_role()
//{
//	return this->dstclient->get_role();
//}

void filebridge::set_dstclient(file_connclient* aclient)
{
	this->dstclient = aclient;
}
void filebridge::set_Icachekey(string key)
{
	Icachekey = key;
}

string filebridge::get_Icachekey()
{
	return Icachekey;
}

void filebridge::set_jobdirpath(string path)
{
	jobdirpath = path; 
}

string filebridge::get_jobdirpath()
{
	return jobdirpath;
}


//int filebridge::get_writeid()
//{
//	return writeid;
//}

//void filebridge::set_writeid(int num)
//{
//	writeid = num; 
//}

#endif
#ifndef __FILEPEER__
#define __FILEPEER__

#include <iostream>
#include <vector>
#include <common/msgaggregator.hh>
#include <file_distributor/messagebuffer.hh>

using namespace std;

class filepeer
{
	private:
		int fd;
		string address;

	public:
		vector<messagebuffer*> msgbuf;
		//msgaggregator writebuffer;

		filepeer(int afd, string anaddress);
		~filepeer();
		int get_fd();
		void set_fd(int num);
		string get_address();
		void set_address(string astring);
};

filepeer::filepeer(int afd, string anaddress)
{
	this->fd = afd;
	this->address = anaddress;

	//writebuffer.configure_initial("write\n");
	//writebuffer.set_msgbuf(&msgbuf);

	// add a null message buffer
	msgbuf.push_back(new messagebuffer());
}


filepeer::~filepeer()
{
	for(int i = 0; (unsigned)i < msgbuf.size(); i++)
	{
		if(msgbuf[i] != NULL)
			delete msgbuf[i];
	}
}

int filepeer::get_fd()
{
	return this->fd;
}

string filepeer::get_address()
{
	return this->address;
}

void filepeer::set_fd(int num)
{
	this->fd = num;
}

void filepeer::set_address(string astring)
{
	this->address = astring;
}

#endif
#ifndef __FILE_CONNCLIENT__
#define __FILE_CONNCLIENT__

#include <iostream>
#include <fstream>
#include <fcntl.h>
#include <orthrus/dataentry.hh>
#include <file_distributor/filepeer.hh>
#include "messagebuffer.hh"
#include "idistributor.hh"
#include "writecount.hh"
#include <mapreduce/definitions.hh>

using namespace std;

class file_connclient
{
	private:
		int fd;
		int dstid;
		string Icachekey;
		entrywriter* Icachewriter; // cache writer for the intermediate results
		filepeer* Itargetpeer;
		//file_role role;

	public:
		idistributor* thedistributor;
		writecount* thecount;
		vector<messagebuffer*> msgbuf;

		file_connclient(int number);
		//file_connclient(int fd, file_role arole);
		~file_connclient();

		int get_fd();
		//int get_writeid();
		void set_fd(int num);
		entrywriter* get_Icachewriter();
		void set_Icachewriter(entrywriter* thewriter);
		filepeer* get_Itargetpeer();
		void set_Itargetpeer(filepeer* thepeer);
		int get_dstid();
		void set_dstid(int anumber);
		void set_Icachekey(string key);
		string get_Icachekey();
		//void set_writeid(int num);
		//void set_role(file_role arole);
		//file_role get_role();
};

file_connclient::file_connclient(int number)
{
	fd = number;
	thecount = NULL;
	Icachewriter = NULL;
	Itargetpeer = NULL;
	thedistributor = NULL;
	dstid = -1;
	//this->writeid = -1;
	//this->role = UNDEFINED;

	// add a null buffer
	msgbuf.push_back(new messagebuffer());
}

//file_connclient::file_connclient(int fd, file_role arole)
//{
//	this->fd = fd;
//	//this->role = arole;
//	this->writeid = -1;
//
//	// add a null buffer
//	msgbuf.push_back(new messagebuffer());
//}

file_connclient::~file_connclient()
{
	for(int i = 0; (unsigned)i < msgbuf.size(); i++)
	{
		delete msgbuf[i];
	}

	if(thecount != NULL)
		delete thecount;

	if(Icachewriter != NULL)
	{
		Icachewriter->complete();
		delete Icachewriter;
	}

	if(thedistributor != NULL)
	{
		delete thedistributor;
	}
}

int file_connclient::get_fd()
{
	return this->fd;
}

void file_connclient::set_fd(int num)
{
	this->fd = num;
}

entrywriter* file_connclient::get_Icachewriter()
{
	return Icachewriter;
}
void file_connclient::set_Icachewriter(entrywriter* thewriter)
{
	Icachewriter = thewriter;
}

filepeer* file_connclient::get_Itargetpeer()
{
	return Itargetpeer;
}

void file_connclient::set_Itargetpeer(filepeer* thepeer)
{
	Itargetpeer = thepeer;
}

int file_connclient::get_dstid()
{
	return dstid;
}

void file_connclient::set_dstid(int anumber)
{
	dstid = anumber;
}

void file_connclient::set_Icachekey(string key)
{
	Icachekey = key;
}

string file_connclient::get_Icachekey()
{
	return Icachekey;
}

//void file_connclient::set_role(file_role arole)
//{
//	this->role = arole;
//}

//file_role file_connclient::get_role()
//{
//	return this->role;
//}

//int file_connclient::get_writeid()
//{
//	return writeid;
//}

//void file_connclient::set_writeid(int num)
//{
//	writeid = num;
//}

#endif
#ifndef __MESSAGEBUFFER__
#define __MESSAGEBUFFER__

#include <unistd.h>
#include <iostream>

using namespace std;

// message can be a null string. which means that remaining
// bytes are all null character to fit into the BUF_CUT
class messagebuffer
{
private:

public:
	string message; // should be transmitted from first one
	int fd; // fd of target object
	int remain; // remaining bytes

	messagebuffer();
	messagebuffer(int number);
	messagebuffer(string amessage, int number, int aremain);
	~messagebuffer();
	void set_message(string amessage);
	void set_fd(int number);
	void set_remain(int number);
	void set_buffer(char* buf, int afd);
	void set_endbuffer(int afd);

	string get_message();
	int get_fd();
	int get_remain();
	bool is_end();
};

messagebuffer::messagebuffer()
{
	// constructor of null message
	fd = -1;
	remain = 0;
}

messagebuffer::messagebuffer(int afd) // same as end buffer
{
	fd = afd;
	remain = 0;
}

messagebuffer::messagebuffer(string amessage, int afd, int aremain)
{
	this->message = amessage;
	this->fd = afd;
	this->remain = aremain;
}

messagebuffer::~messagebuffer()
{
	// do nothing as default
}

void messagebuffer::set_buffer(char* buf, int afd)
{
	this->fd = afd;
	this->remain = BUF_CUT*(strlen(buf)/BUF_CUT+1);
	this->message = buf;
}

void messagebuffer::set_endbuffer(int afd)
{
	this->fd = afd;
	this->remain = 0;
}

void messagebuffer::set_message(string amessage)
{
	this->message = amessage;
}

void messagebuffer::set_fd(int afd)
{
	this->fd = afd;	
}

void messagebuffer::set_remain(int number)
{
	this->remain = number;
}

string messagebuffer::get_message()
{
	return this->message;
}

int messagebuffer::get_fd()
{
	return this->fd;
}

int messagebuffer::get_remain()
{
	return this->remain;
}

bool messagebuffer::is_end() // true if close(fd) is needed
{
	if(fd > 0 && remain == 0)
		return true;
	else
		return false;
}


// memset is needed explicitly before the function call
// when positive value is returned, you can still use the null buffer
// when zero value is returned, transmission is partially done. you should add another null bufferpointer
// when negative value is returned, whole message is not transmitted. you should add another null bufferpointer
int nbwritebuf(int fd, char* buf, messagebuffer* buffer)
{
	// bufferpointer <- a null buffer as an input
//cout<<"message: "<<buf<<endl;
	int written_bytes;
	int writing_bytes = BUF_CUT*(strlen(buf)/BUF_CUT+1);
if(writing_bytes == 0)
cout<<"check writing_bytes in the nbwritebuf"<<endl;
	written_bytes = write(fd, buf, writing_bytes);

//cout<<"writing bytes: "<<writing_bytes<<endl;
//cout<<"written bytes: "<<written_bytes<<endl<<endl;

	if(written_bytes == writing_bytes)
	{
		return written_bytes;
	}
	else if(written_bytes > 0)
	{
		string message = buf + written_bytes;

		buffer->set_fd(fd);
		buffer->set_message(message);
		buffer->set_remain(writing_bytes - written_bytes);

		return 0;
	}
	else // -1 returned, totally failed
	{
		string message = buf;

		buffer->set_fd(fd);
		buffer->set_message(message);
		buffer->set_remain(writing_bytes);

		return -1;
	}
}

int nbwritebuf(int fd, char* buf, int writing_bytes, messagebuffer* buffer)
{
	// bufferpointer <- a null buffer as an input
//cout<<"message: "<<buf<<endl;
	int written_bytes;
	written_bytes = write(fd, buf, writing_bytes);

//cout<<"writing bytes: "<<writing_bytes<<endl;
//cout<<"written bytes: "<<written_bytes<<endl<<endl;


	if(written_bytes == writing_bytes)
	{
		return 1;
	}
	else if(written_bytes > 0)
	{
		string message = buf + written_bytes;

		buffer->set_fd(fd);
		buffer->set_message(message);
		buffer->set_remain(writing_bytes - written_bytes);

		return 0;
	}
	else // -1 returned, totally failed
	{
		string message = buf;

		buffer->set_fd(fd);
		buffer->set_message(message);
		buffer->set_remain(writing_bytes);

		return -1;
	}
}

#endif
#include <iostream>
#include <vector>
#include <file_distributor/fileserver.hh>
#include <fstream>
#include <sstream>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/fcntl.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <mapreduce/definitions.hh>

using namespace std;

char master_address[BUF_SIZE];

bool master_is_set = false;

int port = -1;
int dhtport = -1;

fileserver afileserver;

int main(int argc, const char *argv[])
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	conf>>token;
	while(!conf.eof())
	{
		if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "port")
		{
			conf>>token;
			port = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			conf>>token;
			strcpy(master_address, token.c_str());
			master_is_set = true;
		}
		else
		{
			cout<<"[slave]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// verify initialization
	if(port == -1)
	{
		cout<<"[slave]port should be specified in the setup.conf"<<endl;
		return 1;
	}
	if(master_is_set == false)
	{
		cout<<"[slave]master_address should be specified in the setup.conf"<<endl;
		return 1;
	}
	if(dhtport == -1)
	{
		cout<<"[slave]dht port should be specified in the setup.conf"<<endl;
		return 1;
	}

	// run the file server
	afileserver.run_server(dhtport, master_address);

	return 0;
}
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <sys/unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <mapreduce/definitions.hh>
#include "cacheclient.hh"
#include "iwfrequest.hh"
#include "histogram.hh"

using namespace std;

// this process should be run on master node
// the role of this process is to manage the cache boundaries

int dhtport = -1;

int serverfd = -1;
int ipcfd = -1;

int buffersize = 8388608; // 8 MB buffer

vector<string> nodelist;
vector<cacheclient*> clients;
vector<iwfrequest*> iwfrequests;

histogram* thehistogram;

char read_buf[BUF_SIZE]; // read buffer for signal_listener thread
char write_buf[BUF_SIZE]; // write buffer for signal_listener thread

void open_server(int port);

int main(int argc, char** argv)
{
	// initialize data structures from setup.conf
	ifstream conf;
	string token;
	string confpath = LIB_PATH;
	confpath.append("setup.conf");
	conf.open(confpath.c_str());

	master_connection themaster; // from <orthrus/cacheclient.hh>

	conf>>token;
	while(!conf.eof())
	{
		if(token == "port")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "dhtport")
		{
			conf>>token;
			dhtport = atoi(token.c_str());
		}
		else if(token == "max_job")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else if(token == "master_address")
		{
			// ignore and just pass through this case
			conf>>token;
		}
		else
		{
			cout<<"[cacheserver]Unknown configure record: "<<token<<endl;
		}
		conf>>token;
	}
	conf.close();

	// read the node list information
	ifstream nodelistfile;
	string filepath = LIB_PATH;
	filepath.append("nodelist.conf");

	nodelistfile.open(filepath.c_str());
	nodelistfile>>token;

	while(!nodelistfile.eof())
	{
		nodelist.push_back(token);
		nodelistfile>>token;
	}

	if(access(IPC_PATH, F_OK) == 0)
	{
		unlink(IPC_PATH);
	}

	open_server(dhtport);
	if(serverfd < 0)
	{
		cout<<"[cacheserver]\033[0;31mOpenning server failed\033[0m"<<endl;
		return 1;
	}

	struct sockaddr_in connaddr;
	int addrlen = sizeof(connaddr);
	char* haddrp;

	// pre-allocate the clients for order of clients vector
	for(int i = 0; (unsigned)i < nodelist.size(); i++)
	{
		clients.push_back(new cacheclient(nodelist[i]));
	}

	int connectioncount = 0;
	while((unsigned)connectioncount < nodelist.size())
	{
		int fd;
		fd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);

		if(fd < 0)
		{
			cout<<"[cacheserver]Accepting failed"<<endl;

			// sleep 1 milli second. change this if necessary
			// usleep(1000);
			continue;
		}
		else if(fd == 0)
		{
			cout<<"[cacheserver]Accepting failed"<<endl;
			exit(1);
		}
		else
		{
			// get ip address of client
			haddrp = inet_ntoa(connaddr.sin_addr);

			// find the right index for connected client
			for(int i = 0; clients.size(); i++)
			{
				if(clients[i]->get_address() == haddrp)
				{
					clients[i]->set_fd(fd);
					connectioncount++;
					break;
				}
			}

			// set socket to be non-blocking socket to avoid deadlock
			fcntl(fd, F_SETFL, O_NONBLOCK);
		}
	}

	// receive master connection
	int tmpfd = accept(ipcfd, NULL, NULL);
	if(tmpfd > 0) // master is connected
	{
		int valid = 1;
		setsockopt(tmpfd, SOL_SOCKET, SO_SNDBUF, &buffersize, (socklen_t)sizeof(buffersize));
		setsockopt(tmpfd, SOL_SOCKET, SO_RCVBUF, &buffersize, (socklen_t)sizeof(buffersize));
		setsockopt(tmpfd, SOL_SOCKET, SO_REUSEADDR, &valid, sizeof(valid));
	}
	else
	{
		cout<<"[cacheserver]Connection from master is unsuccessful"<<endl;
		exit(-1);
	}

	// set fd of master
	themaster.set_fd(tmpfd);

	// set the server fd as nonblocking mode
	fcntl(serverfd, F_SETFL, O_NONBLOCK);
	fcntl(tmpfd, F_SETFL, O_NONBLOCK);

	// initialize the EM-KDE histogram
	thehistogram = new histogram(nodelist.size(), NUMBIN);

	// a main iteration loop
	int readbytes = -1;
	int fd;


	struct timeval time_start;
	struct timeval time_end;

	gettimeofday(&time_start, NULL);
	gettimeofday(&time_end, NULL);

	while(1)
	{
		fd = accept(serverfd, (struct sockaddr *) &connaddr, (socklen_t *) &addrlen);

		if(fd > 0) // a client is connected. which will send stop message
		{
			while(readbytes < 0)
				readbytes = nbread(fd, read_buf);

			if(readbytes == 0)
			{
				cout<<"[cacheserver]Connection abnormally closed from client"<<endl;
			}
			else // a message
			{
				if(strncmp(read_buf, "stop", 4) == 0)
				{
					for(int i = 0; (unsigned)i < clients.size(); i++)
					{
						close(clients[i]->get_fd());
					}
					close(serverfd);
					return 0;
				}
				else // message other than "stop"
				{
					cout<<"[cacheserver]Unexpected message from client"<<read_buf<<endl;
				}
			}
		}


		// listen to master
		readbytes = nbread(themaster.get_fd(), read_buf);

		if(readbytes == 0)
		{
			cout<<"[cacheserver]Connection abnormally closed from master(ipc)"<<endl;
			usleep(10000); // 10 msec
		}
		else if(readbytes > 0) // a message accepted
		{
			if(strncmp(read_buf, "boundaries", 10) == 0)
			{
				// distribute the updated boundaries to each nodes 
				for(int i = 0; (unsigned)i < clients.size(); i++)
				{
					nbwrite(clients[i]->get_fd(), read_buf);
				}
			}
			else if(strncmp(read_buf, "iwritefinish", 12) == 0)
			{
				string message;
				stringstream ss;
				char* token;
				int jobid;

				token = strtok(read_buf, " "); // token <- "iwritefinish"

				token = strtok(NULL, " "); // jobid
				jobid = atoi(token);

				// add the request to the vector iwfrequests
				iwfrequest* therequest = new iwfrequest(jobid);
				iwfrequests.push_back(therequest);

				// prepare message for each client
				ss << "iwritefinish ";
				ss << jobid;
				message = ss.str();
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, message.c_str());

				token = strtok(NULL, " ");

				int peerid;

				while(token != NULL)
				{
					// request to the each peer right after tokenize each peer id
					peerid = atoi(token);
					therequest->add_request(peerid);

					// send message to target client
					nbwrite(clients[peerid]->get_fd(), write_buf);
					// tokenize next peer id
					token = strtok(NULL, " ");
				}
			}
			else // unknown message
			{
				cout<<"[cacheserver]Unknown message from master node";
			}
		}

		for(int i = 0; (unsigned)i < clients.size(); i++)
		{
			// do nothing currently
			int readbytes = -1;

			readbytes = nbread(clients[i]->get_fd(), read_buf);
			if(readbytes > 0)
			{
				if(strncmp(read_buf, "iwritefinish", 12) == 0)
				{
					char* token;
					int jobid;
					int numblock;

					token = strtok(read_buf, " "); // token <- "iwritefinish"
					token = strtok(NULL, " "); // token <- jobid

					jobid = atoi(token);

					token = strtok(NULL, " "); // token <- numblock
					numblock = atoi(token);

					for(int j = 0; (unsigned)j < iwfrequests.size(); j++)
					{
						if(iwfrequests[j]->get_jobid() == jobid)
						{
							iwfrequests[j]->add_receive(i, numblock);
							break;
						}
					}
				}
				else
				{
					cout<<"[cacheserver]Abnormal message from clients"<<endl;
				}
			}
			else if(readbytes == 0)
			{
				cout<<"[cacheserver]Connection to clients abnormally closed"<<endl;
				usleep(100000);
			}
		}

		for(int i = 0; (unsigned)i < iwfrequests.size(); i++)
		{
			// check whether the request has received all responds
			if(iwfrequests[i]->is_finished())
			{
				// send numblock information in order to the master
				string message;
				stringstream ss;

				ss << "numblocks ";
				ss << iwfrequests[i]->get_jobid();

				for(int j = 0; (unsigned)j < iwfrequests[i]->peerids.size(); j++)
				{
					ss << " ";
					ss << iwfrequests[i]->numblocks[j];
				}

				message = ss.str();
				memset(write_buf, 0, BUF_SIZE);
				strcpy(write_buf, message.c_str());

				nbwrite(themaster.get_fd(), write_buf);

				// clear the iwfrequest
				delete iwfrequests[i];
				iwfrequests.erase(iwfrequests.begin() + i);
				i--;
			}
		}

		// sleeps for 1 millisecond
		// usleep(1000);
	}

	return 0;
}

void open_server(int port)
{
	struct sockaddr_in serveraddr;

	// socket open
	serverfd = socket(AF_INET, SOCK_STREAM, 0);
	if(serverfd < 0)
		cout<<"[cacheserver]Socket opening failed"<<endl;
	
	int valid = 1;
	setsockopt(serverfd, SOL_SOCKET, SO_REUSEADDR, &valid, sizeof(valid));

	// bind
	memset((void*) &serveraddr, 0, sizeof(struct sockaddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons((unsigned short) port);

	if(bind(serverfd, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) < 0)
	{
		cout<<"[cacheserver]\033[0;31mBinding failed\033[0m"<<endl;
	}

	// listen
	if(listen(serverfd, BACKLOG) < 0)
	{
		cout<<"[cacheserver]Listening failed"<<endl;
	}

	// prepare AF_UNIX socket for the master_connection
	struct sockaddr_un serveraddr2;
	ipcfd = socket(AF_UNIX, SOCK_STREAM, 0);

	if(ipcfd < 0)
	{
		cout<<"[cacheserver]AF_UNIX socket openning failed"<<endl;
		exit(-1);
	}

	// bind
	memset((void*) &serveraddr2, 0, sizeof(serveraddr2));
	serveraddr2.sun_family = AF_UNIX;
	strcpy(serveraddr2.sun_path, IPC_PATH);

	if(bind(ipcfd, (struct sockaddr *)&serveraddr2, SUN_LEN(&serveraddr2)) < 0)
	{
		cout<<"[cacheserver]IPC Binding fialed"<<endl;
		exit(-1);
	}

	// listen
	if(listen(ipcfd, BACKLOG) < 0)
	{
		cout<<"[cacheserver]Listening failed"<<endl;
		exit(-1);
	}
}
#ifndef __IWFREQUEST__
#define __IWFREQUEST__

class iwfrequest
{
	private:
		int received;
		int requested;
		int jobid;

	public:
		vector<int> peerids;
		vector<int> numblocks;

		int get_jobid();
		bool is_finished();
		iwfrequest(int ajobid);
		void add_request(int num);
		void add_receive(int index, int numblock);
};

iwfrequest::iwfrequest(int ajobid)
{
	jobid = ajobid;
	received = 0;
	requested = 0;
}

void iwfrequest::add_request(int num)
{
	peerids.push_back(num);
	numblocks.push_back(-1);
	requested++;
}

int iwfrequest::get_jobid()
{
	return jobid;
}

void iwfrequest::add_receive(int index, int numblock)
{
	for(int i = 0; (unsigned)i < peerids.size(); i++)
	{
		if(peerids[i] == index)
		{
			numblocks[i] = numblock;
			received++;
			return;
		}
	}

cout<<"check add_receive()"<<endl;

}

bool iwfrequest::is_finished()
{
	if(received == requested)
		return true;
	else
		return false;
}

#endif
#ifndef __HISTOGRAM__
#define __HISTOGRAM__

#include <iostream>
#include <mapreduce/definitions.hh>

#define MAX_UINT 4294967295

using namespace std;

class histogram
{
	private:
		int numserver; // number of server
		int numbin; // number of bin -> number of histogram bin
		// int digit; // number of digits to represent the problem space
		double* querycount; // the data access count to each 
		unsigned* boundaries; // the index of end point of each node

	public:
		histogram(); // constructs an uninitialized object
		histogram(int numserver, int numbin); // number of bin and number of digits
		~histogram();

		void initialize(); // partition the problem space equally to each bin
		void init_count(); // initialize the all query counts to zero
		unsigned get_boundary(int index);
		void set_boundary(int index, unsigned boundary);
		double get_count(int index);
		void set_count(int index, double count);
		int get_index(unsigned query); // return the dedicated node index of query
		int count_query(unsigned query);
		void updateboundary();

		void set_numbin(int num);
		int get_numbin();

		void set_numserver(int num);
		int get_numserver();
};

histogram::histogram()
{
	numbin = -1;
	numserver = -1;
	boundaries = NULL;
	querycount = NULL;
}

histogram::histogram(int numserver, int numbin)
{
	boundaries = NULL;
	querycount = NULL;

	this->numserver = numserver;
	this->numbin = numbin;
	boundaries = new unsigned[numserver];
	querycount = new double[numbin];
	
	// initialize
	this->initialize();
}

histogram::~histogram()
{
	if(boundaries != NULL)
		delete boundaries;
	if(querycount != NULL)
		delete querycount;
}

void histogram::initialize()
{
	unsigned max = MAX_UINT;

	// initialize the boundary
	for(int i = 0; i < numserver-1; i++)
	{
		boundaries[i] = (int)(((double)max/(double)numserver)*((double)(i + 1)));
	}

	boundaries[numserver-1] = max;

	// initialize the query count
	for(int i = 0; i < numbin; i++)
	{
		querycount[i] = 1.0/(double)numbin;
	}
}

void histogram::init_count()
{
	for(int i = 0; i < numbin; i++)
	{
		querycount[i] = 1.0/(double)numbin;
	}
}

void histogram::set_numbin(int num)
{
	numbin = num;

	if(querycount != NULL)
		delete querycount;

	querycount = new double[num];
}

int histogram::get_numbin()
{
	return numbin;
}
void histogram::set_numserver(int num)
{
	numserver = num;

	if(boundaries != NULL)
		delete boundaries;
	
	boundaries = new unsigned[num];
}

int histogram::get_numserver()
{
	return numserver;
}

unsigned histogram::get_boundary(int index) // the index starts from 0
{
	if(index >= numserver)
	{
		cout<<"[histogram]Index requested is out of range"<<endl;
		return -1;
	}
	else
	{
		return boundaries[index];
	}
}

void histogram::set_boundary(int index, unsigned boundary)
{
	boundaries[index] = boundary;
}

double histogram::get_count(int index)
{
	if(index >= numbin)
	{
		cout<<"[histogram]Index requested is out of range"<<endl;
		return -1.0;
	}
	else
	{
		return querycount[index];
	}
	return -1.0;
}

void histogram::set_count(int index, double count)
{
	querycount[index] = count;
}

void histogram::updateboundary() // update the boundary according to the query counts
{
	// sum up the count of all bin and divide it by number of servers(query per server)
	double qps = 0.0;
	double temp = 0.0;
	double stmeter = 0.0;
	int j = 0;

	for(int i = 0; i < numbin; i++)
	{
		qps += querycount[i];
	}

	qps = qps/numserver;

	// calculate the new boundary of each server(except the boundary of last server)
	for(int i = 0; i < numserver - 1; i++)
	{
		while(temp + querycount[j]*(1.0 - stmeter) < qps)
		{
			temp += querycount[j]*(1.0 - stmeter);
			j++;

			if(j >= numbin)
			{
				j--;
				break;
			}
			stmeter = 0.0;
		}

		if(stmeter == 0.0)
			stmeter = (qps - temp)/querycount[j];
		else
			stmeter += (qps - temp)/querycount[j];

		boundaries[i] = ((double)MAX_UINT)*(((double)j + stmeter)/((double)numbin));

		temp = 0.0;
	}

	// re-initialize the count of each bin
		// don't need to do because it is EM-KDE and old queries are automatically faded out
}

int histogram::count_query(unsigned query)
{
	// accumulate the query count to the target bin
	int index = (int)(((double)query/(double)MAX_UINT)*(double)numbin);

	if(index == numbin)
		index--;
	else if(index > numbin)
		cout<<"[histogram]Debugging: Cannot find index of requested query."<<endl;

	// alpha adjustment
	for(int i = 0; i < numbin; i++)
	{
		querycount[i] *= (1.0 - ALPHA);
	}

	// accumulate the alpha value (approximated kernel density estimation with KERNELWIDTH)
	int indexstart;
	int indexend;
	double increment;

	if(index - KERNELWIDTH < 0)
		indexstart = 0;
	else
		indexstart = index - KERNELWIDTH;
	
	if(index + KERNELWIDTH > numbin - 1)
		indexend = numbin - 1;
	else
		indexend = index + KERNELWIDTH;

	increment = ALPHA/((double)(indexend - indexstart + 1));

	for(int i = indexstart; i <= indexend; i++)
	{
		querycount[i] += increment;
	}

	return index; // returns the target index as representative histogram bin
}

int histogram::get_index(unsigned query) // return the server index range of which includes the input query
{
	for(int i = 0; i < numserver; i++)
	{
		if(query <= boundaries[i])
			return i;
	}

	cout<<"[histogram]Debugging: Cannot find index of requested query."<<endl;
	return -1;
}

#endif
#ifndef __DATABLOCK__
#define __DATABLOCK__

#include <iostream>
#include <mapreduce/definitions.hh>
#include <string.h>

using namespace std;

class datablock
{
	private:
		char* data;
		unsigned size; // block size(BLOCKSIZE) is defined in mapreduce/definitions.hh
		vector<int> recordindex; // index of start of each record

	public:
		datablock();
		~datablock();

		int write_record(string record); // true when succeeded, false when insufficient capacity
		bool read_record(unsigned pos, string& record); // -1 when data reaches end of block
		char* get_data();
		unsigned get_size();
		void set_size(unsigned num);
};

datablock::datablock()
{
	data = new char[BLOCKSIZE];
	memset(data, 0, BLOCKSIZE);
	size = 0;

	// add 0 index for the start of first record
	recordindex.push_back(0);
}

datablock::~datablock()
{
	if(data != NULL)
		delete data;
}

char* datablock::get_data()
{
	return data;
}

unsigned datablock::get_size()
{
	return size;
}

void datablock::set_size(unsigned num)
{
	size = num;
}

int datablock::write_record(string record)
{
	if(record.length() + 1 > BLOCKSIZE - size)
	{
		return -1;
	}
	else // capacity allows the data
	{
		int written_size = record.length();

		if(size > 0) // if this is not the start of block
		{
			// append newline character \n
			data[size] = '\n';
			size++;
			written_size++;
		}

		// append the contents of the record
		strcpy(data+size, record.c_str());
		size += record.length();

		// add start index of next record(end index of current record)
		recordindex.push_back(size + 1);

		return written_size;
	}
}

bool datablock::read_record(unsigned index, string& record) // return next index if there is next record, or -1
{
	if(index < recordindex.size() - 1) // there is another data to read
	{
		record.assign(data + recordindex[index], recordindex[index + 1] - recordindex[index] - 1);
		return true;
	}
	else
	{
		return false;
	}
}

#endif
#ifndef __DATAENTRY__
#define __DATAENTRY__

#include <iostream>
#include <string.h>
#include <orthrus/datablock.hh>

using namespace std;

class dataentry
{
	private:
		string filename;
		unsigned index;
		unsigned size;
		bool being_written;
		int lockcount;

	public:
		vector<datablock*> datablocks; // a member public field.

		dataentry(string name, unsigned idx);
		~dataentry();
		string get_filename();
		unsigned get_index();
		unsigned get_size();
		void set_size(unsigned num);
		void lock_entry();
		void unlock_entry();
		void mark_being_written();
		void unmark_being_written();

		bool is_locked();
		bool is_being_written();
};

dataentry::dataentry(string name, unsigned idx)
{
	filename = name;
	index = idx;
	size = 0;
	lockcount = 0;
	being_written = false;
}

dataentry::~dataentry()
{
	for(int i = 0; (unsigned)i < datablocks.size(); i++)
	{
		delete datablocks[i];
	}
}

string dataentry::get_filename()
{
	return filename;
}

unsigned dataentry::get_index()
{
	return index;
}

unsigned dataentry::get_size()
{
	return size;
}

void dataentry::set_size(unsigned num)
{
	size = num;
}

void dataentry::lock_entry()
{
	lockcount++;
}

void dataentry::unlock_entry()
{
	lockcount--;
}

void dataentry::mark_being_written()
{
	being_written = true;
}

void dataentry::unmark_being_written()
{
	being_written = false;
}

bool dataentry::is_locked()
{
	if(lockcount > 0)
		return true;
	else
		return false;
}

bool dataentry::is_being_written()
{
	return being_written;
}

// --------entryreader--------

class entryreader
{
	private:
		dataentry* targetentry;
		int blockindex;
		unsigned index;

	public:
		entryreader();
		entryreader(dataentry* entry);
		void set_targetentry(dataentry* entry);
		bool read_record(string& record); // return false when it reaches end of data
};

entryreader::entryreader()
{
	targetentry = NULL;
	blockindex = 0;
	index = 0;
}

entryreader::entryreader(dataentry* entry)
{
	targetentry = entry;
	blockindex = 0;
	index = 0;

	entry->lock_entry();
}

void entryreader::set_targetentry(dataentry* entry)
{
	targetentry = entry;
	blockindex = 0;
	index = 0;

	entry->lock_entry();
}

bool entryreader::read_record(string& record)
{
	if(targetentry->datablocks[blockindex]->read_record(index, record)) // a record successfully read
	{
		index++;
		return true;
	}
	else // no more data in current block
	{
		blockindex++;
		index = 0;

		if((unsigned)blockindex < targetentry->datablocks.size()) // next block exist
		{
			if(!targetentry->datablocks[blockindex]->read_record(index, record)) // first read must succeed from next block
			{
				cout<<"[entryreader]Debugging: Unexpected response from read_record()."<<endl;
				exit(1);
			}

			index++;
			return true;
		}
		else // no more next block
		{
			targetentry->unlock_entry();
			return false;
		}
	}
}

// --------entrywriter--------

class entrywriter
{
	private:
		dataentry* targetentry;

	public:
		entrywriter();
		entrywriter(dataentry* entry);
		void set_targetentry(dataentry* entry);
		bool write_record(string record);
		void complete(); // unlock the entry and unmark as it is not being written
};

entrywriter::entrywriter()
{
	targetentry = NULL;
}

entrywriter::entrywriter(dataentry* entry)
{
	targetentry = entry;

	entry->lock_entry();
	entry->mark_being_written();
}

void entrywriter::set_targetentry(dataentry* entry)
{
	targetentry = entry;

	entry->lock_entry();
	entry->mark_being_written();
}

bool entrywriter::write_record(string record)
{
	if(targetentry->datablocks.size() == 0) // if no block exist for this entry
		targetentry->datablocks.push_back(new datablock());

	int ret = targetentry->datablocks.back()->write_record(record);

	if(ret < 0) // record doesn't fit into the current block
	{
		targetentry->datablocks.push_back(new datablock());

		ret = targetentry->datablocks.back()->write_record(record);
		if(ret < 0) // first write must succeed from new block
		{
			cout<<"[entrywriter]Debugging: Unexpected response from write_record()."<<endl;
			exit(1);
		}

		targetentry->set_size(targetentry->get_size() + ret);
	}
	else // the record successfully written
	{
		targetentry->set_size(targetentry->get_size() + ret);
	}

	return true;
}

void entrywriter::complete()
{
	targetentry->unlock_entry();
	targetentry->unmark_being_written();
}

#endif
