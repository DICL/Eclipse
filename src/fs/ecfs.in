#!/bin/env ruby

require 'optparse'
require 'ffi'
require 'ostruct'
require 'awesome_print'
require 'json'

# This module act as a namespace for the script
module Ecfs
  CONFPATH       = "@sysconfdirfull@/eclipse.json"
  BINDIR         = "@bindirfull@"
  LIBDIR         = "@libdirfull@"

  class Core
    def self.launch 
      @nodelist = File.open(CONFPATH) { |f| JSON.parse(f.read) }["nodes"]

      `#{BINDIR}/master &`
      @nodelist.each do |node|
        `ssh #{node} #{BINDIR}/slave &`
      end

      `#{BINDIR}/cacheserver &`
      @nodelist.each do |node|
        `ssh #{node} #{BINDIR}/eclipse &`
      end
    end

    def self.die
      @nodelist = File.open(CONFPATH) { |f| JSON.parse(f.read) }["nodes"]

      `killall master`
      `killall cacheserver`
      @nodelist.each do |node|
        `ssh #{node} killall slave`
        `ssh #{node} killall eclipse`
      end
    end
  end

  class Fs
    module Eclipse
      extend FFI::Library
      ffi_lib "#{LIBDIR}/libehash.so"
      attach_function :h, [ :string , :size_t ], :ushort
      alias_method :hash, :h
    end

    def initialize
      @files           = {}
      @config          = File.open(CONFPATH) { |f| JSON.parse(f.read) }
      @nodelist        = @config["nodes"]
      @fs_path         = @config["fs_path"] + ".list"
      @fs_scratch_path = @config["fs_scratch_path"] + ".list"

    end

    def put filename:
      @files[filename] = OpenStruct.new(:name => filename,
                                        :addr => @nodelist[Eclipse.hash(filename)])
      writetodisk
    end

    def get filename:
      cat(filename)
    end

    def rm filename:
      node       = @nodelist[Eclipse.hash(filename)]
      pathtofile = @fs_scratch_path + "/" + filename
      `ssh #{node} rm -f #{pathtofile}`
    end

    def cat filename:
      hashvalue = Eclipse.hash(filename)
      puts `ssh #{hashvalue} cat #{filepath}`
    end

    def list
      ap @files
    end

    #def clear
    #end

    def writetodisk
      File.open(@fs_path, 'w') { |f| f.write(JSON.generate(@files)) }
    end

  end

  class CLI_driver < Fs 
    def initialize input: #{{{
      @options = {}

      OptionParser.new do |opts|
        opts.banner = <<EOF
ecfs (Eclipse FileSystem) is an script to manage the fs
Usage: ecfs [-v/--verbose] [options]
EOF
        opts.version = 1.0
        opts.program_name = "Eclipse Launcher"
        opts.separator "\nCore options"
        opts.on("-l", "--launch", "Create new openchord network") { Core.launch }
        opts.on("-d", "--die", "Close the network") { Core.die}
        opts.separator "\nFilesystem options"
        opts.on("-p", "--put FILE", "insert FILE") {|f| put(f) }
        opts.on("-g", "--get FILE", "get FILE") { |f| get(f)}
        opts.separator ""
        opts.on_tail("-h", "--help"   , "recursive this") { puts opts }
      end.parse! input
    end #}}}
  end
end

Ecfs::CLI_driver.new input: ARGV
