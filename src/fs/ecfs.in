#!/bin/env ruby

require 'optparse'
require 'ffi'
require 'ostruct'
require 'awesome_print'
require 'json'

# This module act as a namespace for the script
module Ecfs
  CONFPATH = "@sysconfdirfull@/eclipse.json"
  BINDIR   = "@bindirfull@"
  LIBDIR   = "@libdirfull@"

  class Core #{{{
    def self.launch 
      @nodelist = File.open(CONFPATH) { |f| JSON.parse(f.read) }["nodes"]

      `#{BINDIR}/master &>/dev/null &`
      `sleep 1`
      @nodelist.each do |node|
        system "ssh #{node} 'nohup #{BINDIR}/slave </dev/null &>/dev/null & exit'"
      end

      `#{BINDIR}/cacheserver &>/dev/null &`
      `sleep 1`
      @nodelist.each do |node|
        system "ssh #{node} 'nohup #{BINDIR}/eclipse </dev/null &>/dev/null & exit'"
      end
    end

    # :TODO: big refactor
    def self.show 
      @nodelist = File.open(CONFPATH) { |f| JSON.parse(f.read) }["nodes"]
      `pgrep -u #{`whoami`.chomp} master`
      status = $?.exitstatus == 0 ? "Running" : "Stopped"

      `pgrep -u #{`whoami`.chomp} cacheserver`
      status2 = $?.exitstatus == 0 ? "Running" : "Stopped"
      puts "#{"Localhost".green} [Master: #{status.red}] [Cacheserver: #{status2.red}]"
      @nodelist.each do |node|                                    # Kill for each of the nodes
        `ssh #{node} pgrep -u #{`whoami`.chomp} slave`
        status = $?.exitstatus == 0 ? "Running" : "Stopped"

        `ssh #{node} pgrep -u #{`whoami`.chomp} eclipse`
        status2 = $?.exitstatus == 0 ? "Running" : "Stopped"
        puts "#{`ssh #{node} hostname`.chomp.green} [Slave: #{status.red}] [Eclipse: #{status2.red}]"
      end
    end 

    def self.die
      @nodelist = File.open(CONFPATH) { |f| JSON.parse(f.read) }["nodes"]

      `pkill -u #{`whoami`.chomp} master`
      `pkill -u #{`whoami`.chomp} cacheserver`
      @nodelist.each do |node|
        `ssh #{node} pkill -u #{`whoami`.chomp} slave`
        `ssh #{node} pkill -u #{`whoami`.chomp} eclipse`
      end
    end
  end #}}}

  class Fs
    module Eclipse
      extend FFI::Library
      ffi_lib "#{LIBDIR}/libehash.so"
      attach_function :h, [ :string , :size_t ], :ushort
      alias_method :hash, :h
    end

    def initialize
      @files           = {}
      @config          = File.open(CONFPATH) { |f| JSON.parse(f.read) }
      @nodelist        = @config["nodes"]
      @fs_path         = @config["fs_path"] + ".list"
      @fs_scratch_path = @config["fs_scratch_path"] + ".list"

    end

    def put filename:
      @files[filename] = OpenStruct.new(:name => filename,
                                        :addr => @nodelist[Eclipse.hash(filename)])
      writetodisk
    end

    def get filename:
      cat(filename)
    end

    def rm filename:
      node       = @nodelist[Eclipse.hash(filename)]
      pathtofile = @fs_scratch_path + "/" + filename
      `ssh #{node} rm -f #{pathtofile}`
    end

    def cat filename:
      hashvalue = Eclipse.hash(filename)
      puts `ssh #{hashvalue} cat #{filepath}`
    end

    def list
      ap @files
    end

    #def clear
    #end

    def writetodisk
      File.open(@fs_path, 'w') { |f| f.write(JSON.generate(@files)) }
    end

  end

  class CLI_driver < Fs 
    def initialize input: #{{{
      @options = {}

      OptionParser.new do |opts|
        opts.banner = <<EOF
ecfs (Eclipse FileSystem) is an script to manage the fs
Usage: ecfs [-v/--verbose] [options]
EOF
        opts.version = 1.0
        opts.program_name = "Eclipse Launcher"
        opts.separator "\nCore options"
        opts.on("-l", "--launch", "Create new openchord network") { Core.launch }
        opts.on("-d", "--die", "Close the network") { Core.die}
        opts.on("-s", "--status", "Close the network") { Core.show}
        opts.separator "\nFilesystem options"
        opts.on("-p", "--put FILE", "insert FILE") {|f| put(f) }
        opts.on("-g", "--get FILE", "get FILE") { |f| get(f)}
        opts.separator ""
        opts.on_tail("-h", "--help"   , "recursive this") { puts opts }
      end.parse! input
    end #}}}
  end
end

Ecfs::CLI_driver.new input: ARGV
