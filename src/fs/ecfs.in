#!/bin/env ruby
# vim: ft=ruby : fileencoding=utf-8 : foldmethod=marker : set autoindent
# Author:: Vicente Adolfo Bolea Sanchez <vicente.bolea@gmail.com>
#
require 'optparse'          # For parsing the options
require 'ffi'               # For loading C functions, in this case the hash functions
require 'awesome_print'     #
require 'json'              # 

# This module act as a namespace for the script
module Ecfs
  CONFPATH = "@sysconfdirfull@/eclipse.json"
  BINDIR   = "@bindirfull@"
  LIBDIR   = "@libdirfull@"
  CXX      = "@CXX@"

  class Core 
    # Initialize {{{
    def initialize 
      @nodelist = File.open(find_confpath) { |f| JSON.parse(f.read) }['network']['nodes']
      @verbose  = false
    end

    # }}}
    # find_confpath {{{
    def find_confpath
      home = "#{ENV['HOME']}/.eclipse.json"
      etc  = "/etc/.eclipse.json"

      if File.exists? home
        return home
      elsif File.exists? etc
        return etc
      else
        return CONFPATH
      end 
    end
    # }}}
    # launch {{{
    def launch
      `#{BINDIR}/master &>/dev/null &`
      `sleep 1`
      @nodelist.each do |node|
        system "ssh #{node} 'nohup #{BINDIR}/slave </dev/null &>/dev/null & exit'"
      end

      `#{BINDIR}/cacheserver &>/dev/null &`
      `sleep 4`
      @nodelist.each do |node|
        system "ssh #{node} 'nohup #{BINDIR}/eclipse </dev/null &>/dev/null & exit'"
      end
    end 

    #}}}
    # show {{{
    def show 
      `pgrep -u #{`whoami`.chomp} master`
      status = $?.exitstatus == 0 ? "Running" : "Stopped"

      `pgrep -u #{`whoami`.chomp} cacheserver`
      status2 = $?.exitstatus == 0 ? "Running" : "Stopped"
      puts "#{"Localhost".green} [Master: #{status.red}] [Cacheserver: #{status2.red}]"

      @nodelist.each do |node|                                    # Kill for each of the nodes
        `ssh #{node} pgrep -u #{`whoami`.chomp} slave`
        status = $?.exitstatus == 0 ? "Running" : "Stopped"

        `ssh #{node} pgrep -u #{`whoami`.chomp} eclipse`
        status2 = $?.exitstatus == 0 ? "Running" : "Stopped"
        puts "#{`ssh #{node} hostname`.chomp.green} [Slave: #{status.red}] [Eclipse: #{status2.red}]"
      end
    end 

    #}}}
    # close {{{
    def close
      `pkill -u #{`whoami`.chomp} master`
      `pkill -u #{`whoami`.chomp} cacheserver`
      @nodelist.each do |node|
        `ssh #{node} pkill -u #{`whoami`.chomp} slave`
        `ssh #{node} pkill -u #{`whoami`.chomp} eclipse`
      end 
    end #}}}
  end

  class Fs < Core
    module Eclipse  #{{{
      extend FFI::Library
      ffi_lib "#{LIBDIR}/libecfs.so"
      attach_function :h, [ :string , :size_t ], :ushort
    end

    #}}} 
    def initialize #{{{
      @files           = {}
      @config          = File.open(find_confpath) { |f| JSON.parse(f.read) }
      @fs_path         = @config['path']['filesystem']
      @fs_scratch_path = @config['path']['scratch']
      @fs_tmpfile      = @fs_path + "/.list"
      @files           = File.open(@fs_tmpfile) { |f| JSON.parse(f.read) } if File.exist? @fs_tmpfile
      super()
    end

    def hash(input);         Eclipse.h(input, input.length) end
    def node_containing(fn); @nodelist[hash(fn) % @nodelist.length] end

    #}}}
    # put {{{
    def put(input)
      input.each do |fn|
        node = node_containing(fn)
        @files[fn] = node

        File.open(@fs_tmpfile, 'w') { |f| f.write(JSON.generate(@files)) }
        cmd = "scp #{@fs_path}/#{fn} #{node}:#{@fs_scratch_path}/#{fn}"
        puts cmd if @verbose
        system cmd
      end
    end

    #}}}
    # get {{{
    def get(input)
      input.each do |fn|
        raise "\'#{fn}\' not found in Eclipse FS" unless @files[fn]
        system "ssh #{node_containing(fn)} cat #{@fs_scratch_path}/#{fn}"
      end
    end

    #}}}
    # rm {{{
    def rm(input)
      input = @files.keys.grep(%r[#{@regex}]) if @regex

      input.each do |fn|
        raise "\'#{fn}\' not found in Eclipse FS" unless @files[fn]

        node = node_containing(fn)
        pathtofile = @fs_scratch_path + "/" + fn
        cmd = "ssh #{node} rm -f #{pathtofile}"
        puts cmd if @verbose
        system cmd
        @files.delete(fn)
        File.open(@fs_tmpfile, 'w') { |f| f.write(JSON.generate(@files)) }
      end
    end

    #}}}
    def list #{{{
      ap @files
    end

    #}}}
    def config #{{{
      ap self.instance_variables.map{|var|  [var, self.instance_variable_get(var)]}.to_h
    end  #}}}
    # mcc {{{
    def mcc(input)
      sources = input.join(' ')
      raise 'Need to specify output file (-o File)' unless @outputfile 

      cmd = "#{CXX} -static -o #{@outputfile} #{sources} -l ecfs"
      puts cmd if @verbose
      system cmd
    end

    #}}}
    def clear #{{{
      rm @files.keys
    end
    #}}}
  end

  class CLI_driver < Fs 
    def initialize input:  #{{{
      @options = {}
      super()
      OptionParser.new do |opts|
        opts.banner = "ecfs (Eclipse FileSystem) is an script to manage the fs\n" +
          "Usage: ecfs [options] <actions> [FILE]..."
        opts.version = 1.0
        opts.program_name = "Eclipse Launcher"
        opts.separator "Core actions"
        opts.separator "    launch       Create new Eclipse network"
        opts.separator "    close        Close the network"
        opts.separator "    status       Check the status of the network"
        opts.separator ""
        opts.separator "Filesystem actions"
        opts.separator "    put FILE...  insert FILE..."
        opts.separator "    get FILE...  \'cat\' the FILE..."
        opts.separator "    rm FILE...   remove FILE..."
        opts.separator "    clear        remove all the files in the FS"
        opts.separator "    ls           list all the files in the FS"
        opts.separator "    config       list all the internal variables"
        opts.separator "    mcc -o OUTPUT INPUT...  Compile file with EclipseFS API using OUTPUT name"
        opts.separator ""
        opts.separator "Options"
        opts.on_tail("-h", "--help"   , "recursive this")         { puts opts; exit}
        opts.on_tail("-v", "--verbose" , "printout verbose info") { @verbose = true }
        opts.on_tail("-V", "--version" , "printout version") { puts opts.ver; exit }
        opts.on_tail("-o FILE", "output file, for mcc") { |f| @outputfile = f }
        opts.on_tail("-r REGEX", "regex for remove or ls") { |r| @regex = r }
      end.parse! input

      case input.shift
      when 'launch' then launch
      when 'close' then  close
      when 'status' then show
      when 'put' then    put input
      when 'get' then    get input
      when 'rm' then     rm input
      when 'clear' then  clear
      when 'ls' then     list
      when 'config' then config 
      when 'mcc' then    mcc input
      else               raise "Not action given"
      end
    end #}}}
  end
end

Ecfs::CLI_driver.new input: ARGV
